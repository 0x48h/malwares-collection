<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Exported from Notepad++</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc1 {
	color: #008000;
}
.sc4 {
	color: #FF8000;
}
.sc5 {
	font-weight: bold;
	color: #0000FF;
}
.sc9 {
	color: #804000;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc11 {
}
.sc16 {
	color: #8000FF;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc1">/* inflate.h -- internal inflate state definition
 * Copyright (C) 1995-2004 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */</span><span class="sc0">

</span><span class="sc1">/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */</span><span class="sc0">

</span><span class="sc1">/* define NO_GZIP when compiling if you want to disable gzip header and
   trailer decoding by inflate().  NO_GZIP would be used to avoid linking in
   the crc code when it is not needed.  For shared libraries, gzip decoding
   should be left enabled. */</span><span class="sc0">
</span><span class="sc9">#ifndef NO_GZIP
#  define GUNZIP
#endif
</span><span class="sc0">
</span><span class="sc1">/* Possible inflate modes between inflate() calls */</span><span class="sc0">
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">enum</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">HEAD</span><span class="sc10">,</span><span class="sc0">       </span><span class="sc1">/* i: waiting for magic header */</span><span class="sc0">
    </span><span class="sc11">FLAGS</span><span class="sc10">,</span><span class="sc0">      </span><span class="sc1">/* i: waiting for method and flags (gzip) */</span><span class="sc0">
    </span><span class="sc11">TIME</span><span class="sc10">,</span><span class="sc0">       </span><span class="sc1">/* i: waiting for modification time (gzip) */</span><span class="sc0">
    </span><span class="sc11">OS</span><span class="sc10">,</span><span class="sc0">         </span><span class="sc1">/* i: waiting for extra flags and operating system (gzip) */</span><span class="sc0">
    </span><span class="sc11">EXLEN</span><span class="sc10">,</span><span class="sc0">      </span><span class="sc1">/* i: waiting for extra length (gzip) */</span><span class="sc0">
    </span><span class="sc11">EXTRA</span><span class="sc10">,</span><span class="sc0">      </span><span class="sc1">/* i: waiting for extra bytes (gzip) */</span><span class="sc0">
    </span><span class="sc11">NAME</span><span class="sc10">,</span><span class="sc0">       </span><span class="sc1">/* i: waiting for end of file name (gzip) */</span><span class="sc0">
    </span><span class="sc11">COMMENT</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc1">/* i: waiting for end of comment (gzip) */</span><span class="sc0">
    </span><span class="sc11">HCRC</span><span class="sc10">,</span><span class="sc0">       </span><span class="sc1">/* i: waiting for header crc (gzip) */</span><span class="sc0">
    </span><span class="sc11">DICTID</span><span class="sc10">,</span><span class="sc0">     </span><span class="sc1">/* i: waiting for dictionary check value */</span><span class="sc0">
    </span><span class="sc11">DICT</span><span class="sc10">,</span><span class="sc0">       </span><span class="sc1">/* waiting for inflateSetDictionary() call */</span><span class="sc0">
        </span><span class="sc11">TYPE</span><span class="sc10">,</span><span class="sc0">       </span><span class="sc1">/* i: waiting for type bits, including last-flag bit */</span><span class="sc0">
        </span><span class="sc11">TYPEDO</span><span class="sc10">,</span><span class="sc0">     </span><span class="sc1">/* i: same, but skip check to exit inflate on new block */</span><span class="sc0">
        </span><span class="sc11">STORED</span><span class="sc10">,</span><span class="sc0">     </span><span class="sc1">/* i: waiting for stored size (length and complement) */</span><span class="sc0">
        </span><span class="sc11">COPY</span><span class="sc10">,</span><span class="sc0">       </span><span class="sc1">/* i/o: waiting for input or output to copy stored block */</span><span class="sc0">
        </span><span class="sc11">TABLE</span><span class="sc10">,</span><span class="sc0">      </span><span class="sc1">/* i: waiting for dynamic block table lengths */</span><span class="sc0">
        </span><span class="sc11">LENLENS</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc1">/* i: waiting for code length code lengths */</span><span class="sc0">
        </span><span class="sc11">CODELENS</span><span class="sc10">,</span><span class="sc0">   </span><span class="sc1">/* i: waiting for length/lit and distance code lengths */</span><span class="sc0">
            </span><span class="sc11">LEN</span><span class="sc10">,</span><span class="sc0">        </span><span class="sc1">/* i: waiting for length/lit code */</span><span class="sc0">
            </span><span class="sc11">LENEXT</span><span class="sc10">,</span><span class="sc0">     </span><span class="sc1">/* i: waiting for length extra bits */</span><span class="sc0">
            </span><span class="sc11">DIST</span><span class="sc10">,</span><span class="sc0">       </span><span class="sc1">/* i: waiting for distance code */</span><span class="sc0">
            </span><span class="sc11">DISTEXT</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc1">/* i: waiting for distance extra bits */</span><span class="sc0">
            </span><span class="sc11">MATCH</span><span class="sc10">,</span><span class="sc0">      </span><span class="sc1">/* o: waiting for output space to copy string */</span><span class="sc0">
            </span><span class="sc11">LIT</span><span class="sc10">,</span><span class="sc0">        </span><span class="sc1">/* o: waiting for output space to write literal */</span><span class="sc0">
    </span><span class="sc11">CHECK</span><span class="sc10">,</span><span class="sc0">      </span><span class="sc1">/* i: waiting for 32-bit check value */</span><span class="sc0">
    </span><span class="sc11">LENGTH</span><span class="sc10">,</span><span class="sc0">     </span><span class="sc1">/* i: waiting for 32-bit length (gzip) */</span><span class="sc0">
    </span><span class="sc11">DONE</span><span class="sc10">,</span><span class="sc0">       </span><span class="sc1">/* finished check, done -- remain here until reset */</span><span class="sc0">
    </span><span class="sc11">BAD</span><span class="sc10">,</span><span class="sc0">        </span><span class="sc1">/* got a data error -- remain here until reset */</span><span class="sc0">
    </span><span class="sc11">MEM</span><span class="sc10">,</span><span class="sc0">        </span><span class="sc1">/* got an inflate() memory error -- remain here until reset */</span><span class="sc0">
    </span><span class="sc11">SYNC</span><span class="sc0">        </span><span class="sc1">/* looking for synchronization bytes to restart inflate() */</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">inflate_mode</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc1">/*
    State transitions between above modes -

    (most modes can go to the BAD or MEM mode -- not shown for clarity)

    Process header:
        HEAD -&gt; (gzip) or (zlib)
        (gzip) -&gt; FLAGS -&gt; TIME -&gt; OS -&gt; EXLEN -&gt; EXTRA -&gt; NAME
        NAME -&gt; COMMENT -&gt; HCRC -&gt; TYPE
        (zlib) -&gt; DICTID or TYPE
        DICTID -&gt; DICT -&gt; TYPE
    Read deflate blocks:
            TYPE -&gt; STORED or TABLE or LEN or CHECK
            STORED -&gt; COPY -&gt; TYPE
            TABLE -&gt; LENLENS -&gt; CODELENS -&gt; LEN
    Read deflate codes:
                LEN -&gt; LENEXT or LIT or TYPE
                LENEXT -&gt; DIST -&gt; DISTEXT -&gt; MATCH -&gt; LEN
                LIT -&gt; LEN
    Process trailer:
        CHECK -&gt; LENGTH -&gt; DONE
 */</span><span class="sc0">

</span><span class="sc1">/* state maintained between inflate() calls.  Approximately 7K bytes. */</span><span class="sc0">
</span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">inflate_state</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">inflate_mode</span><span class="sc0"> </span><span class="sc11">mode</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* current inflate mode */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">last</span><span class="sc10">;</span><span class="sc0">                   </span><span class="sc1">/* true if processing last block */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">wrap</span><span class="sc10">;</span><span class="sc0">                   </span><span class="sc1">/* bit 0 true for zlib, bit 1 true for gzip */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">havedict</span><span class="sc10">;</span><span class="sc0">               </span><span class="sc1">/* true if dictionary provided */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">flags</span><span class="sc10">;</span><span class="sc0">                  </span><span class="sc1">/* gzip header method and flags (0 if zlib) */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">dmax</span><span class="sc10">;</span><span class="sc0">              </span><span class="sc1">/* zlib header max distance (INFLATE_STRICT) */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc0"> </span><span class="sc11">check</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc1">/* protected copy of check value */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc0"> </span><span class="sc11">total</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc1">/* protected copy of output count */</span><span class="sc0">
    </span><span class="sc11">gz_headerp</span><span class="sc0"> </span><span class="sc11">head</span><span class="sc10">;</span><span class="sc0">            </span><span class="sc1">/* where to save gzip header information */</span><span class="sc0">
        </span><span class="sc1">/* sliding window */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">wbits</span><span class="sc10">;</span><span class="sc0">             </span><span class="sc1">/* log base 2 of requested window size */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">wsize</span><span class="sc10">;</span><span class="sc0">             </span><span class="sc1">/* window size or zero if not using window */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">whave</span><span class="sc10">;</span><span class="sc0">             </span><span class="sc1">/* valid bytes in the window */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">write</span><span class="sc10">;</span><span class="sc0">             </span><span class="sc1">/* window write index */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc11">FAR</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">window</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* allocated sliding window, if needed */</span><span class="sc0">
        </span><span class="sc1">/* bit accumulator */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc0"> </span><span class="sc11">hold</span><span class="sc10">;</span><span class="sc0">         </span><span class="sc1">/* input bit accumulator */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">;</span><span class="sc0">              </span><span class="sc1">/* number of bits in "in" */</span><span class="sc0">
        </span><span class="sc1">/* for string and stored block copying */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">;</span><span class="sc0">            </span><span class="sc1">/* literal or length of data to copy */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">offset</span><span class="sc10">;</span><span class="sc0">            </span><span class="sc1">/* distance back to copy string from */</span><span class="sc0">
        </span><span class="sc1">/* for table and code decoding */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">extra</span><span class="sc10">;</span><span class="sc0">             </span><span class="sc1">/* extra bits needed */</span><span class="sc0">
        </span><span class="sc1">/* fixed and dynamic code tables */</span><span class="sc0">
    </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">FAR</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">lencode</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc1">/* starting table for length/literal codes */</span><span class="sc0">
    </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">FAR</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">distcode</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc1">/* starting table for distance codes */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">lenbits</span><span class="sc10">;</span><span class="sc0">           </span><span class="sc1">/* index bits for lencode */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">distbits</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* index bits for distcode */</span><span class="sc0">
        </span><span class="sc1">/* dynamic table building */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">ncode</span><span class="sc10">;</span><span class="sc0">             </span><span class="sc1">/* number of code length code lengths */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">nlen</span><span class="sc10">;</span><span class="sc0">              </span><span class="sc1">/* number of length code lengths */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">ndist</span><span class="sc10">;</span><span class="sc0">             </span><span class="sc1">/* number of distance code lengths */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">have</span><span class="sc10">;</span><span class="sc0">              </span><span class="sc1">/* number of code lengths in lens[] */</span><span class="sc0">
    </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc11">FAR</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">next</span><span class="sc10">;</span><span class="sc0">             </span><span class="sc1">/* next available space in codes[] */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">short</span><span class="sc0"> </span><span class="sc11">lens</span><span class="sc10">[</span><span class="sc4">320</span><span class="sc10">];</span><span class="sc0">   </span><span class="sc1">/* temporary storage for code lengths */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">short</span><span class="sc0"> </span><span class="sc11">work</span><span class="sc10">[</span><span class="sc4">288</span><span class="sc10">];</span><span class="sc0">   </span><span class="sc1">/* work area for code table building */</span><span class="sc0">
    </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc11">codes</span><span class="sc10">[</span><span class="sc11">ENOUGH</span><span class="sc10">];</span><span class="sc0">         </span><span class="sc1">/* space for code tables */</span><span class="sc0">
</span><span class="sc10">};</span><span class="sc0">
</span></div></body>
</html>
