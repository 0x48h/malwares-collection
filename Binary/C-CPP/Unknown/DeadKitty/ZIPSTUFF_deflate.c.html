<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Exported from Notepad++</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc1 {
	color: #008000;
}
.sc4 {
	color: #FF8000;
}
.sc5 {
	font-weight: bold;
	color: #0000FF;
}
.sc6 {
	color: #808080;
}
.sc9 {
	color: #804000;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc11 {
}
.sc16 {
	color: #8000FF;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc1">/* deflate.c -- compress data using the deflation algorithm
 * Copyright (C) 1995-2005 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */</span><span class="sc0">

</span><span class="sc1">/*
 *  ALGORITHM
 *
 *      The "deflation" process depends on being able to identify portions
 *      of the input text which are identical to earlier input (within a
 *      sliding window trailing behind the input currently being processed).
 *
 *      The most straightforward technique turns out to be the fastest for
 *      most input files: try all possible matches and select the longest.
 *      The key feature of this algorithm is that insertions into the string
 *      dictionary are very simple and thus fast, and deletions are avoided
 *      completely. Insertions are performed at each input character, whereas
 *      string matches are performed only when the previous match ends. So it
 *      is preferable to spend more time in matches to allow very fast string
 *      insertions and avoid deletions. The matching algorithm for small
 *      strings is inspired from that of Rabin &amp; Karp. A brute force approach
 *      is used to find longer strings when a small match has been found.
 *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
 *      (by Leonid Broukhis).
 *         A previous version of this file used a more sophisticated algorithm
 *      (by Fiala and Greene) which is guaranteed to run in linear amortized
 *      time, but has a larger average cost, uses more memory and is patented.
 *      However the F&amp;G algorithm may be faster for some highly redundant
 *      files if the parameter max_chain_length (described below) is too large.
 *
 *  ACKNOWLEDGEMENTS
 *
 *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
 *      I found it in 'freeze' written by Leonid Broukhis.
 *      Thanks to many people for bug reports and testing.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
 *      Available in http://www.ietf.org/rfc/rfc1951.txt
 *
 *      A description of the Rabin and Karp algorithm is given in the book
 *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
 *
 *      Fiala,E.R., and Greene,D.H.
 *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
 *
 */</span><span class="sc0">

</span><span class="sc1">/* @(#) $Id$ */</span><span class="sc0">

</span><span class="sc9">#include "deflate.h"
</span><span class="sc0">
</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc11">deflate_copyright</span><span class="sc10">[]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0">
   </span><span class="sc6">" deflate 1.2.3 Copyright 1995-2005 Jean-loup Gailly "</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc1">/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 *  Function prototypes.
 */</span><span class="sc0">
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">enum</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">need_more</span><span class="sc10">,</span><span class="sc0">      </span><span class="sc1">/* block not completed, need more input or more output */</span><span class="sc0">
    </span><span class="sc11">block_done</span><span class="sc10">,</span><span class="sc0">     </span><span class="sc1">/* block flush performed */</span><span class="sc0">
    </span><span class="sc11">finish_started</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc1">/* finish started, need only more output at next deflate */</span><span class="sc0">
    </span><span class="sc11">finish_done</span><span class="sc0">     </span><span class="sc1">/* finish done, accept no more input or output */</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">block_state</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc11">block_state</span><span class="sc0"> </span><span class="sc10">(*</span><span class="sc11">compress_func</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc1">/* Compression function. Returns the block state after the call. */</span><span class="sc0">

</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">fill_window</span><span class="sc0">    </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc11">block_state</span><span class="sc0"> </span><span class="sc11">deflate_stored</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc11">block_state</span><span class="sc0"> </span><span class="sc11">deflate_fast</span><span class="sc0">   </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc9">#ifndef FASTEST
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc11">block_state</span><span class="sc0"> </span><span class="sc11">deflate_slow</span><span class="sc0">   </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">lm_init</span><span class="sc0">        </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">putShortMSB</span><span class="sc0">    </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">b</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">flush_pending</span><span class="sc0">  </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">z_streamp</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">read_buf</span><span class="sc0">        </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">z_streamp</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">Bytef</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc9">#ifndef FASTEST
#ifdef ASMV
</span><span class="sc0">      </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">match_init</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc16">void</span><span class="sc10">));</span><span class="sc0"> </span><span class="sc1">/* asm code initialization */</span><span class="sc0">
      </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">longest_match</span><span class="sc0">  </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">IPos</span><span class="sc0"> </span><span class="sc11">cur_match</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc9">#else
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">longest_match</span><span class="sc0">  </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">IPos</span><span class="sc0"> </span><span class="sc11">cur_match</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc9">#endif
#endif
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">longest_match_fast</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">IPos</span><span class="sc0"> </span><span class="sc11">cur_match</span><span class="sc10">));</span><span class="sc0">

</span><span class="sc9">#ifdef DEBUG
</span><span class="sc11">local</span><span class="sc0">  </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">check_match</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">IPos</span><span class="sc0"> </span><span class="sc11">start</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">IPos</span><span class="sc0"> </span><span class="sc11">match</span><span class="sc10">,</span><span class="sc0">
                            </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
</span><span class="sc1">/* ===========================================================================
 * Local data
 */</span><span class="sc0">

</span><span class="sc9">#define NIL 0
</span><span class="sc1">/* Tail of hash chains */</span><span class="sc0">

</span><span class="sc9">#ifndef TOO_FAR
#  define TOO_FAR 4096
#endif
</span><span class="sc1">/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */</span><span class="sc0">

</span><span class="sc9">#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
</span><span class="sc1">/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */</span><span class="sc0">

</span><span class="sc1">/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */</span><span class="sc0">
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">config_s</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
   </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">good_length</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* reduce lazy search above this match length */</span><span class="sc0">
   </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">max_lazy</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc1">/* do not perform lazy search above this match length */</span><span class="sc0">
   </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">nice_length</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* quit search above this match length */</span><span class="sc0">
   </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">max_chain</span><span class="sc10">;</span><span class="sc0">
   </span><span class="sc11">compress_func</span><span class="sc0"> </span><span class="sc11">func</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">config</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc9">#ifdef FASTEST
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">config</span><span class="sc0"> </span><span class="sc11">configuration_table</span><span class="sc10">[</span><span class="sc4">2</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
</span><span class="sc1">/*      good lazy nice chain */</span><span class="sc0">
</span><span class="sc1">/* 0 */</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0">  </span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">deflate_stored</span><span class="sc10">},</span><span class="sc0">  </span><span class="sc1">/* store only */</span><span class="sc0">
</span><span class="sc1">/* 1 */</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0">  </span><span class="sc4">8</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">deflate_fast</span><span class="sc10">}};</span><span class="sc0"> </span><span class="sc1">/* max speed, no lazy matches */</span><span class="sc0">
</span><span class="sc9">#else
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">config</span><span class="sc0"> </span><span class="sc11">configuration_table</span><span class="sc10">[</span><span class="sc4">10</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
</span><span class="sc1">/*      good lazy nice chain */</span><span class="sc0">
</span><span class="sc1">/* 0 */</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0">  </span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">deflate_stored</span><span class="sc10">},</span><span class="sc0">  </span><span class="sc1">/* store only */</span><span class="sc0">
</span><span class="sc1">/* 1 */</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0">  </span><span class="sc4">8</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">deflate_fast</span><span class="sc10">},</span><span class="sc0"> </span><span class="sc1">/* max speed, no lazy matches */</span><span class="sc0">
</span><span class="sc1">/* 2 */</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">5</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">16</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">8</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">deflate_fast</span><span class="sc10">},</span><span class="sc0">
</span><span class="sc1">/* 3 */</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">6</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">32</span><span class="sc10">,</span><span class="sc0">   </span><span class="sc4">32</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">deflate_fast</span><span class="sc10">},</span><span class="sc0">

</span><span class="sc1">/* 4 */</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">16</span><span class="sc10">,</span><span class="sc0">   </span><span class="sc4">16</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">deflate_slow</span><span class="sc10">},</span><span class="sc0">  </span><span class="sc1">/* lazy matches */</span><span class="sc0">
</span><span class="sc1">/* 5 */</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">8</span><span class="sc10">,</span><span class="sc0">   </span><span class="sc4">16</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">32</span><span class="sc10">,</span><span class="sc0">   </span><span class="sc4">32</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">deflate_slow</span><span class="sc10">},</span><span class="sc0">
</span><span class="sc1">/* 6 */</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">8</span><span class="sc10">,</span><span class="sc0">   </span><span class="sc4">16</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">128</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">128</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">deflate_slow</span><span class="sc10">},</span><span class="sc0">
</span><span class="sc1">/* 7 */</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">8</span><span class="sc10">,</span><span class="sc0">   </span><span class="sc4">32</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">128</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">256</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">deflate_slow</span><span class="sc10">},</span><span class="sc0">
</span><span class="sc1">/* 8 */</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">32</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">128</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">258</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">1024</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">deflate_slow</span><span class="sc10">},</span><span class="sc0">
</span><span class="sc1">/* 9 */</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">32</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">258</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">258</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">4096</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">deflate_slow</span><span class="sc10">}};</span><span class="sc0"> </span><span class="sc1">/* max compression */</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
</span><span class="sc1">/* Note: the deflate() code requires max_lazy &gt;= MIN_MATCH and max_chain &gt;= 4
 * For deflate_fast() (levels &lt;= 3) good is ignored and lazy has a different
 * meaning.
 */</span><span class="sc0">

</span><span class="sc9">#define EQUAL 0
</span><span class="sc1">/* result of memcmp for equal strings */</span><span class="sc0">

</span><span class="sc9">#ifndef NO_DUMMY_DECL
</span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">static_tree_desc_s</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">dummy</span><span class="sc10">;};</span><span class="sc0"> </span><span class="sc1">/* for buggy compilers */</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
</span><span class="sc1">/* ===========================================================================
 * Update a hash value with the given input byte
 * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
 *    input characters, so that a running hash key can be computed from the
 *    previous key instead of complete recalculation each time.
 */</span><span class="sc0">
</span><span class="sc9">#define UPDATE_HASH(s,h,c) (h = (((h)&lt;&lt;s-&gt;hash_shift) ^ (c)) &amp; s-&gt;hash_mask)
</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Insert string str in the dictionary and set match_head to the previous head
 * of the hash chain (the most recent string with same hash key). Return
 * the previous length of the hash chain.
 * If this file is compiled with -DFASTEST, the compression level is forced
 * to 1, and no hash chains are maintained.
 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
 *    input characters and the first MIN_MATCH bytes of str are valid
 *    (except for the last MIN_MATCH-1 bytes of the input file).
 */</span><span class="sc0">
</span><span class="sc9">#ifdef FASTEST
#define INSERT_STRING(s, str, match_head) \
   (UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[(str) + (MIN_MATCH-1)]), \
    match_head = s-&gt;head[s-&gt;ins_h], \
    s-&gt;head[s-&gt;ins_h] = (Pos)(str))
#else
#define INSERT_STRING(s, str, match_head) \
   (UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[(str) + (MIN_MATCH-1)]), \
    match_head = s-&gt;prev[(str) &amp; s-&gt;w_mask] = s-&gt;head[s-&gt;ins_h], \
    s-&gt;head[s-&gt;ins_h] = (Pos)(str))
#endif
</span><span class="sc0">
</span><span class="sc1">/* ===========================================================================
 * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
 * prev[] will be initialized on the fly.
 */</span><span class="sc0">
</span><span class="sc9">#define CLEAR_HASH(s) \
    s-&gt;head[s-&gt;hash_size-1] = NIL; \
    zmemzero((Bytef *)s-&gt;head, (unsigned)(s-&gt;hash_size-1)*sizeof(*s-&gt;head));
</span><span class="sc0">
</span><span class="sc1">/* ========================================================================= */</span><span class="sc0">
</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">deflateInit_</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">version</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">stream_size</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">z_streamp</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">version</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">stream_size</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">deflateInit2_</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">Z_DEFLATED</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">MAX_WBITS</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">DEF_MEM_LEVEL</span><span class="sc10">,</span><span class="sc0">
                         </span><span class="sc11">Z_DEFAULT_STRATEGY</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">version</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">stream_size</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc1">/* To do: ignore strm-&gt;next_in if we use it as window */</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ========================================================================= */</span><span class="sc0">
</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">deflateInit2_</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">method</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">windowBits</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">memLevel</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">strategy</span><span class="sc10">,</span><span class="sc0">
                  </span><span class="sc11">version</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">stream_size</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">z_streamp</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0">  </span><span class="sc11">level</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0">  </span><span class="sc11">method</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0">  </span><span class="sc11">windowBits</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0">  </span><span class="sc11">memLevel</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0">  </span><span class="sc11">strategy</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">version</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">stream_size</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">wrap</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">static</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc11">my_version</span><span class="sc10">[]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">ZLIB_VERSION</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">ushf</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">overlay</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc1">/* We overlay pending_buf and d_buf+l_buf. This works since the average
     * output size for (length,distance) codes is &lt;= 24 bits.
     */</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">version</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">version</span><span class="sc10">[</span><span class="sc4">0</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">my_version</span><span class="sc10">[</span><span class="sc4">0</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0">
        </span><span class="sc11">stream_size</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">z_stream</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_VERSION_ERROR</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_STREAM_ERROR</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">msg</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">zalloc</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">alloc_func</span><span class="sc10">)</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">zalloc</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">zcalloc</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">opaque</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">voidpf</span><span class="sc10">)</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">zfree</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">free_func</span><span class="sc10">)</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">zfree</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">zcfree</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc9">#ifdef FASTEST
</span><span class="sc0">    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#else
</span><span class="sc0">    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_DEFAULT_COMPRESSION</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">6</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">windowBits</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc1">/* suppress zlib wrapper */</span><span class="sc0">
        </span><span class="sc11">wrap</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">windowBits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc11">windowBits</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#ifdef GZIP
</span><span class="sc0">    </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">windowBits</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">15</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">wrap</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc1">/* write gzip wrapper instead */</span><span class="sc0">
        </span><span class="sc11">windowBits</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc4">16</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">memLevel</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">memLevel</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">MAX_MEM_LEVEL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">method</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">Z_DEFLATED</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0">
        </span><span class="sc11">windowBits</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">windowBits</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">15</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">9</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0">
        </span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">Z_FIXED</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_STREAM_ERROR</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">windowBits</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">windowBits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">9</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* until 256-byte window bug fixed */</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc0"> </span><span class="sc11">ZALLOC</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">deflate_state</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_MEM_ERROR</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">internal_state</span><span class="sc0"> </span><span class="sc11">FAR</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strm</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">wrap</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">wrap</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">w_bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">windowBits</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">w_size</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">w_bits</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">w_mask</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">w_size</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">hash_bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">memLevel</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">hash_size</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">hash_bits</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">hash_mask</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">hash_size</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">hash_shift</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0">  </span><span class="sc10">((</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">hash_bits</span><span class="sc10">+</span><span class="sc11">MIN_MATCH</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">)/</span><span class="sc11">MIN_MATCH</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Bytef</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc0"> </span><span class="sc11">ZALLOC</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">w_size</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">*</span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">prev</span><span class="sc0">   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Posf</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc0">  </span><span class="sc11">ZALLOC</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">w_size</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">Pos</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">head</span><span class="sc0">   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Posf</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc0">  </span><span class="sc11">ZALLOC</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">hash_size</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">Pos</span><span class="sc10">));</span><span class="sc0">

    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lit_bufsize</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">memLevel</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">6</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc1">/* 16K elements by default */</span><span class="sc0">

    </span><span class="sc11">overlay</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ushf</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc0"> </span><span class="sc11">ZALLOC</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lit_bufsize</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)+</span><span class="sc4">2</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uchf</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc0"> </span><span class="sc11">overlay</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf_size</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lit_bufsize</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)+</span><span class="sc4">2L</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">prev</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">head</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">FINISH_STATE</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">msg</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">*)</span><span class="sc11">ERR_MSG</span><span class="sc10">(</span><span class="sc11">Z_MEM_ERROR</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">deflateEnd</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_MEM_ERROR</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">d_buf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">overlay</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lit_bufsize</span><span class="sc10">/</span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">l_buf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc4">1</span><span class="sc10">+</span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">))*</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lit_bufsize</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">strategy</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">method</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">)</span><span class="sc11">method</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">deflateReset</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ========================================================================= */</span><span class="sc0">
</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">deflateSetDictionary</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">dictionary</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">dictLength</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">z_streamp</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">Bytef</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">dictionary</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0">  </span><span class="sc11">dictLength</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">dictLength</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">IPos</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">dictionary</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0">
        </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">wrap</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0">
        </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">wrap</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">INIT_STATE</span><span class="sc10">))</span><span class="sc0">
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_STREAM_ERROR</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">s</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">wrap</span><span class="sc10">)</span><span class="sc0">
        </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">adler32</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">dictionary</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">dictLength</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">length</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_OK</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">length</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">MAX_DIST</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">MAX_DIST</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">dictionary</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">dictLength</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* use the tail of the dictionary */</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">zmemcpy</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">dictionary</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">block_start</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">long</span><span class="sc10">)</span><span class="sc11">length</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* Insert all strings in the hash table (except for the last two bytes).
     * s-&gt;lookahead stays null, so s-&gt;ins_h will be recomputed at the next
     * call of fill_window.
     */</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">ins_h</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc4">0</span><span class="sc10">];</span><span class="sc0">
    </span><span class="sc11">UPDATE_HASH</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">ins_h</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc4">1</span><span class="sc10">]);</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">INSERT_STRING</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hash_head</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* to make compiler happy */</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ========================================================================= */</span><span class="sc0">
</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">deflateReset</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">z_streamp</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0">
        </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">zalloc</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">alloc_func</span><span class="sc10">)</span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">zfree</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">free_func</span><span class="sc10">)</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_STREAM_ERROR</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">total_in</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">total_out</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">msg</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* use zfree if we ever allocate msg dynamically */</span><span class="sc0">
    </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">data_type</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">Z_UNKNOWN</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">s</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_out</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">wrap</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">wrap</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">wrap</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* was made negative by deflate(..., Z_FINISH); */</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">wrap</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc11">INIT_STATE</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">BUSY_STATE</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0">
</span><span class="sc9">#ifdef GZIP
</span><span class="sc0">        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">wrap</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc11">crc32</span><span class="sc10">(</span><span class="sc4">0L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">        </span><span class="sc11">adler32</span><span class="sc10">(</span><span class="sc4">0L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_flush</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">Z_NO_FLUSH</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">_tr_init</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">lm_init</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ========================================================================= */</span><span class="sc0">
</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">deflateSetHeader</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">head</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">z_streamp</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">gz_headerp</span><span class="sc0"> </span><span class="sc11">head</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_STREAM_ERROR</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">wrap</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_STREAM_ERROR</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">head</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ========================================================================= */</span><span class="sc0">
</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">deflatePrime</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">value</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">z_streamp</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">value</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_STREAM_ERROR</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">bi_buf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)(</span><span class="sc11">value</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ========================================================================= */</span><span class="sc0">
</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">deflateParams</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">strategy</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">z_streamp</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">strategy</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">compress_func</span><span class="sc0"> </span><span class="sc11">func</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">err</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">Z_OK</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_STREAM_ERROR</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc9">#ifdef FASTEST
</span><span class="sc0">    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#else
</span><span class="sc0">    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_DEFAULT_COMPRESSION</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">6</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">9</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">Z_FIXED</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_STREAM_ERROR</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">func</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">configuration_table</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">level</span><span class="sc10">].</span><span class="sc11">func</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">func</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">configuration_table</span><span class="sc10">[</span><span class="sc11">level</span><span class="sc10">].</span><span class="sc11">func</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">total_in</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc1">/* Flush the last buffer: */</span><span class="sc0">
        </span><span class="sc11">err</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">deflate</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">Z_PARTIAL_FLUSH</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">max_lazy_match</span><span class="sc0">   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">configuration_table</span><span class="sc10">[</span><span class="sc11">level</span><span class="sc10">].</span><span class="sc11">max_lazy</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">good_match</span><span class="sc0">       </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">configuration_table</span><span class="sc10">[</span><span class="sc11">level</span><span class="sc10">].</span><span class="sc11">good_length</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">nice_match</span><span class="sc0">       </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">configuration_table</span><span class="sc10">[</span><span class="sc11">level</span><span class="sc10">].</span><span class="sc11">nice_length</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">max_chain_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">configuration_table</span><span class="sc10">[</span><span class="sc11">level</span><span class="sc10">].</span><span class="sc11">max_chain</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">strategy</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">err</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ========================================================================= */</span><span class="sc0">
</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">deflateTune</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">good_length</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">max_lazy</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">nice_length</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">max_chain</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">z_streamp</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">good_length</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_lazy</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">nice_length</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_chain</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_STREAM_ERROR</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">good_match</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">good_length</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">max_lazy_match</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">max_lazy</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">nice_match</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">nice_length</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">max_chain_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">max_chain</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* =========================================================================
 * For the default windowBits of 15 and memLevel of 8, this function returns
 * a close to exact, as well as small, upper bound on the compressed size.
 * They are coded as constants here for a reason--if the #define's are
 * changed, then this function needs to be changed as well.  The return
 * value for 15 and 8 only works for those exact settings.
 *
 * For any setting other than those defaults for windowBits and memLevel,
 * the value returned is a conservative worst case for the maximum expansion
 * resulting from using fixed blocks instead of stored blocks, which deflate
 * can emit on compressed data for some combinations of the parameters.
 *
 * This function could be more sophisticated to provide closer upper bounds
 * for every combination of windowBits and memLevel, as well as wrap.
 * But even the conservative upper bound of about 14% expansion does not
 * seem onerous for output buffer allocation.
 */</span><span class="sc0">
</span><span class="sc11">uLong</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">deflateBound</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">sourceLen</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">z_streamp</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">uLong</span><span class="sc0"> </span><span class="sc11">sourceLen</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">uLong</span><span class="sc0"> </span><span class="sc11">destLen</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* conservative upper bound */</span><span class="sc0">
    </span><span class="sc11">destLen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">sourceLen</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0">
              </span><span class="sc10">((</span><span class="sc11">sourceLen</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">sourceLen</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">63</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">6</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">11</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* if can't get parameters, return conservative bound */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">)</span><span class="sc0">
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">destLen</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* if not default parameters, return conservative bound */</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">w_bits</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">15</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">hash_bits</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">)</span><span class="sc0">
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">destLen</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* default settings: return tight bound for that case */</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">compressBound</span><span class="sc10">(</span><span class="sc11">sourceLen</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">putShortMSB</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">b</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">b</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">)(</span><span class="sc11">b</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">)(</span><span class="sc11">b</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm-&gt;next_out buffer and copying into it.
 * (See also read_buf()).
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">flush_pending</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">z_streamp</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">avail_out</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">avail_out</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">zmemcpy</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">next_out</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">pending_out</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">next_out</span><span class="sc0">  </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">pending_out</span><span class="sc0">  </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">total_out</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">avail_out</span><span class="sc0">  </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">pending_out</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ========================================================================= */</span><span class="sc0">
</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">deflate</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">z_streamp</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">old_flush</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* value of flush param for previous deflate call */</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0">
        </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">Z_FINISH</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_STREAM_ERROR</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">next_out</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0">
        </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">next_in</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">avail_in</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0">
        </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">FINISH_STATE</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">Z_FINISH</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">ERR_RETURN</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">Z_STREAM_ERROR</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">avail_out</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">ERR_RETURN</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">Z_BUF_ERROR</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strm</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* just in case */</span><span class="sc0">
    </span><span class="sc11">old_flush</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_flush</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_flush</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* Write the header */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">INIT_STATE</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
</span><span class="sc9">#ifdef GZIP
</span><span class="sc0">        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">wrap</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">crc32</span><span class="sc10">(</span><span class="sc4">0L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">31</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">139</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc5">NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
                </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
                </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
                </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
                </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
                </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">9</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0">
                            </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">Z_HUFFMAN_ONLY</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0">
                             </span><span class="sc4">4</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">));</span><span class="sc0">
                </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">OS_CODE</span><span class="sc10">);</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">BUSY_STATE</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">text</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0">
                            </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">hcrc</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0">
                            </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">extra</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0">
                            </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">name</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0">
                            </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">comment</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc4">16</span><span class="sc10">)</span><span class="sc0">
                        </span><span class="sc10">);</span><span class="sc0">
                </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">)(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">time</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">));</span><span class="sc0">
                </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">)((</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">time</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">));</span><span class="sc0">
                </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">)((</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">time</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">16</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">));</span><span class="sc0">
                </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">)((</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">time</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">24</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">));</span><span class="sc0">
                </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">9</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0">
                            </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">Z_HUFFMAN_ONLY</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0">
                             </span><span class="sc4">4</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">));</span><span class="sc0">
                </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">os</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">);</span><span class="sc0">
                </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">extra</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc5">NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                    </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">extra_len</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">);</span><span class="sc0">
                    </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">extra_len</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">);</span><span class="sc0">
                </span><span class="sc10">}</span><span class="sc0">
                </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">hcrc</span><span class="sc10">)</span><span class="sc0">
                    </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">crc32</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc10">,</span><span class="sc0">
                                        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc10">);</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzindex</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">EXTRA_STATE</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc5">else</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">        </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">header</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Z_DEFLATED</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">w_bits</span><span class="sc10">-</span><span class="sc4">8</span><span class="sc10">)&lt;&lt;</span><span class="sc4">4</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">level_flags</span><span class="sc10">;</span><span class="sc0">

            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">Z_HUFFMAN_ONLY</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0">
                </span><span class="sc11">level_flags</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">6</span><span class="sc10">)</span><span class="sc0">
                </span><span class="sc11">level_flags</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">6</span><span class="sc10">)</span><span class="sc0">
                </span><span class="sc11">level_flags</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc5">else</span><span class="sc0">
                </span><span class="sc11">level_flags</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">header</span><span class="sc0"> </span><span class="sc10">|=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">level_flags</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">6</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">header</span><span class="sc0"> </span><span class="sc10">|=</span><span class="sc0"> </span><span class="sc11">PRESET_DICT</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">header</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">31</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">header</span><span class="sc0"> </span><span class="sc10">%</span><span class="sc0"> </span><span class="sc4">31</span><span class="sc10">);</span><span class="sc0">

            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">BUSY_STATE</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">putShortMSB</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">header</span><span class="sc10">);</span><span class="sc0">

            </span><span class="sc1">/* Save the adler32 of the preset dictionary: */</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">putShortMSB</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uInt</span><span class="sc10">)(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">16</span><span class="sc10">));</span><span class="sc0">
                </span><span class="sc11">putShortMSB</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uInt</span><span class="sc10">)(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xffff</span><span class="sc10">));</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">adler32</span><span class="sc10">(</span><span class="sc4">0L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#ifdef GZIP
</span><span class="sc0">    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">EXTRA_STATE</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">extra</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc5">NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* start of bytes to update crc */</span><span class="sc0">

            </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzindex</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">extra_len</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xffff</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf_size</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">hcrc</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc10">)</span><span class="sc0">
                        </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">crc32</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc10">);</span><span class="sc0">
                    </span><span class="sc11">flush_pending</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">);</span><span class="sc0">
                    </span><span class="sc11">beg</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc10">;</span><span class="sc0">
                    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf_size</span><span class="sc10">)</span><span class="sc0">
                        </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
                </span><span class="sc10">}</span><span class="sc0">
                </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">extra</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzindex</span><span class="sc10">]);</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzindex</span><span class="sc10">++;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">hcrc</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc10">)</span><span class="sc0">
                </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">crc32</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc10">,</span><span class="sc0">
                                    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzindex</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">extra_len</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzindex</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">NAME_STATE</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc5">else</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">NAME_STATE</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">NAME_STATE</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">name</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc5">NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* start of bytes to update crc */</span><span class="sc0">
            </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">val</span><span class="sc10">;</span><span class="sc0">

            </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf_size</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">hcrc</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc10">)</span><span class="sc0">
                        </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">crc32</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc10">);</span><span class="sc0">
                    </span><span class="sc11">flush_pending</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">);</span><span class="sc0">
                    </span><span class="sc11">beg</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc10">;</span><span class="sc0">
                    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf_size</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                        </span><span class="sc11">val</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
                        </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
                    </span><span class="sc10">}</span><span class="sc0">
                </span><span class="sc10">}</span><span class="sc0">
                </span><span class="sc11">val</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">name</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzindex</span><span class="sc10">++];</span><span class="sc0">
                </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">val</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">val</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">hcrc</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc10">)</span><span class="sc0">
                </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">crc32</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc10">,</span><span class="sc0">
                                    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">val</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzindex</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">COMMENT_STATE</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc5">else</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">COMMENT_STATE</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">COMMENT_STATE</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">comment</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc5">NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* start of bytes to update crc */</span><span class="sc0">
            </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">val</span><span class="sc10">;</span><span class="sc0">

            </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf_size</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">hcrc</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc10">)</span><span class="sc0">
                        </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">crc32</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc10">);</span><span class="sc0">
                    </span><span class="sc11">flush_pending</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">);</span><span class="sc0">
                    </span><span class="sc11">beg</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc10">;</span><span class="sc0">
                    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf_size</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                        </span><span class="sc11">val</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
                        </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
                    </span><span class="sc10">}</span><span class="sc0">
                </span><span class="sc10">}</span><span class="sc0">
                </span><span class="sc11">val</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">comment</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzindex</span><span class="sc10">++];</span><span class="sc0">
                </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">val</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">val</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">hcrc</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc10">)</span><span class="sc0">
                </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">crc32</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc10">,</span><span class="sc0">
                                    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">beg</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">val</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">HCRC_STATE</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc5">else</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">HCRC_STATE</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">HCRC_STATE</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">gzhead</span><span class="sc10">-&gt;</span><span class="sc11">hcrc</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf_size</span><span class="sc10">)</span><span class="sc0">
                </span><span class="sc11">flush_pending</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf_size</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">)(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">));</span><span class="sc0">
                </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">)((</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">));</span><span class="sc0">
                </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">crc32</span><span class="sc10">(</span><span class="sc4">0L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">BUSY_STATE</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc5">else</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">BUSY_STATE</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
    </span><span class="sc1">/* Flush as much pending output as possible */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">flush_pending</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">avail_out</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc1">/* Since avail_out is 0, deflate will be called again with
             * more output space, but possibly with both pending and
             * avail_in equal to zero. There won't be anything to do,
             * but this is not an error situation so make sure we
             * return OK instead of BUF_ERROR at next call of deflate:
             */</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_flush</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_OK</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc1">/* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">avail_in</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">old_flush</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
               </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">Z_FINISH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">ERR_RETURN</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">Z_BUF_ERROR</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc1">/* User must not provide more input after the first FINISH: */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">FINISH_STATE</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">avail_in</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">ERR_RETURN</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">Z_BUF_ERROR</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc1">/* Start a new block or continue the current one.
     */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">avail_in</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0">
        </span><span class="sc10">(</span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">Z_NO_FLUSH</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">FINISH_STATE</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">block_state</span><span class="sc0"> </span><span class="sc11">bstate</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc11">bstate</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(*(</span><span class="sc11">configuration_table</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">level</span><span class="sc10">].</span><span class="sc11">func</span><span class="sc10">))(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bstate</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">finish_started</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">bstate</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">finish_done</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">FINISH_STATE</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bstate</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">need_more</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">bstate</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">finish_started</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">avail_out</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_flush</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* avoid BUF_ERROR next call, see above */</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_OK</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc1">/* If flush != Z_NO_FLUSH &amp;&amp; avail_out == 0, the next call
             * of deflate should use the same flush parameter to make sure
             * that the flush is complete. So we don't have to output an
             * empty block here, this will be done at next call. This also
             * ensures that for a very small output buffer, we emit at most
             * one empty block.
             */</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bstate</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">block_done</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_PARTIAL_FLUSH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">_tr_align</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc1">/* FULL_FLUSH or SYNC_FLUSH */</span><span class="sc0">
                </span><span class="sc11">_tr_stored_block</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">*)</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
                </span><span class="sc1">/* For a full flush, this empty block will be recognized
                 * as a special marker by inflate_sync().
                 */</span><span class="sc0">
                </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_FULL_FLUSH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                    </span><span class="sc11">CLEAR_HASH</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">);</span><span class="sc0">             </span><span class="sc1">/* forget history */</span><span class="sc0">
                </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc11">flush_pending</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">avail_out</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
              </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_flush</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* avoid BUF_ERROR at next call, see above */</span><span class="sc0">
              </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_OK</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">avail_out</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"bug2"</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">Z_FINISH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_OK</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">wrap</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_STREAM_END</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* Write the trailer */</span><span class="sc0">
</span><span class="sc9">#ifdef GZIP
</span><span class="sc0">    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">wrap</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">)(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">));</span><span class="sc0">
        </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">)((</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">));</span><span class="sc0">
        </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">)((</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">16</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">));</span><span class="sc0">
        </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">)((</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">24</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">));</span><span class="sc0">
        </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">)(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">total_in</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">));</span><span class="sc0">
        </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">)((</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">total_in</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">));</span><span class="sc0">
        </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">)((</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">total_in</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">16</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">));</span><span class="sc0">
        </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">)((</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">total_in</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">24</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">else</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">    </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">putShortMSB</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uInt</span><span class="sc10">)(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">16</span><span class="sc10">));</span><span class="sc0">
        </span><span class="sc11">putShortMSB</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uInt</span><span class="sc10">)(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xffff</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">flush_pending</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc1">/* If avail_out is zero, the application will call deflate again
     * to flush the rest.
     */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">wrap</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">wrap</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">wrap</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* write the trailer only once! */</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc11">Z_OK</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">Z_STREAM_END</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ========================================================================= */</span><span class="sc0">
</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">deflateEnd</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">z_streamp</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">status</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_STREAM_ERROR</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">status</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">INIT_STATE</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
        </span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">EXTRA_STATE</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
        </span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">NAME_STATE</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
        </span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">COMMENT_STATE</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
        </span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">HCRC_STATE</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
        </span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">BUSY_STATE</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
        </span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">FINISH_STATE</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
      </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_STREAM_ERROR</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc1">/* Deallocate in reverse order of allocations: */</span><span class="sc0">
    </span><span class="sc11">TRY_FREE</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">TRY_FREE</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">head</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">TRY_FREE</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">prev</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">TRY_FREE</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">ZFREE</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">status</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">BUSY_STATE</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc11">Z_DATA_ERROR</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">Z_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* =========================================================================
 * Copy the source state to the destination state.
 * To simplify the source, this is not supported for 16-bit MSDOS (which
 * doesn't have enough memory anyway to duplicate compression states).
 */</span><span class="sc0">
</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">deflateCopy</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">dest</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">source</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">z_streamp</span><span class="sc0"> </span><span class="sc11">dest</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">z_streamp</span><span class="sc0"> </span><span class="sc11">source</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
</span><span class="sc9">#ifdef MAXSEG_64K
</span><span class="sc0">    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_STREAM_ERROR</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#else
</span><span class="sc0">    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">ds</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">ss</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">ushf</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">overlay</span><span class="sc10">;</span><span class="sc0">


    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">source</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">dest</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">source</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_STREAM_ERROR</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc11">ss</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">source</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">zmemcpy</span><span class="sc10">(</span><span class="sc11">dest</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">source</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">z_stream</span><span class="sc10">));</span><span class="sc0">

    </span><span class="sc11">ds</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc0"> </span><span class="sc11">ZALLOC</span><span class="sc10">(</span><span class="sc11">dest</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">deflate_state</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ds</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_MEM_ERROR</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">dest</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">internal_state</span><span class="sc0"> </span><span class="sc11">FAR</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc0"> </span><span class="sc11">ds</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">zmemcpy</span><span class="sc10">(</span><span class="sc11">ds</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ss</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">deflate_state</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">strm</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">dest</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Bytef</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc0"> </span><span class="sc11">ZALLOC</span><span class="sc10">(</span><span class="sc11">dest</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">w_size</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">*</span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">prev</span><span class="sc0">   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Posf</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc0">  </span><span class="sc11">ZALLOC</span><span class="sc10">(</span><span class="sc11">dest</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">w_size</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">Pos</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">head</span><span class="sc0">   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Posf</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc0">  </span><span class="sc11">ZALLOC</span><span class="sc10">(</span><span class="sc11">dest</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">hash_size</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">Pos</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc11">overlay</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ushf</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc0"> </span><span class="sc11">ZALLOC</span><span class="sc10">(</span><span class="sc11">dest</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">lit_bufsize</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)+</span><span class="sc4">2</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uchf</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc0"> </span><span class="sc11">overlay</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">prev</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">head</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0">
        </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">deflateEnd</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">dest</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_MEM_ERROR</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc1">/* following zmemcpy do not work for 16-bit MSDOS */</span><span class="sc0">
    </span><span class="sc11">zmemcpy</span><span class="sc10">(</span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ss</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">w_size</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc0"> </span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc11">zmemcpy</span><span class="sc10">(</span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">prev</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ss</span><span class="sc10">-&gt;</span><span class="sc11">prev</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">w_size</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc0"> </span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">Pos</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc11">zmemcpy</span><span class="sc10">(</span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">head</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ss</span><span class="sc10">-&gt;</span><span class="sc11">head</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">hash_size</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc0"> </span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">Pos</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc11">zmemcpy</span><span class="sc10">(</span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ss</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uInt</span><span class="sc10">)</span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf_size</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">pending_out</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ss</span><span class="sc10">-&gt;</span><span class="sc11">pending_out</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">ss</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">d_buf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">overlay</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">lit_bufsize</span><span class="sc10">/</span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">l_buf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc4">1</span><span class="sc10">+</span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">))*</span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">lit_bufsize</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">l_desc</span><span class="sc10">.</span><span class="sc11">dyn_tree</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">dyn_ltree</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">d_desc</span><span class="sc10">.</span><span class="sc11">dyn_tree</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">dyn_dtree</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">bl_desc</span><span class="sc10">.</span><span class="sc11">dyn_tree</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">ds</span><span class="sc10">-&gt;</span><span class="sc11">bl_tree</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">Z_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif </span><span class="sc1">/* MAXSEG_64K */</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm-&gt;next_in buffer and copying from it.
 * (See also flush_pending()).
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">read_buf</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">z_streamp</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">Bytef</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">avail_in</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">avail_in</span><span class="sc0">  </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">wrap</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">adler32</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">next_in</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#ifdef GZIP
</span><span class="sc0">    </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">state</span><span class="sc10">-&gt;</span><span class="sc11">wrap</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">crc32</span><span class="sc10">(</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">adler</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">next_in</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">    </span><span class="sc11">zmemcpy</span><span class="sc10">(</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">next_in</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">next_in</span><span class="sc0">  </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">total_in</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">int</span><span class="sc10">)</span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">lm_init</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window_size</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc4">2L</span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">w_size</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">CLEAR_HASH</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc1">/* Set the default configuration parameters:
     */</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">max_lazy_match</span><span class="sc0">   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">configuration_table</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">level</span><span class="sc10">].</span><span class="sc11">max_lazy</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">good_match</span><span class="sc0">       </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">configuration_table</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">level</span><span class="sc10">].</span><span class="sc11">good_length</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">nice_match</span><span class="sc0">       </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">configuration_table</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">level</span><span class="sc10">].</span><span class="sc11">nice_length</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">max_chain_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">configuration_table</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">level</span><span class="sc10">].</span><span class="sc11">max_chain</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">block_start</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0L</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">prev_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_available</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">ins_h</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#ifndef FASTEST
#ifdef ASMV
</span><span class="sc0">    </span><span class="sc11">match_init</span><span class="sc10">();</span><span class="sc0"> </span><span class="sc1">/* initialize the asm code */</span><span class="sc0">
</span><span class="sc9">#endif
#endif
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc9">#ifndef FASTEST
</span><span class="sc1">/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is &lt;= MAX_DIST, and prev_length &gt;= 1
 * OUT assertion: the match length is not greater than s-&gt;lookahead.
 */</span><span class="sc0">
</span><span class="sc9">#ifndef ASMV
</span><span class="sc1">/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
 * match.S. The code will be functionally equivalent.
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">longest_match</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">cur_match</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">IPos</span><span class="sc0"> </span><span class="sc11">cur_match</span><span class="sc10">;</span><span class="sc0">                             </span><span class="sc1">/* current match */</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">chain_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">max_chain_length</span><span class="sc10">;</span><span class="sc1">/* max hash chain length */</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc11">Bytef</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* current string */</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc11">Bytef</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">match</span><span class="sc10">;</span><span class="sc0">                       </span><span class="sc1">/* matched string */</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">                           </span><span class="sc1">/* length of current match */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">best_len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">prev_length</span><span class="sc10">;</span><span class="sc0">              </span><span class="sc1">/* best match length so far */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">nice_match</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">nice_match</span><span class="sc10">;</span><span class="sc0">             </span><span class="sc1">/* stop if match long enough */</span><span class="sc0">
    </span><span class="sc11">IPos</span><span class="sc0"> </span><span class="sc11">limit</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">IPos</span><span class="sc10">)</span><span class="sc11">MAX_DIST</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">IPos</span><span class="sc10">)</span><span class="sc11">MAX_DIST</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">NIL</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc1">/* Stop when cur_match becomes &lt;= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */</span><span class="sc0">
    </span><span class="sc11">Posf</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">prev</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">prev</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">wmask</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">w_mask</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc9">#ifdef UNALIGNED_OK
</span><span class="sc0">    </span><span class="sc1">/* Compare two bytes at a time. Note: this is not always beneficial.
     * Try with and without -DUNALIGNED_OK to check.
     */</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc11">Bytef</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">strend</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">MAX_MATCH</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">scan_start</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">*(</span><span class="sc11">ushf</span><span class="sc10">*)</span><span class="sc11">scan</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">scan_end</span><span class="sc0">   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">*(</span><span class="sc11">ushf</span><span class="sc10">*)(</span><span class="sc11">scan</span><span class="sc10">+</span><span class="sc11">best_len</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc9">#else
</span><span class="sc0">    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc11">Bytef</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">strend</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">MAX_MATCH</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc11">Byte</span><span class="sc0"> </span><span class="sc11">scan_end1</span><span class="sc0">  </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">scan</span><span class="sc10">[</span><span class="sc11">best_len</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">];</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc11">Byte</span><span class="sc0"> </span><span class="sc11">scan_end</span><span class="sc0">   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">scan</span><span class="sc10">[</span><span class="sc11">best_len</span><span class="sc10">];</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
    </span><span class="sc1">/* The code is optimized for HASH_BITS &gt;= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">hash_bits</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">MAX_MATCH</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">258</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"Code too clever"</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc1">/* Do not waste too much time if we already have a good match: */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">prev_length</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">good_match</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">chain_length</span><span class="sc0"> </span><span class="sc10">&gt;&gt;=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc1">/* Do not look for matches beyond the end of the input. This is necessary
     * to make deflate deterministic.
     */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">uInt</span><span class="sc10">)</span><span class="sc11">nice_match</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">nice_match</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">Assert</span><span class="sc10">((</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window_size</span><span class="sc10">-</span><span class="sc11">MIN_LOOKAHEAD</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"need lookahead"</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">cur_match</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"no future"</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">cur_match</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc1">/* Skip to next match if the match length cannot increase
         * or if the match length is less than 2.  Note that the checks below
         * for insufficient lookahead only occur occasionally for performance
         * reasons.  Therefore uninitialized memory will be accessed, and
         * conditional jumps will be made that depend on those values.
         * However the length of the match is limited to the lookahead, so
         * the output of deflate is not affected by the uninitialized values.
         */</span><span class="sc0">
</span><span class="sc9">#if (defined(UNALIGNED_OK) &amp;&amp; MAX_MATCH == 258)
</span><span class="sc0">        </span><span class="sc1">/* This code assumes sizeof(unsigned short) == 2. Do not use
         * UNALIGNED_OK if your compiler uses a different size.
         */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(*(</span><span class="sc11">ushf</span><span class="sc10">*)(</span><span class="sc11">match</span><span class="sc10">+</span><span class="sc11">best_len</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">scan_end</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0">
            </span><span class="sc10">*(</span><span class="sc11">ushf</span><span class="sc10">*)</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">scan_start</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">continue</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc1">/* It is not necessary to compare scan[2] and match[2] since they are
         * always equal when the other bytes match, given that the hash keys
         * are equal and that HASH_BITS &gt;= 8. Compare 2 bytes at a time at
         * strstart+3, +5, ... up to strstart+257. We check for insufficient
         * lookahead only every 4th comparison; the 128th check will be made
         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
         * necessary to put more guard bytes at the end of the window, or
         * to check more often for insufficient lookahead.
         */</span><span class="sc0">
        </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">scan</span><span class="sc10">[</span><span class="sc4">2</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">match</span><span class="sc10">[</span><span class="sc4">2</span><span class="sc10">],</span><span class="sc0"> </span><span class="sc6">"scan[2]?"</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">scan</span><span class="sc10">++,</span><span class="sc0"> </span><span class="sc11">match</span><span class="sc10">++;</span><span class="sc0">
        </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(*(</span><span class="sc11">ushf</span><span class="sc10">*)(</span><span class="sc11">scan</span><span class="sc10">+=</span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*(</span><span class="sc11">ushf</span><span class="sc10">*)(</span><span class="sc11">match</span><span class="sc10">+=</span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
                 </span><span class="sc10">*(</span><span class="sc11">ushf</span><span class="sc10">*)(</span><span class="sc11">scan</span><span class="sc10">+=</span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*(</span><span class="sc11">ushf</span><span class="sc10">*)(</span><span class="sc11">match</span><span class="sc10">+=</span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
                 </span><span class="sc10">*(</span><span class="sc11">ushf</span><span class="sc10">*)(</span><span class="sc11">scan</span><span class="sc10">+=</span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*(</span><span class="sc11">ushf</span><span class="sc10">*)(</span><span class="sc11">match</span><span class="sc10">+=</span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
                 </span><span class="sc10">*(</span><span class="sc11">ushf</span><span class="sc10">*)(</span><span class="sc11">scan</span><span class="sc10">+=</span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*(</span><span class="sc11">ushf</span><span class="sc10">*)(</span><span class="sc11">match</span><span class="sc10">+=</span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
                 </span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">strend</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc1">/* The funny "do {}" generates better code on most compilers */</span><span class="sc0">

        </span><span class="sc1">/* Here, scan &lt;= window+strstart+257 */</span><span class="sc0">
        </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">+(</span><span class="sc16">unsigned</span><span class="sc10">)(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window_size</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">),</span><span class="sc0"> </span><span class="sc6">"wild scan"</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(*</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">match</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">scan</span><span class="sc10">++;</span><span class="sc0">

        </span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">MAX_MATCH</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">int</span><span class="sc10">)(</span><span class="sc11">strend</span><span class="sc10">-</span><span class="sc11">scan</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">strend</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">MAX_MATCH</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0">

</span><span class="sc9">#else </span><span class="sc1">/* UNALIGNED_OK */</span><span class="sc0">

        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">match</span><span class="sc10">[</span><span class="sc11">best_len</span><span class="sc10">]</span><span class="sc0">   </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">scan_end</span><span class="sc0">  </span><span class="sc10">||</span><span class="sc0">
            </span><span class="sc11">match</span><span class="sc10">[</span><span class="sc11">best_len</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">scan_end1</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0">
            </span><span class="sc10">*</span><span class="sc11">match</span><span class="sc0">            </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">scan</span><span class="sc0">     </span><span class="sc10">||</span><span class="sc0">
            </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0">          </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">scan</span><span class="sc10">[</span><span class="sc4">1</span><span class="sc10">])</span><span class="sc0">      </span><span class="sc5">continue</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc1">/* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS &gt;= 8.
         */</span><span class="sc0">
        </span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">match</span><span class="sc10">++;</span><span class="sc0">
        </span><span class="sc11">Assert</span><span class="sc10">(*</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">match</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"match[2]?"</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc1">/* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */</span><span class="sc0">
        </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
                 </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
                 </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
                 </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
                 </span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">strend</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">+(</span><span class="sc16">unsigned</span><span class="sc10">)(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window_size</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">),</span><span class="sc0"> </span><span class="sc6">"wild scan"</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">MAX_MATCH</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">int</span><span class="sc10">)(</span><span class="sc11">strend</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">scan</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">strend</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">MAX_MATCH</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc9">#endif </span><span class="sc1">/* UNALIGNED_OK */</span><span class="sc0">

        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">best_len</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_start</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">cur_match</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">best_len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">nice_match</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#ifdef UNALIGNED_OK
</span><span class="sc0">            </span><span class="sc11">scan_end</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">*(</span><span class="sc11">ushf</span><span class="sc10">*)(</span><span class="sc11">scan</span><span class="sc10">+</span><span class="sc11">best_len</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc9">#else
</span><span class="sc0">            </span><span class="sc11">scan_end1</span><span class="sc0">  </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">scan</span><span class="sc10">[</span><span class="sc11">best_len</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">];</span><span class="sc0">
            </span><span class="sc11">scan_end</span><span class="sc0">   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">scan</span><span class="sc10">[</span><span class="sc11">best_len</span><span class="sc10">];</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">cur_match</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">prev</span><span class="sc10">[</span><span class="sc11">cur_match</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc11">wmask</span><span class="sc10">])</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">limit</span><span class="sc0">
             </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">--</span><span class="sc11">chain_length</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">uInt</span><span class="sc10">)</span><span class="sc11">best_len</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uInt</span><span class="sc10">)</span><span class="sc11">best_len</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#endif </span><span class="sc1">/* ASMV */</span><span class="sc0">
</span><span class="sc9">#endif </span><span class="sc1">/* FASTEST */</span><span class="sc0">

</span><span class="sc1">/* ---------------------------------------------------------------------------
 * Optimized version for level == 1 or strategy == Z_RLE only
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">longest_match_fast</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">cur_match</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">IPos</span><span class="sc0"> </span><span class="sc11">cur_match</span><span class="sc10">;</span><span class="sc0">                             </span><span class="sc1">/* current match */</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc11">Bytef</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* current string */</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc11">Bytef</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">match</span><span class="sc10">;</span><span class="sc0">                       </span><span class="sc1">/* matched string */</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">                           </span><span class="sc1">/* length of current match */</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc11">Bytef</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">strend</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">MAX_MATCH</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* The code is optimized for HASH_BITS &gt;= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">hash_bits</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">MAX_MATCH</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">258</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"Code too clever"</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">Assert</span><span class="sc10">((</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window_size</span><span class="sc10">-</span><span class="sc11">MIN_LOOKAHEAD</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"need lookahead"</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">cur_match</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"no future"</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">cur_match</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* Return failure if the match length is less than 2:
     */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">match</span><span class="sc10">[</span><span class="sc4">0</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">scan</span><span class="sc10">[</span><span class="sc4">0</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">match</span><span class="sc10">[</span><span class="sc4">1</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">scan</span><span class="sc10">[</span><span class="sc4">1</span><span class="sc10">])</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS &gt;= 8.
     */</span><span class="sc0">
    </span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc10">(*</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">match</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"match[2]?"</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc1">/* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */</span><span class="sc0">
    </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
             </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
             </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
             </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
             </span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">strend</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">+(</span><span class="sc16">unsigned</span><span class="sc10">)(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window_size</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">),</span><span class="sc0"> </span><span class="sc6">"wild scan"</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">MAX_MATCH</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">int</span><span class="sc10">)(</span><span class="sc11">strend</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">scan</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_start</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">cur_match</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uInt</span><span class="sc10">)</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uInt</span><span class="sc10">)</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc9">#ifdef DEBUG
</span><span class="sc1">/* ===========================================================================
 * Check that the match at match_start is indeed a match.
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">check_match</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">start</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">match</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">IPos</span><span class="sc0"> </span><span class="sc11">start</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">match</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc1">/* check that the match is indeed a match */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">zmemcmp</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">match</span><span class="sc10">,</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">start</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">EQUAL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">fprintf</span><span class="sc10">(</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">" start %u, match %u, length %d\n"</span><span class="sc10">,</span><span class="sc0">
                </span><span class="sc11">start</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">match</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">fprintf</span><span class="sc10">(</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"%c%c"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">match</span><span class="sc10">++],</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">start</span><span class="sc10">++]);</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(--</span><span class="sc11">length</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">z_error</span><span class="sc10">(</span><span class="sc6">"invalid match"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">z_verbose</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">fprintf</span><span class="sc10">(</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc6">"\\[%d,%d]"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">start</span><span class="sc10">-</span><span class="sc11">match</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">putc</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">start</span><span class="sc10">++],</span><span class="sc0"> </span><span class="sc11">stderr</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(--</span><span class="sc11">length</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#else
#  define check_match(s, start, match, length)
#endif </span><span class="sc1">/* DEBUG */</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead &lt; MIN_LOOKAHEAD
 * OUT assertions: strstart &lt;= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">fill_window</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">m</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc11">Posf</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">p</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">more</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc1">/* Amount of free space at the end of the window. */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">wsize</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">w_size</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">more</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc10">)(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window_size</span><span class="sc0"> </span><span class="sc10">-(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">-(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc1">/* Deal with !@#$% 64K limit: */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc16">int</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">more</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">more</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">wsize</span><span class="sc10">;</span><span class="sc0">

            </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">more</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc10">)(-</span><span class="sc4">1</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc1">/* Very unlikely, but possible on 16 bit machine if
                 * strstart == 0 &amp;&amp; lookahead == 1 (input done a byte at time)
                 */</span><span class="sc0">
                </span><span class="sc11">more</span><span class="sc10">--;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">

        </span><span class="sc1">/* If the window is almost full and there is insufficient lookahead,
         * move the upper half to the lower one to make room in the upper half.
         */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">wsize</span><span class="sc10">+</span><span class="sc11">MAX_DIST</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">

            </span><span class="sc11">zmemcpy</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">+</span><span class="sc11">wsize</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc10">)</span><span class="sc11">wsize</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_start</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc11">wsize</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0">    </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc11">wsize</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* we now have strstart &gt;= MAX_DIST */</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">block_start</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">long</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">wsize</span><span class="sc10">;</span><span class="sc0">

            </span><span class="sc1">/* Slide the hash table (could be avoided with 32 bit values
               at the expense of memory usage). We slide even when level == 0
               to keep the hash table consistent if we switch back to level &gt; 0
               later. (Using level 0 permanently is not an optimal usage of
               zlib, so we don't care about this pathological case.)
             */</span><span class="sc0">
            </span><span class="sc1">/* %%% avoid this when Z_RLE */</span><span class="sc0">
            </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">hash_size</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">p</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">head</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">];</span><span class="sc0">
            </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">m</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">*--</span><span class="sc11">p</span><span class="sc10">;</span><span class="sc0">
                </span><span class="sc10">*</span><span class="sc11">p</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Pos</span><span class="sc10">)(</span><span class="sc11">m</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">wsize</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc11">m</span><span class="sc10">-</span><span class="sc11">wsize</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">NIL</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(--</span><span class="sc11">n</span><span class="sc10">);</span><span class="sc0">

            </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">wsize</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#ifndef FASTEST
</span><span class="sc0">            </span><span class="sc11">p</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">prev</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">];</span><span class="sc0">
            </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">m</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">*--</span><span class="sc11">p</span><span class="sc10">;</span><span class="sc0">
                </span><span class="sc10">*</span><span class="sc11">p</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Pos</span><span class="sc10">)(</span><span class="sc11">m</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">wsize</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc11">m</span><span class="sc10">-</span><span class="sc11">wsize</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">NIL</span><span class="sc10">);</span><span class="sc0">
                </span><span class="sc1">/* If n is not on any hash chain, prev[n] is garbage but
                 * its value will never be used.
                 */</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(--</span><span class="sc11">n</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">            </span><span class="sc11">more</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">wsize</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">avail_in</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc1">/* If there was no sliding:
         *    strstart &lt;= WSIZE+MAX_DIST-1 &amp;&amp; lookahead &lt;= MIN_LOOKAHEAD - 1 &amp;&amp;
         *    more == window_size - lookahead - strstart
         * =&gt; more &gt;= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
         * =&gt; more &gt;= window_size - 2*WSIZE + 2
         * In the BIG_MEM or MMAP case (not yet supported),
         *   window_size == input_size + MIN_LOOKAHEAD  &amp;&amp;
         *   strstart + s-&gt;lookahead &lt;= input_size =&gt; more &gt;= MIN_LOOKAHEAD.
         * Otherwise, window_size == 2*WSIZE so more &gt;= 2.
         * If there was sliding, more &gt;= WSIZE. So in all cases, more &gt;= 2.
         */</span><span class="sc0">
        </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">more</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"more &lt; 2"</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">read_buf</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strm</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">more</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc1">/* Initialize the hash value now that we have some input: */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">ins_h</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">];</span><span class="sc0">
            </span><span class="sc11">UPDATE_HASH</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">ins_h</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">]);</span><span class="sc0">
</span><span class="sc9">#if MIN_MATCH != 3
</span><span class="sc0">            </span><span class="sc11">Call</span><span class="sc0"> </span><span class="sc11">UPDATE_HASH</span><span class="sc10">()</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">-</span><span class="sc4">3</span><span class="sc0"> </span><span class="sc11">more</span><span class="sc0"> </span><span class="sc11">times</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc1">/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
         * but this is not important since only literal bytes will be emitted.
         */</span><span class="sc0">

    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">MIN_LOOKAHEAD</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">avail_in</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Flush the current block, with given end-of-file flag.
 * IN assertion: strstart is set to the end of the current match.
 */</span><span class="sc0">
</span><span class="sc9">#define FLUSH_BLOCK_ONLY(s, eof) { \
   _tr_flush_block(s, (s-&gt;block_start &gt;= 0L ? \
                   (charf *)&amp;s-&gt;window[(unsigned)s-&gt;block_start] : \
                   (charf *)Z_NULL), \
                (ulg)((long)s-&gt;strstart - s-&gt;block_start), \
                (eof)); \
   s-&gt;block_start = s-&gt;strstart; \
   flush_pending(s-&gt;strm); \
   Tracev((stderr,"[FLUSH]")); \
}
</span><span class="sc0">
</span><span class="sc1">/* Same but force premature exit if necessary. */</span><span class="sc0">
</span><span class="sc9">#define FLUSH_BLOCK(s, eof) { \
   FLUSH_BLOCK_ONLY(s, eof); \
   if (s-&gt;strm-&gt;avail_out == 0) return (eof) ? finish_started : need_more; \
}
</span><span class="sc0">
</span><span class="sc1">/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc11">block_state</span><span class="sc0"> </span><span class="sc11">deflate_stored</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc1">/* Stored blocks are limited to 0xffff bytes, pending_buf is limited
     * to pending_buf_size, and each stored block has a 5 byte header:
     */</span><span class="sc0">
    </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">max_block_size</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0xffff</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">max_start</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">max_block_size</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf_size</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc4">5</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">max_block_size</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending_buf_size</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc4">5</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc1">/* Copy as much as possible from input to output: */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(;;)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc1">/* Fill the window as much as possible: */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">

            </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">w_size</span><span class="sc10">+</span><span class="sc11">MAX_DIST</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0">
                   </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">block_start</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">long</span><span class="sc10">)</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">w_size</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"slide too late"</span><span class="sc10">);</span><span class="sc0">

            </span><span class="sc11">fill_window</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NO_FLUSH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">need_more</span><span class="sc10">;</span><span class="sc0">

            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* flush the current block */</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">block_start</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">0L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"block gone"</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc1">/* Emit a stored block if pending_buf will be full: */</span><span class="sc0">
        </span><span class="sc11">max_start</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">block_start</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">max_block_size</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">max_start</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc1">/* strstart == 0 is possible when wraparound on 16-bit machine */</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uInt</span><span class="sc10">)(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">max_start</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uInt</span><span class="sc10">)</span><span class="sc11">max_start</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">FLUSH_BLOCK</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc1">/* Flush if we may have to slide, otherwise block_start may become
         * negative and the data will be gone:
         */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uInt</span><span class="sc10">)</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">block_start</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">MAX_DIST</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">FLUSH_BLOCK</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">FLUSH_BLOCK</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_FINISH</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_FINISH</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc11">finish_done</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">block_done</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc11">block_state</span><span class="sc0"> </span><span class="sc11">deflate_fast</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">IPos</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">NIL</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* head of the hash chain */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">bflush</span><span class="sc10">;</span><span class="sc0">           </span><span class="sc1">/* set if current block must be flushed */</span><span class="sc0">

    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(;;)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc1">/* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">MIN_LOOKAHEAD</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">fill_window</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">MIN_LOOKAHEAD</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NO_FLUSH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">need_more</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* flush the current block */</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">

        </span><span class="sc1">/* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">INSERT_STRING</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">

        </span><span class="sc1">/* Find the longest match, discarding those &lt;= prev_length.
         * At this point we have always match_length &lt; MIN_MATCH
         */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hash_head</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">NIL</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">MAX_DIST</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc1">/* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */</span><span class="sc0">
</span><span class="sc9">#ifdef FASTEST
</span><span class="sc0">            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">Z_HUFFMAN_ONLY</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">Z_RLE</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0">
                </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_RLE</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">longest_match_fast</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#else
</span><span class="sc0">            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">Z_HUFFMAN_ONLY</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">Z_RLE</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">longest_match</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_RLE</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">longest_match_fast</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">            </span><span class="sc1">/* longest_match() or longest_match_fast() sets match_start */</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">check_match</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_start</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc10">);</span><span class="sc0">

            </span><span class="sc11">_tr_tally_dist</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_start</span><span class="sc10">,</span><span class="sc0">
                           </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">bflush</span><span class="sc10">);</span><span class="sc0">

            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc10">;</span><span class="sc0">

            </span><span class="sc1">/* Insert new strings in the hash table only if the match length
             * is not too large. This saves time but degrades compression.
             */</span><span class="sc0">
</span><span class="sc9">#ifndef FASTEST
</span><span class="sc0">            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">max_insert_length</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc10">--;</span><span class="sc0"> </span><span class="sc1">/* string at strstart already in table */</span><span class="sc0">
                </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">++;</span><span class="sc0">
                    </span><span class="sc11">INSERT_STRING</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc10">);</span><span class="sc0">
                    </span><span class="sc1">/* strstart never exceeds WSIZE-MAX_MATCH, so there are
                     * always MIN_MATCH bytes ahead.
                     */</span><span class="sc0">
                </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(--</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">++;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">            </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc10">;</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">ins_h</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">];</span><span class="sc0">
                </span><span class="sc11">UPDATE_HASH</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">ins_h</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">]);</span><span class="sc0">
</span><span class="sc9">#if MIN_MATCH != 3
</span><span class="sc0">                </span><span class="sc11">Call</span><span class="sc0"> </span><span class="sc11">UPDATE_HASH</span><span class="sc10">()</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">-</span><span class="sc4">3</span><span class="sc0"> </span><span class="sc11">more</span><span class="sc0"> </span><span class="sc11">times</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">                </span><span class="sc1">/* If lookahead &lt; MIN_MATCH, ins_h is garbage, but it does not
                 * matter since it will be recomputed at next deflate call.
                 */</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc1">/* No match, output a literal byte */</span><span class="sc0">
            </span><span class="sc11">Tracevv</span><span class="sc10">((</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc6">"%c"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">]));</span><span class="sc0">
            </span><span class="sc11">_tr_tally_lit</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">],</span><span class="sc0"> </span><span class="sc11">bflush</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc10">--;</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">++;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bflush</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">FLUSH_BLOCK</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">FLUSH_BLOCK</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_FINISH</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_FINISH</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc11">finish_done</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">block_done</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc9">#ifndef FASTEST
</span><span class="sc1">/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc11">block_state</span><span class="sc0"> </span><span class="sc11">deflate_slow</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">IPos</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">NIL</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc1">/* head of hash chain */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">bflush</span><span class="sc10">;</span><span class="sc0">              </span><span class="sc1">/* set if current block must be flushed */</span><span class="sc0">

    </span><span class="sc1">/* Process the input block. */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(;;)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc1">/* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">MIN_LOOKAHEAD</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">fill_window</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">MIN_LOOKAHEAD</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NO_FLUSH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">need_more</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* flush the current block */</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">

        </span><span class="sc1">/* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">INSERT_STRING</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">

        </span><span class="sc1">/* Find the longest match, discarding those &lt;= prev_length.
         */</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">prev_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">prev_match</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_start</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hash_head</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">NIL</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">prev_length</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">max_lazy_match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">MAX_DIST</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc1">/* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">Z_HUFFMAN_ONLY</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">Z_RLE</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">longest_match</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_RLE</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">longest_match_fast</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc1">/* longest_match() or longest_match_fast() sets match_start */</span><span class="sc0">

            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">5</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_FILTERED</span><span class="sc0">
</span><span class="sc9">#if TOO_FAR &lt;= 32767
</span><span class="sc0">                </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
                    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_start</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">TOO_FAR</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">                </span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">

                </span><span class="sc1">/* If prev_match is also MIN_MATCH, match_start is garbage
                 * but we will ignore the current match anyway.
                 */</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc1">/* If there was a match at the previous step and the current
         * match is not better, output the previous match:
         */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">prev_length</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">prev_length</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">max_insert</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc1">/* Do not insert strings in hash table beyond this. */</span><span class="sc0">

            </span><span class="sc11">check_match</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">prev_match</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">prev_length</span><span class="sc10">);</span><span class="sc0">

            </span><span class="sc11">_tr_tally_dist</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">prev_match</span><span class="sc10">,</span><span class="sc0">
                           </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">prev_length</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">bflush</span><span class="sc10">);</span><span class="sc0">

            </span><span class="sc1">/* Insert in hash table all strings up to the end of the match.
             * strstart-1 and strstart are already inserted. If there is not
             * enough lookahead, the last two strings are not inserted in
             * the hash table.
             */</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">prev_length</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">prev_length</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(++</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">max_insert</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                    </span><span class="sc11">INSERT_STRING</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc10">);</span><span class="sc0">
                </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(--</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">prev_length</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_available</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">++;</span><span class="sc0">

            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bflush</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">FLUSH_BLOCK</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_available</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc1">/* If there was no match at the previous position, output a
             * single literal. If there was a match but the current match
             * is longer, truncate the previous match to a single literal.
             */</span><span class="sc0">
            </span><span class="sc11">Tracevv</span><span class="sc10">((</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc6">"%c"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">]));</span><span class="sc0">
            </span><span class="sc11">_tr_tally_lit</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">],</span><span class="sc0"> </span><span class="sc11">bflush</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bflush</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">FLUSH_BLOCK_ONLY</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">++;</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc10">--;</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">avail_out</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">need_more</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc1">/* There is no previous match to compare with, wait for
             * the next step to decide.
             */</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_available</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">++;</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc10">--;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">Z_NO_FLUSH</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"no flush?"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_available</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">Tracevv</span><span class="sc10">((</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc6">"%c"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">]));</span><span class="sc0">
        </span><span class="sc11">_tr_tally_lit</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">],</span><span class="sc0"> </span><span class="sc11">bflush</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">match_available</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">FLUSH_BLOCK</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_FINISH</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_FINISH</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc11">finish_done</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">block_done</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#endif </span><span class="sc1">/* FASTEST */</span><span class="sc0">

</span><span class="sc9">#if 0
</span><span class="sc1">/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc11">block_state</span><span class="sc0"> </span><span class="sc11">deflate_rle</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">bflush</span><span class="sc10">;</span><span class="sc0">         </span><span class="sc1">/* set if current block must be flushed */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">run</span><span class="sc10">;</span><span class="sc0">           </span><span class="sc1">/* length of run */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">max</span><span class="sc10">;</span><span class="sc0">           </span><span class="sc1">/* maximum length of run */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">prev</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* byte at distance one to match */</span><span class="sc0">
    </span><span class="sc11">Bytef</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">scan</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc1">/* scan for end of run */</span><span class="sc0">

    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(;;)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc1">/* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the longest encodable run.
         */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">MAX_MATCH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">fill_window</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">MAX_MATCH</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_NO_FLUSH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">need_more</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* flush the current block */</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">

        </span><span class="sc1">/* See how many times the previous byte repeats */</span><span class="sc0">
        </span><span class="sc11">run</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">      </span><span class="sc1">/* if there is a previous byte, that is */</span><span class="sc0">
            </span><span class="sc11">max</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">MAX_MATCH</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">MAX_MATCH</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">prev</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">scan</span><span class="sc10">++;</span><span class="sc0">
            </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(*</span><span class="sc11">scan</span><span class="sc10">++</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">prev</span><span class="sc10">)</span><span class="sc0">
                    </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(++</span><span class="sc11">run</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">max</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">

        </span><span class="sc1">/* Emit match if have run of MIN_MATCH or longer, else emit literal */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">run</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">check_match</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">run</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc11">_tr_tally_dist</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">run</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">bflush</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc11">run</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">run</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc1">/* No match, output a literal byte */</span><span class="sc0">
            </span><span class="sc11">Tracevv</span><span class="sc10">((</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc6">"%c"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">]));</span><span class="sc0">
            </span><span class="sc11">_tr_tally_lit</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">],</span><span class="sc0"> </span><span class="sc11">bflush</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lookahead</span><span class="sc10">--;</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc10">++;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bflush</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">FLUSH_BLOCK</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">FLUSH_BLOCK</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_FINISH</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_FINISH</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc11">finish_done</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">block_done</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#endif
</span></div></body>
</html>
