<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Exported from Notepad++</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc1 {
	color: #008000;
}
.sc4 {
	color: #FF8000;
}
.sc5 {
	font-weight: bold;
	color: #0000FF;
}
.sc6 {
	color: #808080;
}
.sc7 {
	color: #808080;
}
.sc9 {
	color: #804000;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc11 {
}
.sc16 {
	color: #8000FF;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc1">/* trees.c -- output deflated data using Huffman coding
 * Copyright (C) 1995-2005 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h
 */</span><span class="sc0">

</span><span class="sc1">/*
 *  ALGORITHM
 *
 *      The "deflation" process uses several Huffman trees. The more
 *      common source values are represented by shorter bit sequences.
 *
 *      Each code tree is stored in a compressed form which is itself
 * a Huffman encoding of the lengths of all the code strings (in
 * ascending order by source values).  The actual code strings are
 * reconstructed from the lengths in the inflate process, as described
 * in the deflate specification.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
 *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
 *
 *      Storer, James A.
 *          Data Compression:  Methods and Theory, pp. 49-50.
 *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
 *
 *      Sedgewick, R.
 *          Algorithms, p290.
 *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
 */</span><span class="sc0">

</span><span class="sc1">/* @(#) $Id$ */</span><span class="sc0">

</span><span class="sc1">/* #define GEN_TREES_H */</span><span class="sc0">

</span><span class="sc9">#include "deflate.h"
</span><span class="sc0">
</span><span class="sc9">#ifdef DEBUG
#  include &lt;ctype.h&gt;
#endif
</span><span class="sc0">
</span><span class="sc1">/* ===========================================================================
 * Constants
 */</span><span class="sc0">

</span><span class="sc9">#define MAX_BL_BITS 7
</span><span class="sc1">/* Bit length codes must not exceed MAX_BL_BITS bits */</span><span class="sc0">

</span><span class="sc9">#define END_BLOCK 256
</span><span class="sc1">/* end of block literal code */</span><span class="sc0">

</span><span class="sc9">#define REP_3_6      16
</span><span class="sc1">/* repeat previous bit length 3-6 times (2 bits of repeat count) */</span><span class="sc0">

</span><span class="sc9">#define REPZ_3_10    17
</span><span class="sc1">/* repeat a zero length 3-10 times  (3 bits of repeat count) */</span><span class="sc0">

</span><span class="sc9">#define REPZ_11_138  18
</span><span class="sc1">/* repeat a zero length 11-138 times  (7 bits of repeat count) */</span><span class="sc0">

</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">extra_lbits</span><span class="sc10">[</span><span class="sc11">LENGTH_CODES</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc1">/* extra bits for each length code */</span><span class="sc0">
   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc4">2</span><span class="sc10">,</span><span class="sc4">2</span><span class="sc10">,</span><span class="sc4">2</span><span class="sc10">,</span><span class="sc4">2</span><span class="sc10">,</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc4">5</span><span class="sc10">,</span><span class="sc4">5</span><span class="sc10">,</span><span class="sc4">5</span><span class="sc10">,</span><span class="sc4">5</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">};</span><span class="sc0">

</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">extra_dbits</span><span class="sc10">[</span><span class="sc11">D_CODES</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc1">/* extra bits for each distance code */</span><span class="sc0">
   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc4">2</span><span class="sc10">,</span><span class="sc4">2</span><span class="sc10">,</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc4">5</span><span class="sc10">,</span><span class="sc4">5</span><span class="sc10">,</span><span class="sc4">6</span><span class="sc10">,</span><span class="sc4">6</span><span class="sc10">,</span><span class="sc4">7</span><span class="sc10">,</span><span class="sc4">7</span><span class="sc10">,</span><span class="sc4">8</span><span class="sc10">,</span><span class="sc4">8</span><span class="sc10">,</span><span class="sc4">9</span><span class="sc10">,</span><span class="sc4">9</span><span class="sc10">,</span><span class="sc4">10</span><span class="sc10">,</span><span class="sc4">10</span><span class="sc10">,</span><span class="sc4">11</span><span class="sc10">,</span><span class="sc4">11</span><span class="sc10">,</span><span class="sc4">12</span><span class="sc10">,</span><span class="sc4">12</span><span class="sc10">,</span><span class="sc4">13</span><span class="sc10">,</span><span class="sc4">13</span><span class="sc10">};</span><span class="sc0">

</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">extra_blbits</span><span class="sc10">[</span><span class="sc11">BL_CODES</span><span class="sc10">]</span><span class="sc1">/* extra bits for each bit length code */</span><span class="sc0">
   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">2</span><span class="sc10">,</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc4">7</span><span class="sc10">};</span><span class="sc0">

</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">bl_order</span><span class="sc10">[</span><span class="sc11">BL_CODES</span><span class="sc10">]</span><span class="sc0">
   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">16</span><span class="sc10">,</span><span class="sc4">17</span><span class="sc10">,</span><span class="sc4">18</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">8</span><span class="sc10">,</span><span class="sc4">7</span><span class="sc10">,</span><span class="sc4">9</span><span class="sc10">,</span><span class="sc4">6</span><span class="sc10">,</span><span class="sc4">10</span><span class="sc10">,</span><span class="sc4">5</span><span class="sc10">,</span><span class="sc4">11</span><span class="sc10">,</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc4">12</span><span class="sc10">,</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc4">13</span><span class="sc10">,</span><span class="sc4">2</span><span class="sc10">,</span><span class="sc4">14</span><span class="sc10">,</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc4">15</span><span class="sc10">};</span><span class="sc0">
</span><span class="sc1">/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */</span><span class="sc0">

</span><span class="sc9">#define Buf_size (8 * 2*sizeof(char))
</span><span class="sc1">/* Number of bits used within bi_buf. (bi_buf might be implemented on
 * more than 16 bits on some systems.)
 */</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Local data. These are initialized only once.
 */</span><span class="sc0">

</span><span class="sc9">#define DIST_CODE_LEN  512 </span><span class="sc1">/* see definition of array dist_code below */</span><span class="sc0">

</span><span class="sc9">#if defined(GEN_TREES_H) || !defined(STDC)
</span><span class="sc1">/* non ANSI compilers may not accept trees.h */</span><span class="sc0">

</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc11">static_ltree</span><span class="sc10">[</span><span class="sc11">L_CODES</span><span class="sc10">+</span><span class="sc4">2</span><span class="sc10">];</span><span class="sc0">
</span><span class="sc1">/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */</span><span class="sc0">

</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc11">static_dtree</span><span class="sc10">[</span><span class="sc11">D_CODES</span><span class="sc10">];</span><span class="sc0">
</span><span class="sc1">/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */</span><span class="sc0">

</span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">_dist_code</span><span class="sc10">[</span><span class="sc11">DIST_CODE_LEN</span><span class="sc10">];</span><span class="sc0">
</span><span class="sc1">/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */</span><span class="sc0">

</span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">_length_code</span><span class="sc10">[</span><span class="sc11">MAX_MATCH</span><span class="sc10">-</span><span class="sc11">MIN_MATCH</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">];</span><span class="sc0">
</span><span class="sc1">/* length code for each normalized match length (0 == MIN_MATCH) */</span><span class="sc0">

</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">base_length</span><span class="sc10">[</span><span class="sc11">LENGTH_CODES</span><span class="sc10">];</span><span class="sc0">
</span><span class="sc1">/* First normalized length for each code (0 = MIN_MATCH) */</span><span class="sc0">

</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">base_dist</span><span class="sc10">[</span><span class="sc11">D_CODES</span><span class="sc10">];</span><span class="sc0">
</span><span class="sc1">/* First normalized distance for each code (0 = distance of 1) */</span><span class="sc0">

</span><span class="sc9">#else
#  include "trees.h"
#endif </span><span class="sc1">/* GEN_TREES_H */</span><span class="sc0">

</span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">static_tree_desc_s</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">static_tree</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* static tree or NULL */</span><span class="sc0">
    </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">intf</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">extra_bits</span><span class="sc10">;</span><span class="sc0">      </span><span class="sc1">/* extra bits for each code or NULL */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0">     </span><span class="sc11">extra_base</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* base index for extra_bits */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0">     </span><span class="sc11">elems</span><span class="sc10">;</span><span class="sc0">               </span><span class="sc1">/* max number of elements in the tree */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0">     </span><span class="sc11">max_length</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* max bit length for the codes */</span><span class="sc0">
</span><span class="sc10">};</span><span class="sc0">

</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc11">static_tree_desc</span><span class="sc0">  </span><span class="sc11">static_l_desc</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc11">static_ltree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">extra_lbits</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">LITERALS</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">L_CODES</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">MAX_BITS</span><span class="sc10">};</span><span class="sc0">

</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc11">static_tree_desc</span><span class="sc0">  </span><span class="sc11">static_d_desc</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc11">static_dtree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">extra_dbits</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0">          </span><span class="sc11">D_CODES</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">MAX_BITS</span><span class="sc10">};</span><span class="sc0">

</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc11">static_tree_desc</span><span class="sc0">  </span><span class="sc11">static_bl_desc</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0">
</span><span class="sc10">{(</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">extra_blbits</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0">   </span><span class="sc11">BL_CODES</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">MAX_BL_BITS</span><span class="sc10">};</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Local (static) routines in this file.
 */</span><span class="sc0">

</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">tr_static_init</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc16">void</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">init_block</span><span class="sc0">     </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">pqdownheap</span><span class="sc0">     </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">k</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">gen_bitlen</span><span class="sc0">     </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">desc</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">gen_codes</span><span class="sc0">      </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ushf</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">bl_count</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">build_tree</span><span class="sc0">     </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">desc</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">scan_tree</span><span class="sc0">      </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">send_tree</span><span class="sc0">      </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0">  </span><span class="sc11">build_bl_tree</span><span class="sc0">  </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">send_all_trees</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">lcodes</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">dcodes</span><span class="sc10">,</span><span class="sc0">
                              </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">blcodes</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">compress_block</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">ltree</span><span class="sc10">,</span><span class="sc0">
                              </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">dtree</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">set_data_type</span><span class="sc0">  </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">bi_reverse</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">value</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">bi_windup</span><span class="sc0">      </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">bi_flush</span><span class="sc0">       </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">copy_block</span><span class="sc0">     </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">charf</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">,</span><span class="sc0">
                              </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">header</span><span class="sc10">));</span><span class="sc0">

</span><span class="sc9">#ifdef GEN_TREES_H
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">gen_trees_header</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc16">void</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
</span><span class="sc9">#ifndef DEBUG
#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
</span><span class="sc0">   </span><span class="sc1">/* Send a code of the given tree. c and tree must not have side effects */</span><span class="sc0">

</span><span class="sc9">#else </span><span class="sc1">/* DEBUG */</span><span class="sc0">
</span><span class="sc9">#  define send_code(s, c, tree) \
     { if (z_verbose&gt;2) fprintf(stderr,"\ncd %3d ",(c)); \
       send_bits(s, tree[c].Code, tree[c].Len); }
#endif
</span><span class="sc0">
</span><span class="sc1">/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */</span><span class="sc0">
</span><span class="sc9">#define put_short(s, w) { \
    put_byte(s, (uch)((w) &amp; 0xff)); \
    put_byte(s, (uch)((ush)(w) &gt;&gt; 8)); \
}
</span><span class="sc0">
</span><span class="sc1">/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length &lt;= 16 and value fits in length bits.
 */</span><span class="sc0">
</span><span class="sc9">#ifdef DEBUG
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">send_bits</span><span class="sc0">      </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">value</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">));</span><span class="sc0">

</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">value</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">value</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* value to send */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* number of bits */</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">Tracevv</span><span class="sc10">((</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc6">" l %2d v %4x "</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">value</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">length</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">15</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"invalid length"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bits_sent</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">length</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* If not enough room in bi_buf, use (valid) bits from bi_buf and
     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
     * unused bits in value.
     */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">int</span><span class="sc10">)</span><span class="sc11">Buf_size</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_buf</span><span class="sc0"> </span><span class="sc10">|=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">value</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_valid</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">put_short</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_buf</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_buf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">value</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Buf_size</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_valid</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">Buf_size</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_buf</span><span class="sc0"> </span><span class="sc10">|=</span><span class="sc0"> </span><span class="sc11">value</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_valid</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#else </span><span class="sc1">/* !DEBUG */</span><span class="sc0">

</span><span class="sc9">#define send_bits(s, value, length) \
{ int len = length;\
  if (s-&gt;bi_valid &gt; (int)Buf_size - len) {\
    int val = value;\
    s-&gt;bi_buf |= (val &lt;&lt; s-&gt;bi_valid);\
    put_short(s, s-&gt;bi_buf);\
    s-&gt;bi_buf = (ush)val &gt;&gt; (Buf_size - s-&gt;bi_valid);\
    s-&gt;bi_valid += len - Buf_size;\
  } else {\
    s-&gt;bi_buf |= (value) &lt;&lt; s-&gt;bi_valid;\
    s-&gt;bi_valid += len;\
  }\
}
#endif </span><span class="sc1">/* DEBUG */</span><span class="sc0">


</span><span class="sc1">/* the arguments must not have side effects */</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Initialize the various 'constant' tables.
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">tr_static_init</span><span class="sc10">()</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
</span><span class="sc9">#if defined(GEN_TREES_H) || !defined(STDC)
</span><span class="sc0">    </span><span class="sc16">static</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">static_init_done</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc1">/* iterates over tree elements */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">;</span><span class="sc0">     </span><span class="sc1">/* bit counter */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc1">/* length value */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc10">;</span><span class="sc0">     </span><span class="sc1">/* code value */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">dist</span><span class="sc10">;</span><span class="sc0">     </span><span class="sc1">/* distance index */</span><span class="sc0">
    </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">MAX_BITS</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">];</span><span class="sc0">
    </span><span class="sc1">/* number of codes at each bit length for an optimal tree */</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">static_init_done</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* For some embedded targets, global variables are not initialized: */</span><span class="sc0">
    </span><span class="sc11">static_l_desc</span><span class="sc10">.</span><span class="sc11">static_tree</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">static_ltree</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">static_l_desc</span><span class="sc10">.</span><span class="sc11">extra_bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">extra_lbits</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">static_d_desc</span><span class="sc10">.</span><span class="sc11">static_tree</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">static_dtree</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">static_d_desc</span><span class="sc10">.</span><span class="sc11">extra_bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">extra_dbits</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">static_bl_desc</span><span class="sc10">.</span><span class="sc11">extra_bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">extra_blbits</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* Initialize the mapping length (0..255) -&gt; length code (0..28) */</span><span class="sc0">
    </span><span class="sc11">length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">LENGTH_CODES</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">base_length</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc4">1</span><span class="sc10">&lt;&lt;</span><span class="sc11">extra_lbits</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">]);</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">_length_code</span><span class="sc10">[</span><span class="sc11">length</span><span class="sc10">++]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uch</span><span class="sc10">)</span><span class="sc11">code</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">length</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">256</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"tr_static_init: length != 256"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc1">/* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */</span><span class="sc0">
    </span><span class="sc11">_length_code</span><span class="sc10">[</span><span class="sc11">length</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uch</span><span class="sc10">)</span><span class="sc11">code</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* Initialize the mapping dist (0..32K) -&gt; dist code (0..29) */</span><span class="sc0">
    </span><span class="sc11">dist</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">16</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">base_dist</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">dist</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc4">1</span><span class="sc10">&lt;&lt;</span><span class="sc11">extra_dbits</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">]);</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">_dist_code</span><span class="sc10">[</span><span class="sc11">dist</span><span class="sc10">++]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uch</span><span class="sc10">)</span><span class="sc11">code</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">dist</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">256</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"tr_static_init: dist != 256"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">dist</span><span class="sc0"> </span><span class="sc10">&gt;&gt;=</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* from now on, all distances are divided by 128 */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc0"> </span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">D_CODES</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">base_dist</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">dist</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc4">1</span><span class="sc10">&lt;&lt;(</span><span class="sc11">extra_dbits</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">]-</span><span class="sc4">7</span><span class="sc10">));</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">_dist_code</span><span class="sc10">[</span><span class="sc4">256</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">dist</span><span class="sc10">++]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uch</span><span class="sc10">)</span><span class="sc11">code</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">dist</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">256</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"tr_static_init: 256+dist != 512"</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc1">/* Construct the codes of the static literal tree */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">MAX_BITS</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">bits</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">143</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">static_ltree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">++].</span><span class="sc11">Len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc4">8</span><span class="sc10">]++;</span><span class="sc0">
    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">255</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">static_ltree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">++].</span><span class="sc11">Len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">9</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc4">9</span><span class="sc10">]++;</span><span class="sc0">
    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">279</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">static_ltree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">++].</span><span class="sc11">Len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc4">7</span><span class="sc10">]++;</span><span class="sc0">
    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">287</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">static_ltree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">++].</span><span class="sc11">Len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc4">8</span><span class="sc10">]++;</span><span class="sc0">
    </span><span class="sc1">/* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */</span><span class="sc0">
    </span><span class="sc11">gen_codes</span><span class="sc10">((</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">static_ltree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">L_CODES</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">bl_count</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc1">/* The static distance tree is trivial: */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">D_CODES</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">static_dtree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">Len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">5</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">static_dtree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">Code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">bi_reverse</span><span class="sc10">((</span><span class="sc16">unsigned</span><span class="sc10">)</span><span class="sc11">n</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">5</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">static_init_done</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc9">#  ifdef GEN_TREES_H
</span><span class="sc0">    </span><span class="sc11">gen_trees_header</span><span class="sc10">();</span><span class="sc0">
</span><span class="sc9">#  endif
#endif </span><span class="sc1">/* defined(GEN_TREES_H) || !defined(STDC) */</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Genererate the file trees.h describing the static trees.
 */</span><span class="sc0">
</span><span class="sc9">#ifdef GEN_TREES_H
#  ifndef DEBUG
#    include &lt;stdio.h&gt;
#  endif
</span><span class="sc0">
</span><span class="sc9">#  define SEPARATOR(i, last, width) \
      ((i) == (last)? "\n};\n\n" :    \
       ((i) % (width) == (width)-1 ? ",\n" : ", "))
</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">gen_trees_header</span><span class="sc10">()</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">FILE</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">header</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">fopen</span><span class="sc10">(</span><span class="sc6">"trees.h"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"w"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">i</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">Assert</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">header</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc5">NULL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"Can't open trees.h"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">fprintf</span><span class="sc10">(</span><span class="sc11">header</span><span class="sc10">,</span><span class="sc0">
            </span><span class="sc6">"/* header created automatically with -DGEN_TREES_H */\n\n"</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">fprintf</span><span class="sc10">(</span><span class="sc11">header</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"local const ct_data static_ltree[L_CODES+2] = {\n"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">i</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">i</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">L_CODES</span><span class="sc10">+</span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">i</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">fprintf</span><span class="sc10">(</span><span class="sc11">header</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"{{%3u},{%3u}}%s"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">static_ltree</span><span class="sc10">[</span><span class="sc11">i</span><span class="sc10">].</span><span class="sc11">Code</span><span class="sc10">,</span><span class="sc0">
                </span><span class="sc11">static_ltree</span><span class="sc10">[</span><span class="sc11">i</span><span class="sc10">].</span><span class="sc11">Len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">SEPARATOR</span><span class="sc10">(</span><span class="sc11">i</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">L_CODES</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">5</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc11">fprintf</span><span class="sc10">(</span><span class="sc11">header</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"local const ct_data static_dtree[D_CODES] = {\n"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">i</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">i</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">D_CODES</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">i</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">fprintf</span><span class="sc10">(</span><span class="sc11">header</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"{{%2u},{%2u}}%s"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">static_dtree</span><span class="sc10">[</span><span class="sc11">i</span><span class="sc10">].</span><span class="sc11">Code</span><span class="sc10">,</span><span class="sc0">
                </span><span class="sc11">static_dtree</span><span class="sc10">[</span><span class="sc11">i</span><span class="sc10">].</span><span class="sc11">Len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">SEPARATOR</span><span class="sc10">(</span><span class="sc11">i</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">D_CODES</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">5</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc11">fprintf</span><span class="sc10">(</span><span class="sc11">header</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"const uch _dist_code[DIST_CODE_LEN] = {\n"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">i</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">i</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">DIST_CODE_LEN</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">i</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">fprintf</span><span class="sc10">(</span><span class="sc11">header</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"%2u%s"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">_dist_code</span><span class="sc10">[</span><span class="sc11">i</span><span class="sc10">],</span><span class="sc0">
                </span><span class="sc11">SEPARATOR</span><span class="sc10">(</span><span class="sc11">i</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">DIST_CODE_LEN</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">20</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc11">fprintf</span><span class="sc10">(</span><span class="sc11">header</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {\n"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">i</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">i</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">MAX_MATCH</span><span class="sc10">-</span><span class="sc11">MIN_MATCH</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">i</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">fprintf</span><span class="sc10">(</span><span class="sc11">header</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"%2u%s"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">_length_code</span><span class="sc10">[</span><span class="sc11">i</span><span class="sc10">],</span><span class="sc0">
                </span><span class="sc11">SEPARATOR</span><span class="sc10">(</span><span class="sc11">i</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">MAX_MATCH</span><span class="sc10">-</span><span class="sc11">MIN_MATCH</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">20</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc11">fprintf</span><span class="sc10">(</span><span class="sc11">header</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"local const int base_length[LENGTH_CODES] = {\n"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">i</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">i</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">LENGTH_CODES</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">i</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">fprintf</span><span class="sc10">(</span><span class="sc11">header</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"%1u%s"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">base_length</span><span class="sc10">[</span><span class="sc11">i</span><span class="sc10">],</span><span class="sc0">
                </span><span class="sc11">SEPARATOR</span><span class="sc10">(</span><span class="sc11">i</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">LENGTH_CODES</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">20</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc11">fprintf</span><span class="sc10">(</span><span class="sc11">header</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"local const int base_dist[D_CODES] = {\n"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">i</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">i</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">D_CODES</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">i</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">fprintf</span><span class="sc10">(</span><span class="sc11">header</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"%5u%s"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">base_dist</span><span class="sc10">[</span><span class="sc11">i</span><span class="sc10">],</span><span class="sc0">
                </span><span class="sc11">SEPARATOR</span><span class="sc10">(</span><span class="sc11">i</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">D_CODES</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">10</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc11">fclose</span><span class="sc10">(</span><span class="sc11">header</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#endif </span><span class="sc1">/* GEN_TREES_H */</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">_tr_init</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">tr_static_init</span><span class="sc10">();</span><span class="sc0">

    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">l_desc</span><span class="sc10">.</span><span class="sc11">dyn_tree</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">dyn_ltree</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">l_desc</span><span class="sc10">.</span><span class="sc11">stat_desc</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">static_l_desc</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">d_desc</span><span class="sc10">.</span><span class="sc11">dyn_tree</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">dyn_dtree</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">d_desc</span><span class="sc10">.</span><span class="sc11">stat_desc</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">static_d_desc</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_desc</span><span class="sc10">.</span><span class="sc11">dyn_tree</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_tree</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_desc</span><span class="sc10">.</span><span class="sc11">stat_desc</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">static_bl_desc</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_buf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_eob_len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* enough lookahead for inflate */</span><span class="sc0">
</span><span class="sc9">#ifdef DEBUG
</span><span class="sc0">    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">compressed_len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0L</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bits_sent</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0L</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
    </span><span class="sc1">/* Initialize the first block of the first file: */</span><span class="sc0">
    </span><span class="sc11">init_block</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Initialize a new block.
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">init_block</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* iterates over tree elements */</span><span class="sc0">

    </span><span class="sc1">/* Initialize the trees. */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">L_CODES</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">dyn_ltree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">D_CODES</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">dyn_dtree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">BL_CODES</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">dyn_ltree</span><span class="sc10">[</span><span class="sc11">END_BLOCK</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">opt_len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">static_len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0L</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_lit</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">matches</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc9">#define SMALLEST 1
</span><span class="sc1">/* Index within the heap array of least frequent node in the Huffman tree */</span><span class="sc0">


</span><span class="sc1">/* ===========================================================================
 * Remove the smallest element from the heap and recreate the heap with
 * one less element. Updates heap and heap_len.
 */</span><span class="sc0">
</span><span class="sc9">#define pqremove(s, tree, top) \
{\
    top = s-&gt;heap[SMALLEST]; \
    s-&gt;heap[SMALLEST] = s-&gt;heap[s-&gt;heap_len--]; \
    pqdownheap(s, tree, SMALLEST); \
}
</span><span class="sc0">
</span><span class="sc1">/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */</span><span class="sc0">
</span><span class="sc9">#define smaller(tree, n, m, depth) \
   (tree[n].Freq &lt; tree[m].Freq || \
   (tree[n].Freq == tree[m].Freq &amp;&amp; depth[n] &lt;= depth[m]))
</span><span class="sc0">
</span><span class="sc1">/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">pqdownheap</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">k</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* the tree to restore */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">k</span><span class="sc10">;</span><span class="sc0">               </span><span class="sc1">/* node to move down */</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">v</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">k</span><span class="sc10">];</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">j</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">k</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* left son of k */</span><span class="sc0">
    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">j</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap_len</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc1">/* Set j to the smallest of the two sons: */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">j</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap_len</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
            </span><span class="sc11">smaller</span><span class="sc10">(</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">j</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">],</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">j</span><span class="sc10">],</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">depth</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">j</span><span class="sc10">++;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc1">/* Exit if v is smaller than both sons */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">smaller</span><span class="sc10">(</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">v</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">j</span><span class="sc10">],</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">depth</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc1">/* Exchange v with the smallest son */</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">k</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">j</span><span class="sc10">];</span><span class="sc0">  </span><span class="sc11">k</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">j</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc1">/* And continue down the tree, setting j to the left son of k */</span><span class="sc0">
        </span><span class="sc11">j</span><span class="sc0"> </span><span class="sc10">&lt;&lt;=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">k</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">v</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">gen_bitlen</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">desc</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc1">/* the tree descriptor */</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc0">        </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">dyn_tree</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc0">         </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">max_code</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">stree</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">stat_desc</span><span class="sc10">-&gt;</span><span class="sc11">static_tree</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">intf</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">extra</span><span class="sc0">    </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">stat_desc</span><span class="sc10">-&gt;</span><span class="sc11">extra_bits</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">base</span><span class="sc0">             </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">stat_desc</span><span class="sc10">-&gt;</span><span class="sc11">extra_base</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_length</span><span class="sc0">       </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">stat_desc</span><span class="sc10">-&gt;</span><span class="sc11">max_length</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">h</span><span class="sc10">;</span><span class="sc0">              </span><span class="sc1">/* heap index */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">m</span><span class="sc10">;</span><span class="sc0">           </span><span class="sc1">/* iterate over the tree elements */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">;</span><span class="sc0">           </span><span class="sc1">/* bit length */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">xbits</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* extra bits */</span><span class="sc0">
    </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">;</span><span class="sc0">              </span><span class="sc1">/* frequency */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">overflow</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc1">/* number of elements with bit length too large */</span><span class="sc0">

    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">MAX_BITS</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">bits</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */</span><span class="sc0">
    </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap_max</span><span class="sc10">]].</span><span class="sc11">Len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* root of the heap */</span><span class="sc0">

    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">h</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap_max</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">h</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">HEAP_SIZE</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">h</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">h</span><span class="sc10">];</span><span class="sc0">
        </span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">Dad</span><span class="sc10">].</span><span class="sc11">Len</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">max_length</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">max_length</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">overflow</span><span class="sc10">++;</span><span class="sc0">
        </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">Len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">bits</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc1">/* We overwrite tree[n].Dad which is no longer needed */</span><span class="sc0">

        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">continue</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* not a leaf node */</span><span class="sc0">

        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">bits</span><span class="sc10">]++;</span><span class="sc0">
        </span><span class="sc11">xbits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">base</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">xbits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">extra</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">-</span><span class="sc11">base</span><span class="sc10">];</span><span class="sc0">
        </span><span class="sc11">f</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">opt_len</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">f</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">xbits</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stree</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">static_len</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">f</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">Len</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">xbits</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">overflow</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">Trace</span><span class="sc10">((</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc6">"\nbit length overflow\n"</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc1">/* This happens for example on obj2 and pic of the Calgary corpus */</span><span class="sc0">

    </span><span class="sc1">/* Find the first bit length which could increase: */</span><span class="sc0">
    </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">max_length</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">bits</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">--;</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">bits</span><span class="sc10">]--;</span><span class="sc0">      </span><span class="sc1">/* move one leaf down the tree */</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">bits</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* move one overflow item as its brother */</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">max_length</span><span class="sc10">]--;</span><span class="sc0">
        </span><span class="sc1">/* The brother of the overflow item also moves one step up,
         * but this does not affect bl_count[max_length]
         */</span><span class="sc0">
        </span><span class="sc11">overflow</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">overflow</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc1">/* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">max_length</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">--)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">bits</span><span class="sc10">];</span><span class="sc0">
        </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">m</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap</span><span class="sc10">[--</span><span class="sc11">h</span><span class="sc10">];</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">m</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">continue</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc16">unsigned</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">m</span><span class="sc10">].</span><span class="sc11">Len</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">Trace</span><span class="sc10">((</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc6">"code %d bits %d-&gt;%d\n"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">m</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">m</span><span class="sc10">].</span><span class="sc11">Len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">));</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">opt_len</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc16">long</span><span class="sc10">)</span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">long</span><span class="sc10">)</span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">m</span><span class="sc10">].</span><span class="sc11">Len</span><span class="sc10">)</span><span class="sc0">
                              </span><span class="sc10">*(</span><span class="sc16">long</span><span class="sc10">)</span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">m</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc10">;</span><span class="sc0">
                </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">m</span><span class="sc10">].</span><span class="sc11">Len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">bits</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc11">n</span><span class="sc10">--;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">gen_codes</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">bl_count</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc10">;</span><span class="sc0">             </span><span class="sc1">/* the tree to decorate */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">;</span><span class="sc0">              </span><span class="sc1">/* largest code with non zero frequency */</span><span class="sc0">
    </span><span class="sc11">ushf</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">bl_count</span><span class="sc10">;</span><span class="sc0">            </span><span class="sc1">/* number of codes at each bit length */</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">next_code</span><span class="sc10">[</span><span class="sc11">MAX_BITS</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">];</span><span class="sc0"> </span><span class="sc1">/* next code value for each bit length */</span><span class="sc0">
    </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">              </span><span class="sc1">/* running code value */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">;</span><span class="sc0">                  </span><span class="sc1">/* bit index */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0">                     </span><span class="sc1">/* code index */</span><span class="sc0">

    </span><span class="sc1">/* The distribution counts are first used to generate the code values
     * without bit reversal.
     */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">MAX_BITS</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">next_code</span><span class="sc10">[</span><span class="sc11">bits</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">bits</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">])</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc1">/* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">MAX_BITS</span><span class="sc10">]-</span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc4">1</span><span class="sc10">&lt;&lt;</span><span class="sc11">MAX_BITS</span><span class="sc10">)-</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0">
            </span><span class="sc6">"inconsistent bit counts"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">Tracev</span><span class="sc10">((</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc6">"\ngen_codes: max_code %d "</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">));</span><span class="sc0">

    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">Len</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">continue</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc1">/* Now reverse the bits */</span><span class="sc0">
        </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">Code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">bi_reverse</span><span class="sc10">(</span><span class="sc11">next_code</span><span class="sc10">[</span><span class="sc11">len</span><span class="sc10">]++,</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc11">Tracecv</span><span class="sc10">(</span><span class="sc11">tree</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">static_ltree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc6">"\nn %3d %c l %2d c %4x (%x) "</span><span class="sc10">,</span><span class="sc0">
             </span><span class="sc11">n</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">isgraph</span><span class="sc10">(</span><span class="sc11">n</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc7">' '</span><span class="sc10">),</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">Code</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">next_code</span><span class="sc10">[</span><span class="sc11">len</span><span class="sc10">]-</span><span class="sc4">1</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">build_tree</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">desc</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* the tree descriptor */</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc0">         </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">dyn_tree</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">stree</span><span class="sc0">  </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">stat_desc</span><span class="sc10">-&gt;</span><span class="sc11">static_tree</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">elems</span><span class="sc0">             </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">stat_desc</span><span class="sc10">-&gt;</span><span class="sc11">elems</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">m</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* iterate over heap elements */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* largest code with non zero frequency */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">node</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* new node being created */</span><span class="sc0">

    </span><span class="sc1">/* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap_len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap_max</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">HEAP_SIZE</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">elems</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap</span><span class="sc10">[++(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap_len</span><span class="sc10">)]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">depth</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">Len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc1">/* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */</span><span class="sc0">
    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap_len</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">node</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap</span><span class="sc10">[++(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap_len</span><span class="sc10">)]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">max_code</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc10">++</span><span class="sc11">max_code</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">node</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">depth</span><span class="sc10">[</span><span class="sc11">node</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">opt_len</span><span class="sc10">--;</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stree</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">static_len</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc11">stree</span><span class="sc10">[</span><span class="sc11">node</span><span class="sc10">].</span><span class="sc11">Len</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc1">/* node is 0 or 1 so it does not have extra bits */</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">max_code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap_len</span><span class="sc10">/</span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">--)</span><span class="sc0"> </span><span class="sc11">pqdownheap</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc1">/* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */</span><span class="sc0">
    </span><span class="sc11">node</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">elems</span><span class="sc10">;</span><span class="sc0">              </span><span class="sc1">/* next internal node of the tree */</span><span class="sc0">
    </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">pqremove</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">);</span><span class="sc0">  </span><span class="sc1">/* n = node of least frequency */</span><span class="sc0">
        </span><span class="sc11">m</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">SMALLEST</span><span class="sc10">];</span><span class="sc0"> </span><span class="sc1">/* m = node of next least frequency */</span><span class="sc0">

        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap</span><span class="sc10">[--(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap_max</span><span class="sc10">)]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* keep the nodes sorted by frequency */</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap</span><span class="sc10">[--(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap_max</span><span class="sc10">)]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">m</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc1">/* Create a new node father of n and m */</span><span class="sc0">
        </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">node</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">m</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">depth</span><span class="sc10">[</span><span class="sc11">node</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uch</span><span class="sc10">)((</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">depth</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">depth</span><span class="sc10">[</span><span class="sc11">m</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0">
                                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">depth</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">depth</span><span class="sc10">[</span><span class="sc11">m</span><span class="sc10">])</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">Dad</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">m</span><span class="sc10">].</span><span class="sc11">Dad</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">node</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#ifdef DUMP_BL_TREE
</span><span class="sc0">        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">tree</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_tree</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">fprintf</span><span class="sc10">(</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc6">"\nnode %d(%d), sons %d(%d) %d(%d)"</span><span class="sc10">,</span><span class="sc0">
                    </span><span class="sc11">node</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">node</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">m</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">m</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">        </span><span class="sc1">/* and insert the new node in the heap */</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">SMALLEST</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">node</span><span class="sc10">++;</span><span class="sc0">
        </span><span class="sc11">pqdownheap</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">SMALLEST</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap_len</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap</span><span class="sc10">[--(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap_max</span><span class="sc10">)]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">SMALLEST</span><span class="sc10">];</span><span class="sc0">

    </span><span class="sc1">/* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */</span><span class="sc0">
    </span><span class="sc11">gen_bitlen</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">desc</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc1">/* The field len is now set, we can generate the bit codes */</span><span class="sc0">
    </span><span class="sc11">gen_codes</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_count</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">scan_tree</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc1">/* the tree to be scanned */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc1">/* and its largest code of non zero frequency */</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0">                     </span><span class="sc1">/* iterates over all tree elements */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">prevlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* last emitted length */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">curlen</span><span class="sc10">;</span><span class="sc0">                </span><span class="sc1">/* length of current code */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc4">0</span><span class="sc10">].</span><span class="sc11">Len</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* length of next code */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">             </span><span class="sc1">/* repeat count of the current code */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">;</span><span class="sc0">         </span><span class="sc1">/* max repeat count */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">;</span><span class="sc0">         </span><span class="sc1">/* min repeat count */</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">nextlen</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">138</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">max_code</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">].</span><span class="sc11">Len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc4">0xffff</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* guard */</span><span class="sc0">

    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">].</span><span class="sc11">Len</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(++</span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc5">continue</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_tree</span><span class="sc10">[</span><span class="sc11">curlen</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">count</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">prevlen</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_tree</span><span class="sc10">[</span><span class="sc11">curlen</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc10">++;</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_tree</span><span class="sc10">[</span><span class="sc11">REP_3_6</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc10">++;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">10</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_tree</span><span class="sc10">[</span><span class="sc11">REPZ_3_10</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc10">++;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_tree</span><span class="sc10">[</span><span class="sc11">REPZ_11_138</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc10">++;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">prevlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">curlen</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">nextlen</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">138</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">6</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">send_tree</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* the tree to be scanned */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc1">/* and its largest code of non zero frequency */</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0">                     </span><span class="sc1">/* iterates over all tree elements */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">prevlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* last emitted length */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">curlen</span><span class="sc10">;</span><span class="sc0">                </span><span class="sc1">/* length of current code */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc4">0</span><span class="sc10">].</span><span class="sc11">Len</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* length of next code */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">             </span><span class="sc1">/* repeat count of the current code */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">;</span><span class="sc0">         </span><span class="sc1">/* max repeat count */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">;</span><span class="sc0">         </span><span class="sc1">/* min repeat count */</span><span class="sc0">

    </span><span class="sc1">/* tree[max_code+1].Len = -1; */</span><span class="sc0">  </span><span class="sc1">/* guard already set */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">nextlen</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">138</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">].</span><span class="sc11">Len</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(++</span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc5">continue</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">curlen</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_tree</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(--</span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">prevlen</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">curlen</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_tree</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc11">count</span><span class="sc10">--;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">6</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">" 3_6?"</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">REP_3_6</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_tree</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">count</span><span class="sc10">-</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">10</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">REPZ_3_10</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_tree</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">count</span><span class="sc10">-</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">REPZ_11_138</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_tree</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">count</span><span class="sc10">-</span><span class="sc4">11</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">prevlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">curlen</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">nextlen</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">138</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">6</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">build_bl_tree</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_blindex</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* index of last bit length code of non zero freq */</span><span class="sc0">

    </span><span class="sc1">/* Determine the bit length frequencies for literal and distance trees */</span><span class="sc0">
    </span><span class="sc11">scan_tree</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">dyn_ltree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">l_desc</span><span class="sc10">.</span><span class="sc11">max_code</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">scan_tree</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">dyn_dtree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">d_desc</span><span class="sc10">.</span><span class="sc11">max_code</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc1">/* Build the bit length tree: */</span><span class="sc0">
    </span><span class="sc11">build_tree</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc10">*)(&amp;(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_desc</span><span class="sc10">)));</span><span class="sc0">
    </span><span class="sc1">/* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */</span><span class="sc0">

    </span><span class="sc1">/* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">max_blindex</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">BL_CODES</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">max_blindex</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">max_blindex</span><span class="sc10">--)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_tree</span><span class="sc10">[</span><span class="sc11">bl_order</span><span class="sc10">[</span><span class="sc11">max_blindex</span><span class="sc10">]].</span><span class="sc11">Len</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc1">/* Update opt_len to include the bit length tree and counts */</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">opt_len</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">*(</span><span class="sc11">max_blindex</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">5</span><span class="sc10">+</span><span class="sc4">5</span><span class="sc10">+</span><span class="sc4">4</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">Tracev</span><span class="sc10">((</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"\ndyn trees: dyn %ld, stat %ld"</span><span class="sc10">,</span><span class="sc0">
            </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">opt_len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">static_len</span><span class="sc10">));</span><span class="sc0">

    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">max_blindex</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes &gt;= 257, dcodes &gt;= 1, blcodes &gt;= 4.
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">send_all_trees</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">lcodes</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">dcodes</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">blcodes</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">lcodes</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">dcodes</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">blcodes</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* number of codes for each tree */</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">rank</span><span class="sc10">;</span><span class="sc0">                    </span><span class="sc1">/* index in bl_order */</span><span class="sc0">

    </span><span class="sc11">Assert</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">lcodes</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">257</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">dcodes</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">blcodes</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"not enough codes"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">lcodes</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">L_CODES</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">dcodes</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">D_CODES</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">blcodes</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">BL_CODES</span><span class="sc10">,</span><span class="sc0">
            </span><span class="sc6">"too many codes"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">Tracev</span><span class="sc10">((</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"\nbl counts: "</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">lcodes</span><span class="sc10">-</span><span class="sc4">257</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">5</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc1">/* not +255 as stated in appnote.txt */</span><span class="sc0">
    </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">dcodes</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0">   </span><span class="sc4">5</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">blcodes</span><span class="sc10">-</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0">  </span><span class="sc4">4</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc1">/* not -3 as stated in appnote.txt */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">rank</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">rank</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">blcodes</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">rank</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">Tracev</span><span class="sc10">((</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"\nbl code %2d "</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">bl_order</span><span class="sc10">[</span><span class="sc11">rank</span><span class="sc10">]));</span><span class="sc0">
        </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bl_tree</span><span class="sc10">[</span><span class="sc11">bl_order</span><span class="sc10">[</span><span class="sc11">rank</span><span class="sc10">]].</span><span class="sc11">Len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">Tracev</span><span class="sc10">((</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"\nbl tree: sent %ld"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bits_sent</span><span class="sc10">));</span><span class="sc0">

    </span><span class="sc11">send_tree</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">dyn_ltree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">lcodes</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc1">/* literal tree */</span><span class="sc0">
    </span><span class="sc11">Tracev</span><span class="sc10">((</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"\nlit tree: sent %ld"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bits_sent</span><span class="sc10">));</span><span class="sc0">

    </span><span class="sc11">send_tree</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">dyn_dtree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">dcodes</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc1">/* distance tree */</span><span class="sc0">
    </span><span class="sc11">Tracev</span><span class="sc10">((</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"\ndist tree: sent %ld"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bits_sent</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Send a stored block
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">_tr_stored_block</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">stored_len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">eof</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">charf</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc1">/* input block */</span><span class="sc0">
    </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">stored_len</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc1">/* length of input block */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">eof</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* true if this is the last block for a file */</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">STORED_BLOCK</span><span class="sc10">&lt;&lt;</span><span class="sc4">1</span><span class="sc10">)+</span><span class="sc11">eof</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">);</span><span class="sc0">  </span><span class="sc1">/* send block type */</span><span class="sc0">
</span><span class="sc9">#ifdef DEBUG
</span><span class="sc0">    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">compressed_len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">compressed_len</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)~</span><span class="sc4">7L</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">compressed_len</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stored_len</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">    </span><span class="sc11">copy_block</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc10">)</span><span class="sc11">stored_len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc1">/* with header */</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 * The current inflate code requires 9 bits of lookahead. If the
 * last two codes for the previous block (real code plus EOB) were coded
 * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
 * the last real code. In this case we send two empty static blocks instead
 * of one. (There are no problems if the previous block is stored or fixed.)
 * To simplify the code, we assume the worst case of last real code encoded
 * on one bit only.
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">_tr_align</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">STATIC_TREES</span><span class="sc10">&lt;&lt;</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">END_BLOCK</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">static_ltree</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc9">#ifdef DEBUG
</span><span class="sc0">    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">compressed_len</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">10L</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* 3 for block type, 7 for EOB */</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">    </span><span class="sc11">bi_flush</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc1">/* Of the 10 bits for the empty block, we have already sent
     * (10 - bi_valid) bits. The lookahead for the last real code (before
     * the EOB of the previous block) was thus at least one plus the length
     * of the EOB plus what we have just sent of the empty static block.
     */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_eob_len</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">10</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">9</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">STATIC_TREES</span><span class="sc10">&lt;&lt;</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">END_BLOCK</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">static_ltree</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc9">#ifdef DEBUG
</span><span class="sc0">        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">compressed_len</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">10L</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">        </span><span class="sc11">bi_flush</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_eob_len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">_tr_flush_block</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">stored_len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">eof</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">charf</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc1">/* input block, or NULL if too old */</span><span class="sc0">
    </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">stored_len</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc1">/* length of input block */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">eof</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* true if this is the last block for a file */</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">opt_lenb</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">static_lenb</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* opt_len and static_len in bytes */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_blindex</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* index of last bit length code of non zero freq */</span><span class="sc0">

    </span><span class="sc1">/* Build the Huffman trees unless a stored block is forced */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">

        </span><span class="sc1">/* Check if the file is binary or text */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stored_len</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">data_type</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_UNKNOWN</span><span class="sc10">)</span><span class="sc0">
            </span><span class="sc11">set_data_type</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc1">/* Construct the literal and distance trees */</span><span class="sc0">
        </span><span class="sc11">build_tree</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc10">*)(&amp;(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">l_desc</span><span class="sc10">)));</span><span class="sc0">
        </span><span class="sc11">Tracev</span><span class="sc10">((</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"\nlit data: dyn %ld, stat %ld"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">opt_len</span><span class="sc10">,</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">static_len</span><span class="sc10">));</span><span class="sc0">

        </span><span class="sc11">build_tree</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc10">*)(&amp;(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">d_desc</span><span class="sc10">)));</span><span class="sc0">
        </span><span class="sc11">Tracev</span><span class="sc10">((</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"\ndist data: dyn %ld, stat %ld"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">opt_len</span><span class="sc10">,</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">static_len</span><span class="sc10">));</span><span class="sc0">
        </span><span class="sc1">/* At this point, opt_len and static_len are the total bit lengths of
         * the compressed block data, excluding the tree representations.
         */</span><span class="sc0">

        </span><span class="sc1">/* Build the bit length tree for the above two trees, and get the index
         * in bl_order of the last bit length code to send.
         */</span><span class="sc0">
        </span><span class="sc11">max_blindex</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">build_bl_tree</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc1">/* Determine the best encoding. Compute the block lengths in bytes. */</span><span class="sc0">
        </span><span class="sc11">opt_lenb</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">opt_len</span><span class="sc10">+</span><span class="sc4">3</span><span class="sc10">+</span><span class="sc4">7</span><span class="sc10">)&gt;&gt;</span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">static_lenb</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">static_len</span><span class="sc10">+</span><span class="sc4">3</span><span class="sc10">+</span><span class="sc4">7</span><span class="sc10">)&gt;&gt;</span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc11">Tracev</span><span class="sc10">((</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u "</span><span class="sc10">,</span><span class="sc0">
                </span><span class="sc11">opt_lenb</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">opt_len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">static_lenb</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">static_len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">stored_len</span><span class="sc10">,</span><span class="sc0">
                </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_lit</span><span class="sc10">));</span><span class="sc0">

        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">static_lenb</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">opt_lenb</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">opt_lenb</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">static_lenb</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">buf</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">*)</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"lost buf"</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">opt_lenb</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">static_lenb</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">stored_len</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">5</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* force a stored block */</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

</span><span class="sc9">#ifdef FORCE_STORED
</span><span class="sc0">    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">buf</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">*)</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc1">/* force stored block */</span><span class="sc0">
</span><span class="sc9">#else
</span><span class="sc0">    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stored_len</span><span class="sc10">+</span><span class="sc4">4</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">opt_lenb</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">buf</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">*)</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                       </span><span class="sc1">/* 4: two words for the lengths */</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">        </span><span class="sc1">/* The test buf != NULL is only necessary if LIT_BUFSIZE &gt; WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE &lt;= WSIZE, it is never too late to
         * transform a block into a stored block.
         */</span><span class="sc0">
        </span><span class="sc11">_tr_stored_block</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">stored_len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">eof</span><span class="sc10">);</span><span class="sc0">

</span><span class="sc9">#ifdef FORCE_STATIC
</span><span class="sc0">    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">static_lenb</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc1">/* force static trees */</span><span class="sc0">
</span><span class="sc9">#else
</span><span class="sc0">    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strategy</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">Z_FIXED</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">static_lenb</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">opt_lenb</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">        </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">STATIC_TREES</span><span class="sc10">&lt;&lt;</span><span class="sc4">1</span><span class="sc10">)+</span><span class="sc11">eof</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">compress_block</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">static_ltree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">static_dtree</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc9">#ifdef DEBUG
</span><span class="sc0">        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">compressed_len</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">static_len</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">DYN_TREES</span><span class="sc10">&lt;&lt;</span><span class="sc4">1</span><span class="sc10">)+</span><span class="sc11">eof</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">send_all_trees</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">l_desc</span><span class="sc10">.</span><span class="sc11">max_code</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">d_desc</span><span class="sc10">.</span><span class="sc11">max_code</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0">
                       </span><span class="sc11">max_blindex</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">compress_block</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">dyn_ltree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">dyn_dtree</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc9">#ifdef DEBUG
</span><span class="sc0">        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">compressed_len</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">opt_len</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">compressed_len</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bits_sent</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"bad compressed size"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc1">/* The above check is made mod 2^32, for files larger than 512 MB
     * and uLong implemented on 32 bits.
     */</span><span class="sc0">
    </span><span class="sc11">init_block</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">eof</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">bi_windup</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc9">#ifdef DEBUG
</span><span class="sc0">        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">compressed_len</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* align on byte boundary */</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">Tracev</span><span class="sc10">((</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc6">"\ncomprlen %lu(%lu) "</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">compressed_len</span><span class="sc10">&gt;&gt;</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc0">
           </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">compressed_len</span><span class="sc10">-</span><span class="sc4">7</span><span class="sc10">*</span><span class="sc11">eof</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */</span><span class="sc0">
</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">_tr_tally</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">dist</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">lc</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">dist</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* distance of matched string */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">lc</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc1">/* match length-MIN_MATCH or unmatched char (if dist==0) */</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">d_buf</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_lit</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">dist</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">l_buf</span><span class="sc10">[</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_lit</span><span class="sc10">++]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uch</span><span class="sc10">)</span><span class="sc11">lc</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">dist</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc1">/* lc is the unmatched char */</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">dyn_ltree</span><span class="sc10">[</span><span class="sc11">lc</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc10">++;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">matches</span><span class="sc10">++;</span><span class="sc0">
        </span><span class="sc1">/* Here, lc is the match length - MIN_MATCH */</span><span class="sc0">
        </span><span class="sc11">dist</span><span class="sc10">--;</span><span class="sc0">             </span><span class="sc1">/* dist = match distance - 1 */</span><span class="sc0">
        </span><span class="sc11">Assert</span><span class="sc10">((</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">dist</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">MAX_DIST</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
               </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">lc</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)(</span><span class="sc11">MAX_MATCH</span><span class="sc10">-</span><span class="sc11">MIN_MATCH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
               </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">d_code</span><span class="sc10">(</span><span class="sc11">dist</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">D_CODES</span><span class="sc10">,</span><span class="sc0">  </span><span class="sc6">"_tr_tally: bad match"</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">dyn_ltree</span><span class="sc10">[</span><span class="sc11">_length_code</span><span class="sc10">[</span><span class="sc11">lc</span><span class="sc10">]+</span><span class="sc11">LITERALS</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc10">++;</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">dyn_dtree</span><span class="sc10">[</span><span class="sc11">d_code</span><span class="sc10">(</span><span class="sc11">dist</span><span class="sc10">)].</span><span class="sc11">Freq</span><span class="sc10">++;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

</span><span class="sc9">#ifdef TRUNCATE_BLOCK
</span><span class="sc0">    </span><span class="sc1">/* Try to guess if it is profitable to stop the current block here */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_lit</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0x1fff</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc1">/* Compute an upper bound for the compressed length */</span><span class="sc0">
        </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">out_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_lit</span><span class="sc10">*</span><span class="sc4">8L</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">in_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)((</span><span class="sc16">long</span><span class="sc10">)</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">block_start</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">dcode</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">dcode</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">dcode</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">D_CODES</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">dcode</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">out_length</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">dyn_dtree</span><span class="sc10">[</span><span class="sc11">dcode</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc0">
                </span><span class="sc10">(</span><span class="sc4">5L</span><span class="sc10">+</span><span class="sc11">extra_dbits</span><span class="sc10">[</span><span class="sc11">dcode</span><span class="sc10">]);</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc11">out_length</span><span class="sc0"> </span><span class="sc10">&gt;&gt;=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">Tracev</span><span class="sc10">((</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc6">"\nlast_lit %u, in %ld, out ~%ld(%ld%%) "</span><span class="sc10">,</span><span class="sc0">
               </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_lit</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">in_length</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">out_length</span><span class="sc10">,</span><span class="sc0">
               </span><span class="sc4">100L</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">out_length</span><span class="sc10">*</span><span class="sc4">100L</span><span class="sc10">/</span><span class="sc11">in_length</span><span class="sc10">));</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">matches</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_lit</span><span class="sc10">/</span><span class="sc4">2</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">out_length</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">in_length</span><span class="sc10">/</span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_lit</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lit_bufsize</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc1">/* We avoid equality with lit_bufsize because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">compress_block</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ltree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">dtree</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">ltree</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* literal tree */</span><span class="sc0">
    </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">dtree</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* distance tree */</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">dist</span><span class="sc10">;</span><span class="sc0">      </span><span class="sc1">/* distance of matched string */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">lc</span><span class="sc10">;</span><span class="sc0">             </span><span class="sc1">/* match length or unmatched char (if dist == 0) */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">lx</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc1">/* running index in l_buf */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc10">;</span><span class="sc0">      </span><span class="sc1">/* the code to send */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">extra</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* number of extra bits to send */</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_lit</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">dist</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">d_buf</span><span class="sc10">[</span><span class="sc11">lx</span><span class="sc10">];</span><span class="sc0">
        </span><span class="sc11">lc</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">l_buf</span><span class="sc10">[</span><span class="sc11">lx</span><span class="sc10">++];</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">dist</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">lc</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ltree</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc1">/* send a literal byte */</span><span class="sc0">
            </span><span class="sc11">Tracecv</span><span class="sc10">(</span><span class="sc11">isgraph</span><span class="sc10">(</span><span class="sc11">lc</span><span class="sc10">),</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc6">" '%c' "</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">lc</span><span class="sc10">));</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc1">/* Here, lc is the match length - MIN_MATCH */</span><span class="sc0">
            </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">_length_code</span><span class="sc10">[</span><span class="sc11">lc</span><span class="sc10">];</span><span class="sc0">
            </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc10">+</span><span class="sc11">LITERALS</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ltree</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc1">/* send the length code */</span><span class="sc0">
            </span><span class="sc11">extra</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">extra_lbits</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">];</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">extra</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">lc</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc11">base_length</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">];</span><span class="sc0">
                </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">lc</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">extra</span><span class="sc10">);</span><span class="sc0">       </span><span class="sc1">/* send the extra length bits */</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc11">dist</span><span class="sc10">--;</span><span class="sc0"> </span><span class="sc1">/* dist is now the match distance - 1 */</span><span class="sc0">
            </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">d_code</span><span class="sc10">(</span><span class="sc11">dist</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc11">Assert</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">D_CODES</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"bad d_code"</span><span class="sc10">);</span><span class="sc0">

            </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">dtree</span><span class="sc10">);</span><span class="sc0">       </span><span class="sc1">/* send the distance code */</span><span class="sc0">
            </span><span class="sc11">extra</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">extra_dbits</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">];</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">extra</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">dist</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc11">base_dist</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">];</span><span class="sc0">
                </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">dist</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">extra</span><span class="sc10">);</span><span class="sc0">   </span><span class="sc1">/* send the extra distance bits */</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc1">/* literal or match pair ? */</span><span class="sc0">

        </span><span class="sc1">/* Check that the overlay between pending_buf and d_buf+l_buf is ok: */</span><span class="sc0">
        </span><span class="sc11">Assert</span><span class="sc10">((</span><span class="sc11">uInt</span><span class="sc10">)(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">pending</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">lit_bufsize</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">*</span><span class="sc11">lx</span><span class="sc10">,</span><span class="sc0">
               </span><span class="sc6">"pendingBuf overflow"</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">lx</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_lit</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">END_BLOCK</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ltree</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_eob_len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">ltree</span><span class="sc10">[</span><span class="sc11">END_BLOCK</span><span class="sc10">].</span><span class="sc11">Len</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Set the data type to BINARY or TEXT, using a crude approximation:
 * set it to Z_TEXT if all symbols are either printable characters (33 to 255)
 * or white spaces (9 to 13, or 32); or set it to Z_BINARY otherwise.
 * IN assertion: the fields Freq of dyn_ltree are set.
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">set_data_type</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">9</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">dyn_ltree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0">
            </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">9</span><span class="sc10">)</span><span class="sc0">
        </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">14</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">32</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">dyn_ltree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">Freq</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0">
                </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">strm</span><span class="sc10">-&gt;</span><span class="sc11">data_type</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">32</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc11">Z_TEXT</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">Z_BINARY</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 &lt;= len &lt;= 15
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">bi_reverse</span><span class="sc10">(</span><span class="sc11">code</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* the value to invert */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc1">/* its bit length */</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">res</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">res</span><span class="sc0"> </span><span class="sc10">|=</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">&gt;&gt;=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">res</span><span class="sc0"> </span><span class="sc10">&lt;&lt;=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(--</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">res</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">bi_flush</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">16</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">put_short</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_buf</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_buf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">)</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_buf</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_buf</span><span class="sc0"> </span><span class="sc10">&gt;&gt;=</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">bi_windup</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">put_short</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_buf</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Byte</span><span class="sc10">)</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_buf</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_buf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#ifdef DEBUG
</span><span class="sc0">    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bits_sent</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bits_sent</span><span class="sc10">+</span><span class="sc4">7</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc10">~</span><span class="sc4">7</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */</span><span class="sc0">
</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">copy_block</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">header</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">charf</span><span class="sc0">    </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc1">/* the input data */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">     </span><span class="sc1">/* its length */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0">      </span><span class="sc11">header</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* true if block header must be written */</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">bi_windup</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">);</span><span class="sc0">        </span><span class="sc1">/* align on byte boundary */</span><span class="sc0">
    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">last_eob_len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* enough lookahead for inflate */</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">header</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">put_short</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">put_short</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)~</span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc9">#ifdef DEBUG
</span><span class="sc0">        </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bits_sent</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">*</span><span class="sc4">16</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#ifdef DEBUG
</span><span class="sc0">    </span><span class="sc11">s</span><span class="sc10">-&gt;</span><span class="sc11">bits_sent</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">len</span><span class="sc10">&lt;&lt;</span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">len</span><span class="sc10">--)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">put_byte</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">++);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">
</span></div></body>
</html>
