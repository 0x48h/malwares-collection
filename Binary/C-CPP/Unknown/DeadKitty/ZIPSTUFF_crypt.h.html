<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Exported from Notepad++</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc1 {
	color: #008000;
}
.sc3 {
	color: #008080;
}
.sc4 {
	color: #FF8000;
}
.sc5 {
	font-weight: bold;
	color: #0000FF;
}
.sc7 {
	color: #808080;
}
.sc9 {
	color: #804000;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc11 {
}
.sc16 {
	color: #8000FF;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc1">/* crypt.h -- base code for crypt/uncrypt ZIPfile


   Version 1.01e, February 12th, 2005

   Copyright (C) 1998-2005 Gilles Vollant

   This code is a modified version of crypting code in Infozip distribution

   The encryption/decryption parts of this source code (as opposed to the
   non-echoing password parts) were originally written in Europe.  The
   whole source package can be freely distributed, including from the USA.
   (Prior to January 2000, re-export from the US was a violation of US law.)

   This encryption code is a direct transcription of the algorithm from
   Roger Schlafly, described by Phil Katz in the file appnote.txt.  This
   file (appnote.txt) is distributed with the PKZIP program (even in the
   version without encryption capabilities).

   If you don't need crypting in your application, just define symbols
   NOCRYPT and NOUNCRYPT.

   This code support the "Traditional PKWARE Encryption".

   The new AES encryption added on Zip format by Winzip (see the page
   http://www.winzip.com/aes_info.htm ) and PKWare PKZip 5.x Strong
   Encryption is not supported.
*/</span><span class="sc0">

</span><span class="sc9">#define CRC32(c, b) ((*(pcrc_32_tab+(((int)(c) ^ (b)) &amp; 0xff))) ^ ((c) &gt;&gt; 8))
</span><span class="sc0">
</span><span class="sc3">/***********************************************************************
 * Return the next byte in the pseudo-random sequence
 */</span><span class="sc0">
</span><span class="sc16">static</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">decrypt_byte</span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">pkeys</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">pcrc_32_tab</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">temp</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* POTENTIAL BUG:  temp*(temp^1) may overflow in an
                     * unpredictable manner on 16-bit systems; not a problem
                     * with any known compiler so far, though */</span><span class="sc0">

    </span><span class="sc11">temp</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc16">unsigned</span><span class="sc10">)(*(</span><span class="sc11">pkeys</span><span class="sc10">+</span><span class="sc4">2</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xffff</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">|</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">int</span><span class="sc10">)(((</span><span class="sc11">temp</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">temp</span><span class="sc0"> </span><span class="sc10">^</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc3">/***********************************************************************
 * Update the encryption keys with the next byte of plain text
 */</span><span class="sc0">
</span><span class="sc16">static</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">update_keys</span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">pkeys</span><span class="sc10">,</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">pcrc_32_tab</span><span class="sc10">,</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">c</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc10">(*(</span><span class="sc11">pkeys</span><span class="sc10">+</span><span class="sc4">0</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">CRC32</span><span class="sc10">((*(</span><span class="sc11">pkeys</span><span class="sc10">+</span><span class="sc4">0</span><span class="sc10">)),</span><span class="sc0"> </span><span class="sc11">c</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">(*(</span><span class="sc11">pkeys</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc10">(*(</span><span class="sc11">pkeys</span><span class="sc10">+</span><span class="sc4">0</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">(*(</span><span class="sc11">pkeys</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(*(</span><span class="sc11">pkeys</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc0"> </span><span class="sc4">134775813L</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">{</span><span class="sc0">
      </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">keyshift</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">int</span><span class="sc10">)((*(</span><span class="sc11">pkeys</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">24</span><span class="sc10">);</span><span class="sc0">
      </span><span class="sc10">(*(</span><span class="sc11">pkeys</span><span class="sc10">+</span><span class="sc4">2</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">CRC32</span><span class="sc10">((*(</span><span class="sc11">pkeys</span><span class="sc10">+</span><span class="sc4">2</span><span class="sc10">)),</span><span class="sc0"> </span><span class="sc11">keyshift</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">c</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">


</span><span class="sc3">/***********************************************************************
 * Initialize the encryption keys and the random header according to
 * the given password.
 */</span><span class="sc0">
</span><span class="sc16">static</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">init_keys</span><span class="sc10">(</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">passwd</span><span class="sc10">,</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">pkeys</span><span class="sc10">,</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">pcrc_32_tab</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc10">*(</span><span class="sc11">pkeys</span><span class="sc10">+</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">305419896L</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">*(</span><span class="sc11">pkeys</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">591751049L</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">*(</span><span class="sc11">pkeys</span><span class="sc10">+</span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">878082192L</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(*</span><span class="sc11">passwd</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc7">'\0'</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">update_keys</span><span class="sc10">(</span><span class="sc11">pkeys</span><span class="sc10">,</span><span class="sc11">pcrc_32_tab</span><span class="sc10">,(</span><span class="sc16">int</span><span class="sc10">)*</span><span class="sc11">passwd</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">passwd</span><span class="sc10">++;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc9">#define zdecode(pkeys,pcrc_32_tab,c) \
    (update_keys(pkeys,pcrc_32_tab,c ^= decrypt_byte(pkeys,pcrc_32_tab)))
</span><span class="sc0">
</span><span class="sc9">#define zencode(pkeys,pcrc_32_tab,c,t) \
    (t=decrypt_byte(pkeys,pcrc_32_tab), update_keys(pkeys,pcrc_32_tab,c), t^(c))
</span><span class="sc0">
</span><span class="sc9">#ifdef INCLUDECRYPTINGCODE_IFCRYPTALLOWED
</span><span class="sc0">
</span><span class="sc9">#define RAND_HEAD_LEN  12
</span><span class="sc0">   </span><span class="sc1">/* "last resort" source for second part of crypt seed pattern */</span><span class="sc0">
</span><span class="sc9">#  ifndef ZCR_SEED2
#    define ZCR_SEED2 3141592654UL     </span><span class="sc1">/* use PI as default pattern */</span><span class="sc0">
</span><span class="sc9">#  endif
</span><span class="sc0">
</span><span class="sc16">static</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">crypthead</span><span class="sc10">(</span><span class="sc11">passwd</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">bufSize</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">pkeys</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">pcrc_32_tab</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">crcForCrypting</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">passwd</span><span class="sc10">;</span><span class="sc0">         </span><span class="sc1">/* password string */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">;</span><span class="sc0">         </span><span class="sc1">/* where to write header */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">bufSize</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">pkeys</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">pcrc_32_tab</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc0"> </span><span class="sc11">crcForCrypting</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0">                       </span><span class="sc1">/* index in random header */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">t</span><span class="sc10">;</span><span class="sc0">                       </span><span class="sc1">/* temporary */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">c</span><span class="sc10">;</span><span class="sc0">                       </span><span class="sc1">/* random byte */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc11">header</span><span class="sc10">[</span><span class="sc11">RAND_HEAD_LEN</span><span class="sc10">-</span><span class="sc4">2</span><span class="sc10">];</span><span class="sc0"> </span><span class="sc1">/* random header */</span><span class="sc0">
    </span><span class="sc16">static</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">calls</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc1">/* ensure different random header each time */</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bufSize</span><span class="sc10">&lt;</span><span class="sc11">RAND_HEAD_LEN</span><span class="sc10">)</span><span class="sc0">
      </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* First generate RAND_HEAD_LEN-2 random bytes. We encrypt the
     * output of rand() to get less predictability, since rand() is
     * often poorly implemented.
     */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(++</span><span class="sc11">calls</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">srand</span><span class="sc10">((</span><span class="sc16">unsigned</span><span class="sc10">)(</span><span class="sc11">time</span><span class="sc10">(</span><span class="sc5">NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">^</span><span class="sc0"> </span><span class="sc11">ZCR_SEED2</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">init_keys</span><span class="sc10">(</span><span class="sc11">passwd</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">pkeys</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">pcrc_32_tab</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">RAND_HEAD_LEN</span><span class="sc10">-</span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0">
    </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">c</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">rand</span><span class="sc10">()</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">header</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc10">)</span><span class="sc11">zencode</span><span class="sc10">(</span><span class="sc11">pkeys</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">pcrc_32_tab</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">c</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">t</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc1">/* Encrypt random header (last two bytes is high word of crc) */</span><span class="sc0">
    </span><span class="sc11">init_keys</span><span class="sc10">(</span><span class="sc11">passwd</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">pkeys</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">pcrc_32_tab</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">RAND_HEAD_LEN</span><span class="sc10">-</span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0">
    </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">buf</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc10">)</span><span class="sc11">zencode</span><span class="sc10">(</span><span class="sc11">pkeys</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">pcrc_32_tab</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">header</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">],</span><span class="sc0"> </span><span class="sc11">t</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">buf</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">++]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">zencode</span><span class="sc10">(</span><span class="sc11">pkeys</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">pcrc_32_tab</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">int</span><span class="sc10">)(</span><span class="sc11">crcForCrypting</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">16</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">t</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">buf</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">++]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">zencode</span><span class="sc10">(</span><span class="sc11">pkeys</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">pcrc_32_tab</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">int</span><span class="sc10">)(</span><span class="sc11">crcForCrypting</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">24</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xff</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">t</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc9">#endif
</span></div></body>
</html>
