<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Exported from Notepad++</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc1 {
	color: #008000;
}
.sc4 {
	color: #FF8000;
}
.sc5 {
	font-weight: bold;
	color: #0000FF;
}
.sc9 {
	color: #804000;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc11 {
}
.sc16 {
	color: #8000FF;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc1">/* deflate.h -- internal compression state
 * Copyright (C) 1995-2004 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h
 */</span><span class="sc0">

</span><span class="sc1">/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */</span><span class="sc0">

</span><span class="sc1">/* @(#) $Id$ */</span><span class="sc0">

</span><span class="sc9">#ifndef DEFLATE_H
#define DEFLATE_H
</span><span class="sc0">
</span><span class="sc9">#include "zutil.h"
</span><span class="sc0">
</span><span class="sc1">/* define NO_GZIP when compiling if you want to disable gzip header and
   trailer creation by deflate().  NO_GZIP would be used to avoid linking in
   the crc code when it is not needed.  For shared libraries, gzip encoding
   should be left enabled. */</span><span class="sc0">
</span><span class="sc9">#ifndef NO_GZIP
#  define GZIP
#endif
</span><span class="sc0">
</span><span class="sc1">/* ===========================================================================
 * Internal compression state.
 */</span><span class="sc0">

</span><span class="sc9">#define LENGTH_CODES 29
</span><span class="sc1">/* number of length codes, not counting the special END_BLOCK code */</span><span class="sc0">

</span><span class="sc9">#define LITERALS  256
</span><span class="sc1">/* number of literal bytes 0..255 */</span><span class="sc0">

</span><span class="sc9">#define L_CODES (LITERALS+1+LENGTH_CODES)
</span><span class="sc1">/* number of Literal or Length codes, including the END_BLOCK code */</span><span class="sc0">

</span><span class="sc9">#define D_CODES   30
</span><span class="sc1">/* number of distance codes */</span><span class="sc0">

</span><span class="sc9">#define BL_CODES  19
</span><span class="sc1">/* number of codes used to transfer the bit lengths */</span><span class="sc0">

</span><span class="sc9">#define HEAP_SIZE (2*L_CODES+1)
</span><span class="sc1">/* maximum heap size */</span><span class="sc0">

</span><span class="sc9">#define MAX_BITS 15
</span><span class="sc1">/* All codes must not exceed MAX_BITS bits */</span><span class="sc0">

</span><span class="sc9">#define INIT_STATE    42
#define EXTRA_STATE   69
#define NAME_STATE    73
#define COMMENT_STATE 91
#define HCRC_STATE   103
#define BUSY_STATE   113
#define FINISH_STATE 666
</span><span class="sc1">/* Stream status */</span><span class="sc0">


</span><span class="sc1">/* Data structure describing a single value and its code string. */</span><span class="sc0">
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">ct_data_s</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">union</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">ush</span><span class="sc0">  </span><span class="sc11">freq</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc1">/* frequency count */</span><span class="sc0">
        </span><span class="sc11">ush</span><span class="sc0">  </span><span class="sc11">code</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc1">/* bit string */</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">fc</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">union</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">ush</span><span class="sc0">  </span><span class="sc11">dad</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc1">/* father node in Huffman tree */</span><span class="sc0">
        </span><span class="sc11">ush</span><span class="sc0">  </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc1">/* length of bit string */</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">dl</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">FAR</span><span class="sc0"> </span><span class="sc11">ct_data</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc9">#define Freq fc.freq
#define Code fc.code
#define Dad  dl.dad
#define Len  dl.len
</span><span class="sc0">
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">static_tree_desc_s</span><span class="sc0">  </span><span class="sc11">static_tree_desc</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">tree_desc_s</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">dyn_tree</span><span class="sc10">;</span><span class="sc0">           </span><span class="sc1">/* the dynamic tree */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0">     </span><span class="sc11">max_code</span><span class="sc10">;</span><span class="sc0">            </span><span class="sc1">/* largest code with non zero frequency */</span><span class="sc0">
    </span><span class="sc11">static_tree_desc</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">stat_desc</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* the corresponding static tree */</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">FAR</span><span class="sc0"> </span><span class="sc11">tree_desc</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">Pos</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc11">Pos</span><span class="sc0"> </span><span class="sc11">FAR</span><span class="sc0"> </span><span class="sc11">Posf</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">IPos</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc1">/* A Pos is an index in the character window. We use short instead of int to
 * save space in the various tables. IPos is used only for parameter passing.
 */</span><span class="sc0">

</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">internal_state</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">z_streamp</span><span class="sc0"> </span><span class="sc11">strm</span><span class="sc10">;</span><span class="sc0">      </span><span class="sc1">/* pointer back to this zlib stream */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0">   </span><span class="sc11">status</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc1">/* as the name implies */</span><span class="sc0">
    </span><span class="sc11">Bytef</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">pending_buf</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* output still pending */</span><span class="sc0">
    </span><span class="sc11">ulg</span><span class="sc0">   </span><span class="sc11">pending_buf_size</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* size of pending_buf */</span><span class="sc0">
    </span><span class="sc11">Bytef</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">pending_out</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* next pending byte to output to the stream */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0">   </span><span class="sc11">pending</span><span class="sc10">;</span><span class="sc0">      </span><span class="sc1">/* nb of bytes in the pending buffer */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0">   </span><span class="sc11">wrap</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* bit 0 true for zlib, bit 1 true for gzip */</span><span class="sc0">
    </span><span class="sc11">gz_headerp</span><span class="sc0">  </span><span class="sc11">gzhead</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* gzip header information to write */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0">   </span><span class="sc11">gzindex</span><span class="sc10">;</span><span class="sc0">      </span><span class="sc1">/* where in extra, name, or comment */</span><span class="sc0">
    </span><span class="sc11">Byte</span><span class="sc0">  </span><span class="sc11">method</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc1">/* STORED (for zip only) or DEFLATED */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0">   </span><span class="sc11">last_flush</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc1">/* value of flush param for previous deflate call */</span><span class="sc0">

                </span><span class="sc1">/* used by deflate.c: */</span><span class="sc0">

    </span><span class="sc11">uInt</span><span class="sc0">  </span><span class="sc11">w_size</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc1">/* LZ77 window size (32K by default) */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0">  </span><span class="sc11">w_bits</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc1">/* log2(w_size)  (8..16) */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0">  </span><span class="sc11">w_mask</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc1">/* w_size - 1 */</span><span class="sc0">

    </span><span class="sc11">Bytef</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">window</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc1">/* Sliding window. Input bytes are read into the second half of the window,
     * and move to the first half later to keep a dictionary of at least wSize
     * bytes. With this organization, matches are limited to a distance of
     * wSize-MAX_MATCH bytes, but this ensures that IO is always
     * performed with a length multiple of the block size. Also, it limits
     * the window size to 64K, which is quite useful on MSDOS.
     * To do: use the user input buffer as sliding window.
     */</span><span class="sc0">

    </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">window_size</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc1">/* Actual size of window: 2*wSize, except when the user input buffer
     * is directly used as sliding window.
     */</span><span class="sc0">

    </span><span class="sc11">Posf</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">prev</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc1">/* Link to older string with same hash index. To limit the size of this
     * array to 64K, this link is maintained only for the last 32K strings.
     * An index in this array is thus a window index modulo 32K.
     */</span><span class="sc0">

    </span><span class="sc11">Posf</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">head</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* Heads of the hash chains or NIL. */</span><span class="sc0">

    </span><span class="sc11">uInt</span><span class="sc0">  </span><span class="sc11">ins_h</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* hash index of string to be inserted */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0">  </span><span class="sc11">hash_size</span><span class="sc10">;</span><span class="sc0">      </span><span class="sc1">/* number of elements in hash table */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0">  </span><span class="sc11">hash_bits</span><span class="sc10">;</span><span class="sc0">      </span><span class="sc1">/* log2(hash_size) */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0">  </span><span class="sc11">hash_mask</span><span class="sc10">;</span><span class="sc0">      </span><span class="sc1">/* hash_size-1 */</span><span class="sc0">

    </span><span class="sc11">uInt</span><span class="sc0">  </span><span class="sc11">hash_shift</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc1">/* Number of bits by which ins_h must be shifted at each input
     * step. It must be such that after MIN_MATCH steps, the oldest
     * byte no longer takes part in the hash key, that is:
     *   hash_shift * MIN_MATCH &gt;= hash_bits
     */</span><span class="sc0">

    </span><span class="sc16">long</span><span class="sc0"> </span><span class="sc11">block_start</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc1">/* Window position at the beginning of the current output block. Gets
     * negative when the window is moved backwards.
     */</span><span class="sc0">

    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">match_length</span><span class="sc10">;</span><span class="sc0">           </span><span class="sc1">/* length of best match */</span><span class="sc0">
    </span><span class="sc11">IPos</span><span class="sc0"> </span><span class="sc11">prev_match</span><span class="sc10">;</span><span class="sc0">             </span><span class="sc1">/* previous match */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">match_available</span><span class="sc10">;</span><span class="sc0">         </span><span class="sc1">/* set if previous match exists */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">strstart</span><span class="sc10">;</span><span class="sc0">               </span><span class="sc1">/* start of string to insert */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">match_start</span><span class="sc10">;</span><span class="sc0">            </span><span class="sc1">/* start of matching string */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">lookahead</span><span class="sc10">;</span><span class="sc0">              </span><span class="sc1">/* number of valid bytes ahead in window */</span><span class="sc0">

    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">prev_length</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc1">/* Length of the best match at previous step. Matches not greater than this
     * are discarded. This is used in the lazy match evaluation.
     */</span><span class="sc0">

    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">max_chain_length</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc1">/* To speed up deflation, hash chains are never searched beyond this
     * length.  A higher limit improves compression ratio but degrades the
     * speed.
     */</span><span class="sc0">

    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">max_lazy_match</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc1">/* Attempt to find a better match only when the current match is strictly
     * smaller than this value. This mechanism is used only for compression
     * levels &gt;= 4.
     */</span><span class="sc0">
</span><span class="sc9">#   define max_insert_length  max_lazy_match
</span><span class="sc0">    </span><span class="sc1">/* Insert new strings in the hash table only if the match length is not
     * greater than this length. This saves time but degrades compression.
     * max_insert_length is used only for compression levels &lt;= 3.
     */</span><span class="sc0">

    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc1">/* compression level (1..9) */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">strategy</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* favor or force Huffman coding*/</span><span class="sc0">

    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">good_match</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc1">/* Use a faster search when the previous match is longer than this */</span><span class="sc0">

    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">nice_match</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* Stop searching when current match exceeds this */</span><span class="sc0">

                </span><span class="sc1">/* used by trees.c: */</span><span class="sc0">
    </span><span class="sc1">/* Didn't use ct_data typedef below to supress compiler warning */</span><span class="sc0">
    </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">ct_data_s</span><span class="sc0"> </span><span class="sc11">dyn_ltree</span><span class="sc10">[</span><span class="sc11">HEAP_SIZE</span><span class="sc10">];</span><span class="sc0">   </span><span class="sc1">/* literal and length tree */</span><span class="sc0">
    </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">ct_data_s</span><span class="sc0"> </span><span class="sc11">dyn_dtree</span><span class="sc10">[</span><span class="sc4">2</span><span class="sc10">*</span><span class="sc11">D_CODES</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">];</span><span class="sc0"> </span><span class="sc1">/* distance tree */</span><span class="sc0">
    </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">ct_data_s</span><span class="sc0"> </span><span class="sc11">bl_tree</span><span class="sc10">[</span><span class="sc4">2</span><span class="sc10">*</span><span class="sc11">BL_CODES</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">];</span><span class="sc0">  </span><span class="sc1">/* Huffman tree for bit lengths */</span><span class="sc0">

    </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">tree_desc_s</span><span class="sc0"> </span><span class="sc11">l_desc</span><span class="sc10">;</span><span class="sc0">               </span><span class="sc1">/* desc. for literal tree */</span><span class="sc0">
    </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">tree_desc_s</span><span class="sc0"> </span><span class="sc11">d_desc</span><span class="sc10">;</span><span class="sc0">               </span><span class="sc1">/* desc. for distance tree */</span><span class="sc0">
    </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">tree_desc_s</span><span class="sc0"> </span><span class="sc11">bl_desc</span><span class="sc10">;</span><span class="sc0">              </span><span class="sc1">/* desc. for bit length tree */</span><span class="sc0">

    </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">MAX_BITS</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">];</span><span class="sc0">
    </span><span class="sc1">/* number of codes at each bit length for an optimal tree */</span><span class="sc0">

    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc4">2</span><span class="sc10">*</span><span class="sc11">L_CODES</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">];</span><span class="sc0">      </span><span class="sc1">/* heap used to build the Huffman trees */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">heap_len</span><span class="sc10">;</span><span class="sc0">               </span><span class="sc1">/* number of elements in the heap */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">heap_max</span><span class="sc10">;</span><span class="sc0">               </span><span class="sc1">/* element of largest frequency */</span><span class="sc0">
    </span><span class="sc1">/* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
     * The same heap array is used to build all trees.
     */</span><span class="sc0">

    </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">depth</span><span class="sc10">[</span><span class="sc4">2</span><span class="sc10">*</span><span class="sc11">L_CODES</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">];</span><span class="sc0">
    </span><span class="sc1">/* Depth of each subtree used as tie breaker for trees of equal frequency
     */</span><span class="sc0">

    </span><span class="sc11">uchf</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">l_buf</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* buffer for literals or lengths */</span><span class="sc0">

    </span><span class="sc11">uInt</span><span class="sc0">  </span><span class="sc11">lit_bufsize</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc1">/* Size of match buffer for literals/lengths.  There are 4 reasons for
     * limiting lit_bufsize to 64K:
     *   - frequencies can be kept in 16 bit counters
     *   - if compression is not successful for the first block, all input
     *     data is still in the window so we can still emit a stored block even
     *     when input comes from standard input.  (This can also be done for
     *     all blocks if lit_bufsize is not greater than 32K.)
     *   - if compression is not successful for a file smaller than 64K, we can
     *     even emit a stored file instead of a stored block (saving 5 bytes).
     *     This is applicable only for zip (not gzip or zlib).
     *   - creating new Huffman trees less frequently may not provide fast
     *     adaptation to changes in the input data statistics. (Take for
     *     example a binary file with poorly compressible code followed by
     *     a highly compressible string table.) Smaller buffer sizes give
     *     fast adaptation but have of course the overhead of transmitting
     *     trees more frequently.
     *   - I can't count above 4
     */</span><span class="sc0">

    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">last_lit</span><span class="sc10">;</span><span class="sc0">      </span><span class="sc1">/* running index in l_buf */</span><span class="sc0">

    </span><span class="sc11">ushf</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">d_buf</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc1">/* Buffer for distances. To simplify the code, d_buf and l_buf have
     * the same number of elements. To use different lengths, an extra flag
     * array would be necessary.
     */</span><span class="sc0">

    </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">opt_len</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc1">/* bit length of current block with optimal trees */</span><span class="sc0">
    </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">static_len</span><span class="sc10">;</span><span class="sc0">     </span><span class="sc1">/* bit length of current block with static trees */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">matches</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc1">/* number of string matches in current block */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">last_eob_len</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc1">/* bit length of EOB code for last block */</span><span class="sc0">

</span><span class="sc9">#ifdef DEBUG
</span><span class="sc0">    </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">compressed_len</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* total bit length of compressed file mod 2^32 */</span><span class="sc0">
    </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">bits_sent</span><span class="sc10">;</span><span class="sc0">      </span><span class="sc1">/* bit length of compressed data sent mod 2^32 */</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
    </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">bi_buf</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc1">/* Output buffer. bits are inserted starting at the bottom (least
     * significant bits).
     */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">bi_valid</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc1">/* Number of valid bits in bi_buf.  All bits above the last valid bit
     * are always zero.
     */</span><span class="sc0">

</span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">FAR</span><span class="sc0"> </span><span class="sc11">deflate_state</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc1">/* Output a byte on the stream.
 * IN assertion: there is enough room in pending_buf.
 */</span><span class="sc0">
</span><span class="sc9">#define put_byte(s, c) {s-&gt;pending_buf[s-&gt;pending++] = (c);}
</span><span class="sc0">

</span><span class="sc9">#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
</span><span class="sc1">/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */</span><span class="sc0">

</span><span class="sc9">#define MAX_DIST(s)  ((s)-&gt;w_size-MIN_LOOKAHEAD)
</span><span class="sc1">/* In order to simplify the code, particularly on 16 bit machines, match
 * distances are limited to MAX_DIST instead of WSIZE.
 */</span><span class="sc0">

        </span><span class="sc1">/* in trees.c */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">_tr_init</span><span class="sc0">         </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc16">int</span><span class="sc0">  </span><span class="sc11">_tr_tally</span><span class="sc0">        </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">dist</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">lc</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">_tr_flush_block</span><span class="sc0">  </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">charf</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">stored_len</span><span class="sc10">,</span><span class="sc0">
                          </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">eof</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">_tr_align</span><span class="sc0">        </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">_tr_stored_block</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">deflate_state</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">charf</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">stored_len</span><span class="sc10">,</span><span class="sc0">
                          </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">eof</span><span class="sc10">));</span><span class="sc0">

</span><span class="sc9">#define d_code(dist) \
   ((dist) &lt; 256 ? _dist_code[dist] : _dist_code[256+((dist)&gt;&gt;7)])
</span><span class="sc1">/* Mapping from a distance to a distance code. dist is the distance - 1 and
 * must not have side effects. _dist_code[256] and _dist_code[257] are never
 * used.
 */</span><span class="sc0">

</span><span class="sc9">#ifndef DEBUG
</span><span class="sc1">/* Inline versions of _tr_tally for speed: */</span><span class="sc0">

</span><span class="sc9">#if defined(GEN_TREES_H) || !defined(STDC)
</span><span class="sc0">  </span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">_length_code</span><span class="sc10">[];</span><span class="sc0">
  </span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">_dist_code</span><span class="sc10">[];</span><span class="sc0">
</span><span class="sc9">#else
</span><span class="sc0">  </span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">_length_code</span><span class="sc10">[];</span><span class="sc0">
  </span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">_dist_code</span><span class="sc10">[];</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
</span><span class="sc9"># define _tr_tally_lit(s, c, flush) \
  { uch cc = (c); \
    s-&gt;d_buf[s-&gt;last_lit] = 0; \
    s-&gt;l_buf[s-&gt;last_lit++] = cc; \
    s-&gt;dyn_ltree[cc].Freq++; \
    flush = (s-&gt;last_lit == s-&gt;lit_bufsize-1); \
   }
# define _tr_tally_dist(s, distance, length, flush) \
  { uch len = (length); \
    ush dist = (distance); \
    s-&gt;d_buf[s-&gt;last_lit] = dist; \
    s-&gt;l_buf[s-&gt;last_lit++] = len; \
    dist--; \
    s-&gt;dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
    s-&gt;dyn_dtree[d_code(dist)].Freq++; \
    flush = (s-&gt;last_lit == s-&gt;lit_bufsize-1); \
  }
#else
# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
# define _tr_tally_dist(s, distance, length, flush) \
              flush = _tr_tally(s, distance, length)
#endif
</span><span class="sc0">
</span><span class="sc9">#endif </span><span class="sc1">/* DEFLATE_H */</span><span class="sc0">
</span></div></body>
</html>
