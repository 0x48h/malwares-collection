<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Exported from Notepad++</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc1 {
	color: #008000;
}
.sc4 {
	color: #FF8000;
}
.sc5 {
	font-weight: bold;
	color: #0000FF;
}
.sc9 {
	color: #804000;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc11 {
}
.sc16 {
	color: #8000FF;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc1">/* zutil.h -- internal interface and configuration of the compression library
 * Copyright (C) 1995-2005 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */</span><span class="sc0">

</span><span class="sc1">/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */</span><span class="sc0">

</span><span class="sc1">/* @(#) $Id$ */</span><span class="sc0">

</span><span class="sc9">#ifndef ZUTIL_H
#define ZUTIL_H
</span><span class="sc0">
</span><span class="sc9">#define ZLIB_INTERNAL
#include "zlib.h"
</span><span class="sc0">
</span><span class="sc9">#ifdef STDC
#  ifndef _WIN32_WCE
#    include &lt;stddef.h&gt;
#  endif
#  include &lt;string.h&gt;
#  include &lt;stdlib.h&gt;
#endif
#ifdef NO_ERRNO_H
#   ifdef _WIN32_WCE
</span><span class="sc0">      </span><span class="sc1">/* The Microsoft C Run-Time Library for Windows CE doesn't have
       * errno.  We define it as a global variable to simplify porting.
       * Its value is always 0 and should not be used.  We rename it to
       * avoid conflict with other libraries that use the same workaround.
       */</span><span class="sc0">
</span><span class="sc9">#     define errno z_errno
#   endif
</span><span class="sc0">    </span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">errno</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#else
#  ifndef _WIN32_WCE
#    include &lt;errno.h&gt;
#  endif
#endif
</span><span class="sc0">
</span><span class="sc9">#ifndef local
#  define local static
#endif
</span><span class="sc1">/* compile with -Dlocal if your debugger can't find static symbols */</span><span class="sc0">

</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0">  </span><span class="sc11">uch</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">FAR</span><span class="sc0"> </span><span class="sc11">uchf</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">short</span><span class="sc0"> </span><span class="sc11">ush</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">FAR</span><span class="sc0"> </span><span class="sc11">ushf</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc0">  </span><span class="sc11">ulg</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">z_errmsg</span><span class="sc10">[</span><span class="sc4">10</span><span class="sc10">];</span><span class="sc0"> </span><span class="sc1">/* indexed by 2-zlib_error */</span><span class="sc0">
</span><span class="sc1">/* (size given to avoid silly warnings with Visual C++) */</span><span class="sc0">

</span><span class="sc9">#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
</span><span class="sc0">
</span><span class="sc9">#define ERR_RETURN(strm,err) \
  return (strm-&gt;msg = (char*)ERR_MSG(err), (err))
</span><span class="sc1">/* To be used only when the state is known to be valid */</span><span class="sc0">

        </span><span class="sc1">/* common constants */</span><span class="sc0">

</span><span class="sc9">#ifndef DEF_WBITS
#  define DEF_WBITS MAX_WBITS
#endif
</span><span class="sc1">/* default windowBits for decompression. MAX_WBITS is for compression only */</span><span class="sc0">

</span><span class="sc9">#if MAX_MEM_LEVEL &gt;= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif
</span><span class="sc1">/* default memLevel */</span><span class="sc0">

</span><span class="sc9">#define STORED_BLOCK 0
#define STATIC_TREES 1
#define DYN_TREES    2
</span><span class="sc1">/* The three kinds of block type */</span><span class="sc0">

</span><span class="sc9">#define MIN_MATCH  3
#define MAX_MATCH  258
</span><span class="sc1">/* The minimum and maximum match lengths */</span><span class="sc0">

</span><span class="sc9">#define PRESET_DICT 0x20 </span><span class="sc1">/* preset dictionary flag in zlib header */</span><span class="sc0">

        </span><span class="sc1">/* target dependencies */</span><span class="sc0">

</span><span class="sc9">#if defined(MSDOS) || (defined(WINDOWS) &amp;&amp; !defined(WIN32))
#  define OS_CODE  0x00
#  if defined(__TURBOC__) || defined(__BORLANDC__)
#    if(__STDC__ == 1) &amp;&amp; (defined(__LARGE__) || defined(__COMPACT__))
</span><span class="sc0">       </span><span class="sc1">/* Allow compilation with ANSI keywords only enabled */</span><span class="sc0">
       </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">_Cdecl</span><span class="sc0"> </span><span class="sc11">farfree</span><span class="sc10">(</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">block</span><span class="sc0"> </span><span class="sc10">);</span><span class="sc0">
       </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">_Cdecl</span><span class="sc0"> </span><span class="sc11">farmalloc</span><span class="sc10">(</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc0"> </span><span class="sc11">nbytes</span><span class="sc0"> </span><span class="sc10">);</span><span class="sc0">
</span><span class="sc9">#    else
#      include &lt;alloc.h&gt;
#    endif
#  else </span><span class="sc1">/* MSC or DJGPP */</span><span class="sc0">
</span><span class="sc9">#    include &lt;malloc.h&gt;
#  endif
#endif
</span><span class="sc0">
</span><span class="sc9">#ifdef AMIGA
#  define OS_CODE  0x01
#endif
</span><span class="sc0">
</span><span class="sc9">#if defined(VAXC) || defined(VMS)
#  define OS_CODE  0x02
#  define F_OPEN(name, mode) \
     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
#endif
</span><span class="sc0">
</span><span class="sc9">#if defined(ATARI) || defined(atarist)
#  define OS_CODE  0x05
#endif
</span><span class="sc0">
</span><span class="sc9">#ifdef OS2
#  define OS_CODE  0x06
#  ifdef M_I86
</span><span class="sc0">     </span><span class="sc9">#include &lt;malloc.h&gt;
#  endif
#endif
</span><span class="sc0">
</span><span class="sc9">#if defined(MACOS) || defined(TARGET_OS_MAC)
#  define OS_CODE  0x07
#  if defined(__MWERKS__) &amp;&amp; __dest_os != __be_os &amp;&amp; __dest_os != __win32_os
#    include &lt;unix.h&gt; </span><span class="sc1">/* for fdopen */</span><span class="sc0">
</span><span class="sc9">#  else
#    ifndef fdopen
#      define fdopen(fd,mode) NULL </span><span class="sc1">/* No fdopen() */</span><span class="sc0">
</span><span class="sc9">#    endif
#  endif
#endif
</span><span class="sc0">
</span><span class="sc9">#ifdef TOPS20
#  define OS_CODE  0x0a
#endif
</span><span class="sc0">
</span><span class="sc9">#ifdef WIN32
#  ifndef __CYGWIN__  </span><span class="sc1">/* Cygwin is Unix, not Win32 */</span><span class="sc0">
</span><span class="sc9">#    define OS_CODE  0x0b
#  endif
#endif
</span><span class="sc0">
</span><span class="sc9">#ifdef __50SERIES </span><span class="sc1">/* Prime/PRIMOS */</span><span class="sc0">
</span><span class="sc9">#  define OS_CODE  0x0f
#endif
</span><span class="sc0">
</span><span class="sc9">#if defined(_BEOS_) || defined(RISCOS)
#  define fdopen(fd,mode) NULL </span><span class="sc1">/* No fdopen() */</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
</span><span class="sc9">#if (defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt; 600))
#  if defined(_WIN32_WCE)
#    define fdopen(fd,mode) NULL </span><span class="sc1">/* No fdopen() */</span><span class="sc0">
</span><span class="sc9">#    ifndef _PTRDIFF_T_DEFINED
</span><span class="sc0">       </span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ptrdiff_t</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#      define _PTRDIFF_T_DEFINED
#    endif
#  else
#    define fdopen(fd,type)  _fdopen(fd,type)
#  endif
#endif
</span><span class="sc0">
        </span><span class="sc1">/* common defaults */</span><span class="sc0">

</span><span class="sc9">#ifndef OS_CODE
#  define OS_CODE  0x03  </span><span class="sc1">/* assume Unix */</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
</span><span class="sc9">#ifndef F_OPEN
#  define F_OPEN(name, mode) fopen((name), (mode))
#endif
</span><span class="sc0">
         </span><span class="sc1">/* functions */</span><span class="sc0">

</span><span class="sc9">#if defined(STDC99) || (defined(__TURBOC__) &amp;&amp; __TURBOC__ &gt;= 0x550)
#  ifndef HAVE_VSNPRINTF
#    define HAVE_VSNPRINTF
#  endif
#endif
#if defined(__CYGWIN__)
#  ifndef HAVE_VSNPRINTF
#    define HAVE_VSNPRINTF
#  endif
#endif
#ifndef HAVE_VSNPRINTF
#  ifdef MSDOS
</span><span class="sc0">     </span><span class="sc1">/* vsnprintf may exist on some MS-DOS compilers (DJGPP?),
        but for now we just assume it doesn't. */</span><span class="sc0">
</span><span class="sc9">#    define NO_vsnprintf
#  endif
#  ifdef __TURBOC__
#    define NO_vsnprintf
#  endif
#  ifdef WIN32
</span><span class="sc0">     </span><span class="sc1">/* In Win32, vsnprintf is available as the "non-ANSI" _vsnprintf. */</span><span class="sc0">
</span><span class="sc9">#    if !defined(vsnprintf) &amp;&amp; !defined(NO_vsnprintf)
#      define vsnprintf _vsnprintf
#    endif
#  endif
#  ifdef __SASC
#    define NO_vsnprintf
#  endif
#endif
#ifdef VMS
#  define NO_vsnprintf
#endif
</span><span class="sc0">
</span><span class="sc9">#if defined(pyr)
#  define NO_MEMCPY
#endif
#if defined(SMALL_MEDIUM) &amp;&amp; !defined(_MSC_VER) &amp;&amp; !defined(__SC__)
</span><span class="sc0"> </span><span class="sc1">/* Use our own functions for small and medium model with MSC &lt;= 5.0.
  * You may have to use the same strategy for Borland C (untested).
  * The __SC__ check is for Symantec.
  */</span><span class="sc0">
</span><span class="sc9">#  define NO_MEMCPY
#endif
#if defined(STDC) &amp;&amp; !defined(HAVE_MEMCPY) &amp;&amp; !defined(NO_MEMCPY)
#  define HAVE_MEMCPY
#endif
#ifdef HAVE_MEMCPY
#  ifdef SMALL_MEDIUM </span><span class="sc1">/* MSDOS small or medium model */</span><span class="sc0">
</span><span class="sc9">#    define zmemcpy _fmemcpy
#    define zmemcmp _fmemcmp
#    define zmemzero(dest, len) _fmemset(dest, 0, len)
#  else
#    define zmemcpy memcpy
#    define zmemcmp memcmp
#    define zmemzero(dest, len) memset(dest, 0, len)
#  endif
#else
</span><span class="sc0">   </span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">zmemcpy</span><span class="sc0">  </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">Bytef</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">dest</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">Bytef</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">source</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">));</span><span class="sc0">
   </span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0">  </span><span class="sc11">zmemcmp</span><span class="sc0">  </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">Bytef</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">s1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">Bytef</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">s2</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">));</span><span class="sc0">
   </span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">zmemzero</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">Bytef</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">dest</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
</span><span class="sc1">/* Diagnostic functions */</span><span class="sc0">
</span><span class="sc9">#ifdef DEBUG
#  include &lt;stdio.h&gt;
</span><span class="sc0">   </span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">z_verbose</span><span class="sc10">;</span><span class="sc0">
   </span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">z_error</span><span class="sc0">    </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">m</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc9">#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
#  define Trace(x) {if (z_verbose&gt;=0) fprintf x ;}
#  define Tracev(x) {if (z_verbose&gt;0) fprintf x ;}
#  define Tracevv(x) {if (z_verbose&gt;1) fprintf x ;}
#  define Tracec(c,x) {if (z_verbose&gt;0 &amp;&amp; (c)) fprintf x ;}
#  define Tracecv(c,x) {if (z_verbose&gt;1 &amp;&amp; (c)) fprintf x ;}
#else
#  define Assert(cond,msg)
#  define Trace(x)
#  define Tracev(x)
#  define Tracevv(x)
#  define Tracec(c,x)
#  define Tracecv(c,x)
#endif
</span><span class="sc0">

</span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">zcalloc</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">opaque</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">items</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0">   </span><span class="sc11">zcfree</span><span class="sc0">  </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">opaque</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">ptr</span><span class="sc10">));</span><span class="sc0">

</span><span class="sc9">#define ZALLOC(strm, items, size) \
           (*((strm)-&gt;zalloc))((strm)-&gt;opaque, (items), (size))
#define ZFREE(strm, addr)  (*((strm)-&gt;zfree))((strm)-&gt;opaque, (voidpf)(addr))
#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}
</span><span class="sc0">
</span><span class="sc9">#endif </span><span class="sc1">/* ZUTIL_H */</span><span class="sc0">
</span></div></body>
</html>
