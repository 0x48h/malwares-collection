<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Exported from Notepad++</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc1 {
	color: #008000;
}
.sc5 {
	font-weight: bold;
	color: #0000FF;
}
.sc6 {
	color: #808080;
}
.sc9 {
	color: #804000;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc11 {
}
.sc16 {
	color: #8000FF;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc1">/* zip.h -- IO for compress .zip files using zlib
   Version 1.01e, February 12th, 2005

   Copyright (C) 1998-2005 Gilles Vollant

   This unzip package allow creates .ZIP file, compatible with PKZip 2.04g
     WinZip, InfoZip tools and compatible.
   Multi volume ZipFile (span) are not supported.
   Encryption compatible with pkzip 2.04g only supported
   Old compressions used by old PKZip 1.x are not supported

  For uncompress .zip file, look at unzip.h


   I WAIT FEEDBACK at mail info@winimage.com
   Visit also http://www.winimage.com/zLibDll/unzip.html for evolution

   Condition of use and distribution are the same than zlib :

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.


*/</span><span class="sc0">

</span><span class="sc1">/* for more info about .ZIP format, see
      http://www.info-zip.org/pub/infozip/doc/appnote-981119-iz.zip
      http://www.info-zip.org/pub/infozip/doc/
   PkWare has also a specification at :
      ftp://ftp.pkware.com/probdesc.zip
*/</span><span class="sc0">

</span><span class="sc9">#ifndef _zip_H
#define _zip_H
</span><span class="sc0">
</span><span class="sc9">#ifdef __cplusplus
</span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc6">"C"</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
</span><span class="sc9">#ifndef _ZLIB_H
#include "zlib.h"
#endif
</span><span class="sc0">
</span><span class="sc9">#ifndef _ZLIBIOAPI_H
#include "ioapi.h"
#endif
</span><span class="sc0">
</span><span class="sc9">#if defined(STRICTZIP) || defined(STRICTZIPUNZIP)
</span><span class="sc1">/* like the STRICT of WIN32, we define a pointer that cannot be converted
    from (void*) without cast */</span><span class="sc0">
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">TagzipFile__</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">unused</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">zipFile__</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc11">zipFile__</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">zipFile</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#else
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc11">voidp</span><span class="sc0"> </span><span class="sc11">zipFile</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
</span><span class="sc9">#define ZIP_OK                          (0)
#define ZIP_EOF                         (0)
#define ZIP_ERRNO                       (Z_ERRNO)
#define ZIP_PARAMERROR                  (-102)
#define ZIP_BADZIPFILE                  (-103)
#define ZIP_INTERNALERROR               (-104)
</span><span class="sc0">
</span><span class="sc9">#ifndef DEF_MEM_LEVEL
#  if MAX_MEM_LEVEL &gt;= 8
#    define DEF_MEM_LEVEL 8
#  else
#    define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#  endif
#endif
</span><span class="sc1">/* default memLevel */</span><span class="sc0">

</span><span class="sc1">/* tm_zip contain date/time info */</span><span class="sc0">
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">tm_zip_s</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">tm_sec</span><span class="sc10">;</span><span class="sc0">            </span><span class="sc1">/* seconds after the minute - [0,59] */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">tm_min</span><span class="sc10">;</span><span class="sc0">            </span><span class="sc1">/* minutes after the hour - [0,59] */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">tm_hour</span><span class="sc10">;</span><span class="sc0">           </span><span class="sc1">/* hours since midnight - [0,23] */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">tm_mday</span><span class="sc10">;</span><span class="sc0">           </span><span class="sc1">/* day of the month - [1,31] */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">tm_mon</span><span class="sc10">;</span><span class="sc0">            </span><span class="sc1">/* months since January - [0,11] */</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">tm_year</span><span class="sc10">;</span><span class="sc0">           </span><span class="sc1">/* years - [1980..2044] */</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">tm_zip</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">struct</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">tm_zip</span><span class="sc0">      </span><span class="sc11">tmz_date</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc1">/* date in understandable format           */</span><span class="sc0">
    </span><span class="sc11">uLong</span><span class="sc0">       </span><span class="sc11">dosDate</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc1">/* if dos_date == 0, tmu_date is used      */</span><span class="sc0">
</span><span class="sc1">/*    uLong       flag;        */</span><span class="sc0">   </span><span class="sc1">/* general purpose bit flag        2 bytes */</span><span class="sc0">

    </span><span class="sc11">uLong</span><span class="sc0">       </span><span class="sc11">internal_fa</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc1">/* internal file attributes        2 bytes */</span><span class="sc0">
    </span><span class="sc11">uLong</span><span class="sc0">       </span><span class="sc11">external_fa</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc1">/* external file attributes        4 bytes */</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">zip_fileinfo</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">zipcharpc</span><span class="sc10">;</span><span class="sc0">


</span><span class="sc9">#define APPEND_STATUS_CREATE        (0)
#define APPEND_STATUS_CREATEAFTER   (1)
#define APPEND_STATUS_ADDINZIP      (2)
</span><span class="sc0">
</span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc11">zipFile</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">zipOpen</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">pathname</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">append</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc1">/*
  Create a zipfile.
     pathname contain on Windows XP a filename like "c:\\zlib\\zlib113.zip" or on
       an Unix computer "zlib/zlib113.zip".
     if the file pathname exist and append==APPEND_STATUS_CREATEAFTER, the zip
       will be created at the end of the file.
         (useful if the file contain a self extractor code)
     if the file pathname exist and append==APPEND_STATUS_ADDINZIP, we will
       add files in existing zip (be sure you don't add file that doesn't exist)
     If the zipfile cannot be opened, the return value is NULL.
     Else, the return value is a zipFile Handle, usable with other function
       of this zip package.
*/</span><span class="sc0">

</span><span class="sc1">/* Note : there is no delete function into a zipfile.
   If you want delete file into a zipfile, you must open a zipfile, and create another
   Of couse, you can use RAW reading and writing to copy the file you did not want delte
*/</span><span class="sc0">

</span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc11">zipFile</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">zipOpen2</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">pathname</span><span class="sc10">,</span><span class="sc0">
                                   </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">append</span><span class="sc10">,</span><span class="sc0">
                                   </span><span class="sc11">zipcharpc</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">globalcomment</span><span class="sc10">,</span><span class="sc0">
                                   </span><span class="sc11">zlib_filefunc_def</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">pzlib_filefunc_def</span><span class="sc10">));</span><span class="sc0">

</span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">zipOpenNewFileInZip</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">zipFile</span><span class="sc0"> </span><span class="sc11">file</span><span class="sc10">,</span><span class="sc0">
                       </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">filename</span><span class="sc10">,</span><span class="sc0">
                       </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">zip_fileinfo</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">zipfi</span><span class="sc10">,</span><span class="sc0">
                       </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">extrafield_local</span><span class="sc10">,</span><span class="sc0">
                       </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">size_extrafield_local</span><span class="sc10">,</span><span class="sc0">
                       </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">extrafield_global</span><span class="sc10">,</span><span class="sc0">
                       </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">size_extrafield_global</span><span class="sc10">,</span><span class="sc0">
                       </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">comment</span><span class="sc10">,</span><span class="sc0">
                       </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">method</span><span class="sc10">,</span><span class="sc0">
                       </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc1">/*
  Open a file in the ZIP for writing.
  filename : the filename in zip (if NULL, '-' without quote will be used
  *zipfi contain supplemental information
  if extrafield_local!=NULL and size_extrafield_local&gt;0, extrafield_local
    contains the extrafield data the the local header
  if extrafield_global!=NULL and size_extrafield_global&gt;0, extrafield_global
    contains the extrafield data the the local header
  if comment != NULL, comment contain the comment string
  method contain the compression method (0 for store, Z_DEFLATED for deflate)
  level contain the level of compression (can be Z_DEFAULT_COMPRESSION)
*/</span><span class="sc0">


</span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">zipOpenNewFileInZip2</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">zipFile</span><span class="sc0"> </span><span class="sc11">file</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">filename</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">zip_fileinfo</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">zipfi</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">extrafield_local</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">size_extrafield_local</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">extrafield_global</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">size_extrafield_global</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">comment</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">method</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">raw</span><span class="sc10">));</span><span class="sc0">

</span><span class="sc1">/*
  Same than zipOpenNewFileInZip, except if raw=1, we write raw file
 */</span><span class="sc0">

</span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">zipOpenNewFileInZip3</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">zipFile</span><span class="sc0"> </span><span class="sc11">file</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">filename</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">zip_fileinfo</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">zipfi</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">extrafield_local</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">size_extrafield_local</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">extrafield_global</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">size_extrafield_global</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">comment</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">method</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">raw</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">windowBits</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">memLevel</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">strategy</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">password</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc11">uLong</span><span class="sc0"> </span><span class="sc11">crcForCtypting</span><span class="sc10">));</span><span class="sc0">

</span><span class="sc1">/*
  Same than zipOpenNewFileInZip2, except
    windowBits,memLevel,,strategy : see parameter strategy in deflateInit2
    password : crypting password (NULL for no crypting)
    crcForCtypting : crc of file to compress (needed for crypting)
 */</span><span class="sc0">


</span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">zipWriteInFileInZip</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">zipFile</span><span class="sc0"> </span><span class="sc11">file</span><span class="sc10">,</span><span class="sc0">
                       </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0">
                       </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc1">/*
  Write data in the zipfile
*/</span><span class="sc0">

</span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">zipCloseFileInZip</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">zipFile</span><span class="sc0"> </span><span class="sc11">file</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc1">/*
  Close the current file in the zipfile
*/</span><span class="sc0">

</span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">zipCloseFileInZipRaw</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">zipFile</span><span class="sc0"> </span><span class="sc11">file</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc11">uLong</span><span class="sc0"> </span><span class="sc11">uncompressed_size</span><span class="sc10">,</span><span class="sc0">
                                            </span><span class="sc11">uLong</span><span class="sc0"> </span><span class="sc11">crc32</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc1">/*
  Close the current file in the zipfile, for fiel opened with
    parameter raw=1 in zipOpenNewFileInZip2
  uncompressed_size and crc32 are value for the uncompressed size
*/</span><span class="sc0">

</span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">zipClose</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">zipFile</span><span class="sc0"> </span><span class="sc11">file</span><span class="sc10">,</span><span class="sc0">
                </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">global_comment</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc1">/*
  Close the zipfile
*/</span><span class="sc0">

</span><span class="sc9">#ifdef __cplusplus
</span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
</span><span class="sc9">#endif </span><span class="sc1">/* _zip_H */</span><span class="sc0">
</span></div></body>
</html>
