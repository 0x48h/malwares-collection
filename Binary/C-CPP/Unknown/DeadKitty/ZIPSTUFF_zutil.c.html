<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Exported from Notepad++</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc1 {
	color: #008000;
}
.sc4 {
	color: #FF8000;
}
.sc5 {
	font-weight: bold;
	color: #0000FF;
}
.sc6 {
	color: #808080;
}
.sc9 {
	color: #804000;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc11 {
}
.sc16 {
	color: #8000FF;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc1">/* zutil.c -- target dependent utility functions for the compression library
 * Copyright (C) 1995-2005 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */</span><span class="sc0">

</span><span class="sc1">/* @(#) $Id$ */</span><span class="sc0">

</span><span class="sc9">#include "zutil.h"
</span><span class="sc0">
</span><span class="sc9">#ifndef NO_DUMMY_DECL
</span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">internal_state</span><span class="sc0">      </span><span class="sc10">{</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">dummy</span><span class="sc10">;};</span><span class="sc0"> </span><span class="sc1">/* for buggy compilers */</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">z_errmsg</span><span class="sc10">[</span><span class="sc4">10</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
</span><span class="sc6">"need dictionary"</span><span class="sc10">,</span><span class="sc0">     </span><span class="sc1">/* Z_NEED_DICT       2  */</span><span class="sc0">
</span><span class="sc6">"stream end"</span><span class="sc10">,</span><span class="sc0">          </span><span class="sc1">/* Z_STREAM_END      1  */</span><span class="sc0">
</span><span class="sc6">""</span><span class="sc10">,</span><span class="sc0">                    </span><span class="sc1">/* Z_OK              0  */</span><span class="sc0">
</span><span class="sc6">"file error"</span><span class="sc10">,</span><span class="sc0">          </span><span class="sc1">/* Z_ERRNO         (-1) */</span><span class="sc0">
</span><span class="sc6">"stream error"</span><span class="sc10">,</span><span class="sc0">        </span><span class="sc1">/* Z_STREAM_ERROR  (-2) */</span><span class="sc0">
</span><span class="sc6">"data error"</span><span class="sc10">,</span><span class="sc0">          </span><span class="sc1">/* Z_DATA_ERROR    (-3) */</span><span class="sc0">
</span><span class="sc6">"insufficient memory"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc1">/* Z_MEM_ERROR     (-4) */</span><span class="sc0">
</span><span class="sc6">"buffer error"</span><span class="sc10">,</span><span class="sc0">        </span><span class="sc1">/* Z_BUF_ERROR     (-5) */</span><span class="sc0">
</span><span class="sc6">"incompatible version"</span><span class="sc10">,</span><span class="sc1">/* Z_VERSION_ERROR (-6) */</span><span class="sc0">
</span><span class="sc6">""</span><span class="sc10">};</span><span class="sc0">


</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">zlibVersion</span><span class="sc10">()</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZLIB_VERSION</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc11">uLong</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">zlibCompileFlags</span><span class="sc10">()</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">uLong</span><span class="sc0"> </span><span class="sc11">flags</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">switch</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">uInt</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">:</span><span class="sc0">     </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">:</span><span class="sc0">     </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">     </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">:</span><span class="sc0">     </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0">     </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">default</span><span class="sc10">:</span><span class="sc0">    </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">switch</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">uLong</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">:</span><span class="sc0">     </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">:</span><span class="sc0">     </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">:</span><span class="sc0">     </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">default</span><span class="sc10">:</span><span class="sc0">    </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">switch</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">voidpf</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">:</span><span class="sc0">     </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">:</span><span class="sc0">     </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">:</span><span class="sc0">     </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">default</span><span class="sc10">:</span><span class="sc0">    </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">switch</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">z_off_t</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">:</span><span class="sc0">     </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">:</span><span class="sc0">     </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">6</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">:</span><span class="sc0">     </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">6</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">default</span><span class="sc10">:</span><span class="sc0">    </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">6</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#ifdef DEBUG
</span><span class="sc0">    </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
#if defined(ASMV) || defined(ASMINF)
</span><span class="sc0">    </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">9</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
#ifdef ZLIB_WINAPI
</span><span class="sc0">    </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">10</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
#ifdef BUILDFIXED
</span><span class="sc0">    </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">12</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
#ifdef DYNAMIC_CRC_TABLE
</span><span class="sc0">    </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">13</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
#ifdef NO_GZCOMPRESS
</span><span class="sc0">    </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1L</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">16</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
#ifdef NO_GZIP
</span><span class="sc0">    </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1L</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">17</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
#ifdef PKZIP_BUG_WORKAROUND
</span><span class="sc0">    </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1L</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">20</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
#ifdef FASTEST
</span><span class="sc0">    </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1L</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">21</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
#ifdef STDC
#  ifdef NO_vsnprintf
</span><span class="sc0">        </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1L</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">25</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#    ifdef HAS_vsprintf_void
</span><span class="sc0">        </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1L</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">26</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#    endif
#  else
#    ifdef HAS_vsnprintf_void
</span><span class="sc0">        </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1L</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">26</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#    endif
#  endif
#else
</span><span class="sc0">        </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1L</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">24</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#  ifdef NO_snprintf
</span><span class="sc0">        </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1L</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">25</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#    ifdef HAS_sprintf_void
</span><span class="sc0">        </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1L</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">26</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#    endif
#  else
#    ifdef HAS_snprintf_void
</span><span class="sc0">        </span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">1L</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">26</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#    endif
#  endif
#endif
</span><span class="sc0">    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">flags</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc9">#ifdef DEBUG
</span><span class="sc0">
</span><span class="sc9">#  ifndef verbose
#    define verbose 0
#  endif
</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">z_verbose</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">verbose</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">z_error</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">m</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">m</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">fprintf</span><span class="sc10">(</span><span class="sc11">stderr</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"%s\n"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">m</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">exit</span><span class="sc10">(</span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
</span><span class="sc1">/* exported to allow conversion of error code to string for compress() and
 * uncompress()
 */</span><span class="sc0">
</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">ZEXPORT</span><span class="sc0"> </span><span class="sc11">zError</span><span class="sc10">(</span><span class="sc11">err</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">err</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ERR_MSG</span><span class="sc10">(</span><span class="sc11">err</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc9">#if defined(_WIN32_WCE)
</span><span class="sc0">    </span><span class="sc1">/* The Microsoft C Run-Time Library for Windows CE doesn't have
     * errno.  We define it as a global variable to simplify porting.
     * Its value is always 0 and should not be used.
     */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">errno</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
</span><span class="sc9">#ifndef HAVE_MEMCPY
</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">zmemcpy</span><span class="sc10">(</span><span class="sc11">dest</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">source</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">Bytef</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">dest</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">Bytef</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">source</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0">  </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc10">*</span><span class="sc11">dest</span><span class="sc10">++</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">source</span><span class="sc10">++;</span><span class="sc0"> </span><span class="sc1">/* ??? to be unrolled */</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(--</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">zmemcmp</span><span class="sc10">(</span><span class="sc11">s1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">s2</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">Bytef</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">s1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">Bytef</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">s2</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0">  </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">j</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">j</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">j</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">j</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">s1</span><span class="sc10">[</span><span class="sc11">j</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">s2</span><span class="sc10">[</span><span class="sc11">j</span><span class="sc10">])</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">*(</span><span class="sc11">s1</span><span class="sc10">[</span><span class="sc11">j</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">s2</span><span class="sc10">[</span><span class="sc11">j</span><span class="sc10">])-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">zmemzero</span><span class="sc10">(</span><span class="sc11">dest</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">Bytef</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">dest</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">uInt</span><span class="sc0">  </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc10">*</span><span class="sc11">dest</span><span class="sc10">++</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* ??? to be unrolled */</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(--</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">

</span><span class="sc9">#ifdef SYS16BIT
</span><span class="sc0">
</span><span class="sc9">#ifdef __TURBOC__
</span><span class="sc1">/* Turbo C in 16-bit mode */</span><span class="sc0">

</span><span class="sc9">#  define MY_ZCALLOC
</span><span class="sc0">
</span><span class="sc1">/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
 * and farmalloc(64K) returns a pointer with an offset of 8, so we
 * must fix the pointer. Warning: the pointer must be put back to its
 * original form in order to free it, use zcfree().
 */</span><span class="sc0">

</span><span class="sc9">#define MAX_PTR 10
</span><span class="sc1">/* 10*64K = 640K */</span><span class="sc0">

</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">next_ptr</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">ptr_table_s</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">org_ptr</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">new_ptr</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">ptr_table</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc11">local</span><span class="sc0"> </span><span class="sc11">ptr_table</span><span class="sc0"> </span><span class="sc11">table</span><span class="sc10">[</span><span class="sc11">MAX_PTR</span><span class="sc10">];</span><span class="sc0">
</span><span class="sc1">/* This table is used to remember the original form of pointers
 * to large buffers (64K). Such pointers are normalized with a zero offset.
 * Since MSDOS is not a preemptive multitasking OS, this table is not
 * protected from concurrent access. This hack doesn't work anyway on
 * a protected system like OS/2. Use Microsoft C instead.
 */</span><span class="sc0">

</span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">zcalloc</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">opaque</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">items</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">buf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">opaque</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* just to make some compilers happy */</span><span class="sc0">
    </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">bsize</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">items</span><span class="sc10">*</span><span class="sc11">size</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* If we allocate less than 65520 bytes, we assume that farmalloc
     * will return a usable pointer which doesn't have to be normalized.
     */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bsize</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">65520L</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">buf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">farmalloc</span><span class="sc10">(</span><span class="sc11">bsize</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(*(</span><span class="sc11">ush</span><span class="sc10">*)&amp;</span><span class="sc11">buf</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">buf</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">buf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">farmalloc</span><span class="sc10">(</span><span class="sc11">bsize</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">16L</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">buf</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc5">NULL</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">next_ptr</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">MAX_PTR</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc5">NULL</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">table</span><span class="sc10">[</span><span class="sc11">next_ptr</span><span class="sc10">].</span><span class="sc11">org_ptr</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">buf</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* Normalize the pointer to seg:0 */</span><span class="sc0">
    </span><span class="sc10">*((</span><span class="sc11">ush</span><span class="sc10">*)&amp;</span><span class="sc11">buf</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">ush</span><span class="sc10">)((</span><span class="sc11">uch</span><span class="sc10">*)</span><span class="sc11">buf</span><span class="sc10">-</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">15</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">*(</span><span class="sc11">ush</span><span class="sc10">*)&amp;</span><span class="sc11">buf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">table</span><span class="sc10">[</span><span class="sc11">next_ptr</span><span class="sc10">++].</span><span class="sc11">new_ptr</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">buf</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">buf</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc16">void</span><span class="sc0">  </span><span class="sc11">zcfree</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">opaque</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">ptr</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(*(</span><span class="sc11">ush</span><span class="sc10">*)&amp;</span><span class="sc11">ptr</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc1">/* object &lt; 64K */</span><span class="sc0">
        </span><span class="sc11">farfree</span><span class="sc10">(</span><span class="sc11">ptr</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc5">return</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc1">/* Find the original pointer */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">next_ptr</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ptr</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">table</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">new_ptr</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">continue</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc11">farfree</span><span class="sc10">(</span><span class="sc11">table</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">org_ptr</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(++</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">next_ptr</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">table</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">table</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">];</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc11">next_ptr</span><span class="sc10">--;</span><span class="sc0">
        </span><span class="sc5">return</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">ptr</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">opaque</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* just to make some compilers happy */</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"zcfree: ptr not found"</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc9">#endif </span><span class="sc1">/* __TURBOC__ */</span><span class="sc0">


</span><span class="sc9">#ifdef M_I86
</span><span class="sc1">/* Microsoft C in 16-bit mode */</span><span class="sc0">

</span><span class="sc9">#  define MY_ZCALLOC
</span><span class="sc0">
</span><span class="sc9">#if (!defined(_MSC_VER) || (_MSC_VER &lt;= 600))
#  define _halloc  halloc
#  define _hfree   hfree
#endif
</span><span class="sc0">
</span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">zcalloc</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">opaque</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">items</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">opaque</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">opaque</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* to make compiler happy */</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">_halloc</span><span class="sc10">((</span><span class="sc16">long</span><span class="sc10">)</span><span class="sc11">items</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc16">void</span><span class="sc0">  </span><span class="sc11">zcfree</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">opaque</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">ptr</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">opaque</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">opaque</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* to make compiler happy */</span><span class="sc0">
    </span><span class="sc11">_hfree</span><span class="sc10">(</span><span class="sc11">ptr</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc9">#endif </span><span class="sc1">/* M_I86 */</span><span class="sc0">

</span><span class="sc9">#endif </span><span class="sc1">/* SYS16BIT */</span><span class="sc0">


</span><span class="sc9">#ifndef MY_ZCALLOC </span><span class="sc1">/* Any system without a special alloc function */</span><span class="sc0">

</span><span class="sc9">#ifndef STDC
</span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc11">voidp</span><span class="sc0">  </span><span class="sc11">malloc</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc11">voidp</span><span class="sc0">  </span><span class="sc11">calloc</span><span class="sc0"> </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">items</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">uInt</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc16">extern</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0">   </span><span class="sc11">free</span><span class="sc0">   </span><span class="sc11">OF</span><span class="sc10">((</span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">ptr</span><span class="sc10">));</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
</span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">zcalloc</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">opaque</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">items</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">opaque</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">items</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">opaque</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">items</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* make compiler happy */</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">uInt</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">voidpf</span><span class="sc10">)</span><span class="sc11">malloc</span><span class="sc10">(</span><span class="sc11">items</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0">
                              </span><span class="sc10">(</span><span class="sc11">voidpf</span><span class="sc10">)</span><span class="sc11">calloc</span><span class="sc10">(</span><span class="sc11">items</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc16">void</span><span class="sc0">  </span><span class="sc11">zcfree</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">opaque</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ptr</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">opaque</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">voidpf</span><span class="sc0"> </span><span class="sc11">ptr</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">free</span><span class="sc10">(</span><span class="sc11">ptr</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">opaque</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* make compiler happy */</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc9">#endif </span><span class="sc1">/* MY_ZCALLOC */</span><span class="sc0">
</span></div></body>
</html>
