<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>IRC-Worm.Win32.Tutiam.a - ZipPackerIn.h.html</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc1 {
	color: #008000;
}
.sc2 {
	color: #008000;
}
.sc4 {
	color: #FF8000;
}
.sc5 {
	font-weight: bold;
	color: #0000FF;
}
.sc6 {
	color: #808080;
}
.sc7 {
	color: #808080;
}
.sc9 {
	color: #804000;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc11 {
}
.sc16 {
	color: #8000FF;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc2">// XZip.h  Version 1.1
//
// Authors:      Mark Adler et al. (see below)
//
// Modified by:  Lucian WischikF
//               lu@wischik.com
//
// Version 1.0   - Turned C files into just a single CPP file
//               - Made them compile cleanly as C++ files
//               - Gave them simpler APIs
//               - Added the ability to zip/unzip directly in memory without 
//                 any intermediate files
// 
// Modified by:  Hans Dietrich
//               hdietrich2@hotmail.com
//
// Version 1.1:  - Added Unicode support to CreateZip() and ZipAdd()
//               - Changed file names to avoid conflicts with Lucian's files
//
///////////////////////////////////////////////////////////////////////////////
//
// Lucian Wischik's comments:
// --------------------------
// THIS FILE is almost entirely based upon code by info-zip.
// It has been modified by Lucian Wischik.
// The original code may be found at http://www.info-zip.org
// The original copyright text follows.
//
///////////////////////////////////////////////////////////////////////////////
//
// Original authors' comments:
// ---------------------------
// This is version 2002-Feb-16 of the Info-ZIP copyright and license. The 
// definitive version of this document should be available at 
// ftp://ftp.info-zip.org/pub/infozip/license.html indefinitely.
// 
// Copyright (c) 1990-2002 Info-ZIP.  All rights reserved.
//
// For the purposes of this copyright and license, "Info-ZIP" is defined as
// the following set of individuals:
//
//   Mark Adler, John Bush, Karl Davis, Harald Denker, Jean-Michel Dubois,
//   Jean-loup Gailly, Hunter Goatley, Ian Gorman, Chris Herborth, Dirk Haase,
//   Greg Hartwig, Robert Heath, Jonathan Hudson, Paul Kienitz, 
//   David Kirschbaum, Johnny Lee, Onno van der Linden, Igor Mandrichenko, 
//   Steve P. Miller, Sergio Monesi, Keith Owens, George Petrov, Greg Roelofs, 
//   Kai Uwe Rommel, Steve Salisbury, Dave Smith, Christian Spieler, 
//   Antoine Verheijen, Paul von Behren, Rich Wales, Mike White
//
// This software is provided "as is", without warranty of any kind, express
// or implied.  In no event shall Info-ZIP or its contributors be held liable
// for any direct, indirect, incidental, special or consequential damages
// arising out of the use of or inability to use this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       definition, disclaimer, and this list of conditions.
//
//    2. Redistributions in binary form (compiled executables) must reproduce 
//       the above copyright notice, definition, disclaimer, and this list of 
//       conditions in documentation and/or other materials provided with the 
//       distribution. The sole exception to this condition is redistribution 
//       of a standard UnZipSFX binary as part of a self-extracting archive; 
//       that is permitted without inclusion of this license, as long as the 
//       normal UnZipSFX banner has not been removed from the binary or disabled.
//
//    3. Altered versions--including, but not limited to, ports to new 
//       operating systems, existing ports with new graphical interfaces, and 
//       dynamic, shared, or static library versions--must be plainly marked 
//       as such and must not be misrepresented as being the original source.  
//       Such altered versions also must not be misrepresented as being 
//       Info-ZIP releases--including, but not limited to, labeling of the 
//       altered versions with the names "Info-ZIP" (or any variation thereof, 
//       including, but not limited to, different capitalizations), 
//       "Pocket UnZip", "WiZ" or "MacZip" without the explicit permission of 
//       Info-ZIP.  Such altered versions are further prohibited from 
//       misrepresentative use of the Zip-Bugs or Info-ZIP e-mail addresses or 
//       of the Info-ZIP URL(s).
//
//    4. Info-ZIP retains the right to use the names "Info-ZIP", "Zip", "UnZip",
//       "UnZipSFX", "WiZ", "Pocket UnZip", "Pocket Zip", and "MacZip" for its 
//       own source and binary releases.
//
///////////////////////////////////////////////////////////////////////////////
</span><span class="sc0">
</span><span class="sc9">#ifndef XZIP_H
#define XZIP_H
</span><span class="sc0">
</span><span class="sc2">// ZIP functions -- for creating zip files
// This file is a repackaged form of the Info-Zip source code available
// at www.info-zip.org. The original copyright notice may be found in
// zip.cpp. The repackaging was done by Lucian Wischik to simplify its
// use in Windows/C++.
</span><span class="sc0">
</span><span class="sc9">#ifndef XUNZIP_H
</span><span class="sc11">DECLARE_HANDLE</span><span class="sc10">(</span><span class="sc11">HZIP</span><span class="sc10">);</span><span class="sc0">       </span><span class="sc2">// An HZIP identifies a zip file that is being created
</span><span class="sc9">#endif
</span><span class="sc0">
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc11">DWORD</span><span class="sc0"> </span><span class="sc11">ZRESULT</span><span class="sc10">;</span><span class="sc0">      </span><span class="sc2">// result codes from any of the zip functions. Listed later.
</span><span class="sc0">
</span><span class="sc2">// flag values passed to some functions
</span><span class="sc9">#define ZIP_HANDLE   1
#define ZIP_FILENAME 2
#define ZIP_MEMORY   3
#define ZIP_FOLDER   4
</span><span class="sc0">

</span><span class="sc2">///////////////////////////////////////////////////////////////////////////////
//
// CreateZip()
//
// Purpose:     Create a zip archive file
//
// Parameters:  z      - archive file name if flags is ZIP_FILENAME;  for other
//                       uses see below
//              len    - for memory (ZIP_MEMORY) should be the buffer size;
//                       for other uses, should be 0
//              flags  - indicates usage, see below;  for files, this will be
//                       ZIP_FILENAME
//
// Returns:     HZIP   - non-zero if zip archive created ok, otherwise 0
//
</span><span class="sc11">HZIP</span><span class="sc0"> </span><span class="sc11">CreateZip</span><span class="sc10">(</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">z</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">DWORD</span><span class="sc0"> </span><span class="sc11">flags</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc2">// CreateZip - call this to start the creation of a zip file.
// As the zip is being created, it will be stored somewhere:
// to a pipe:              CreateZip(hpipe_write, 0,ZIP_HANDLE);
// in a file (by handle):  CreateZip(hfile, 0,ZIP_HANDLE);
// in a file (by name):    CreateZip("c:\\test.zip", 0,ZIP_FILENAME);
// in memory:              CreateZip(buf, len,ZIP_MEMORY);
// or in pagefile memory:  CreateZip(0, len,ZIP_MEMORY);
// The final case stores it in memory backed by the system paging file,
// where the zip may not exceed len bytes. This is a bit friendlier than
// allocating memory with new[]: it won't lead to fragmentation, and the
// memory won't be touched unless needed.
// Note: because pipes don't allow random access, the structure of a zipfile
// created into a pipe is slightly different from that created into a file
// or memory. In particular, the compressed-size of the item cannot be
// stored in the zipfile until after the item itself. (Also, for an item added
// itself via a pipe, the uncompressed-size might not either be known until
// after.) This is not normally a problem. But if you try to unzip via a pipe
// as well, then the unzipper will not know these things about the item until
// after it has been unzipped. Therefore: for unzippers which don't just write
// each item to disk or to a pipe, but instead pre-allocate memory space into
// which to unzip them, then either you have to create the zip not to a pipe,
// or you have to add items not from a pipe, or at least when adding items
// from a pipe you have to specify the length.
</span><span class="sc0">

</span><span class="sc2">///////////////////////////////////////////////////////////////////////////////
//
// ZipAdd()
//
// Purpose:     Add a file to a zip archive
//
// Parameters:  hz      - handle to an open zip archive
//              dstzn   - name used inside the zip archive to identify the file
//              src     - for a file (ZIP_FILENAME) this specifies the filename
//                        to be added to the archive;  for other uses, see below
//              len     - for memory (ZIP_MEMORY) this specifies the buffer 
//                        length;  for other uses, this should be 0
//              flags   - indicates usage, see below;  for files, this will be
//                        ZIP_FILENAME
//
// Returns:     ZRESULT - ZR_OK if success, otherwise some other value
//
</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">ZipAdd</span><span class="sc10">(</span><span class="sc11">HZIP</span><span class="sc0"> </span><span class="sc11">hz</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">TCHAR</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">dstzn</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">src</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">DWORD</span><span class="sc0"> </span><span class="sc11">flags</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc2">// ZipAdd - call this for each file to be added to the zip.
// dstzn is the name that the file will be stored as in the zip file.
// The file to be added to the zip can come
// from a pipe:  ZipAdd(hz,"file.dat", hpipe_read,0,ZIP_HANDLE);
// from a file:  ZipAdd(hz,"file.dat", hfile,0,ZIP_HANDLE);
// from a fname: ZipAdd(hz,"file.dat", "c:\\docs\\origfile.dat",0,ZIP_FILENAME);
// from memory:  ZipAdd(hz,"subdir\\file.dat", buf,len,ZIP_MEMORY);
// (folder):     ZipAdd(hz,"subdir",   0,0,ZIP_FOLDER);
// Note: if adding an item from a pipe, and if also creating the zip file itself
// to a pipe, then you might wish to pass a non-zero length to the ZipAdd
// function. This will let the zipfile store the items size ahead of the
// compressed item itself, which in turn makes it easier when unzipping the
// zipfile into a pipe.
</span><span class="sc0">

</span><span class="sc2">///////////////////////////////////////////////////////////////////////////////
//
// CloseZip()
//
// Purpose:     Close an open zip archive
//
// Parameters:  hz      - handle to an open zip archive
//
// Returns:     ZRESULT - ZR_OK if success, otherwise some other value
//
</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">CloseZip</span><span class="sc10">(</span><span class="sc11">HZIP</span><span class="sc0"> </span><span class="sc11">hz</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc2">// CloseZip - the zip handle must be closed with this function.
</span><span class="sc0">

</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">ZipGetMemory</span><span class="sc10">(</span><span class="sc11">HZIP</span><span class="sc0"> </span><span class="sc11">hz</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">**</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc2">// ZipGetMemory - If the zip was created in memory, via ZipCreate(0,ZIP_MEMORY),
// then this function will return information about that memory block.
// buf will receive a pointer to its start, and len its length.
// Note: you can't add any more after calling this.
</span><span class="sc0">

</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">FormatZipMessage</span><span class="sc10">(</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc2">// FormatZipMessage - given an error code, formats it as a string.
// It returns the length of the error message. If buf/len points
// to a real buffer, then it also writes as much as possible into there.
</span><span class="sc0">


</span><span class="sc2">// These are the result codes:
</span><span class="sc9">#define ZR_OK         0x00000000     </span><span class="sc2">// nb. the pseudo-code zr-recent is never returned,
</span><span class="sc9">#define ZR_RECENT     0x00000001     </span><span class="sc2">// but can be passed to FormatZipMessage.
// The following come from general system stuff (e.g. files not openable)
</span><span class="sc9">#define ZR_GENMASK    0x0000FF00
#define ZR_NODUPH     0x00000100     </span><span class="sc2">// couldn't duplicate the handle
</span><span class="sc9">#define ZR_NOFILE     0x00000200     </span><span class="sc2">// couldn't create/open the file
</span><span class="sc9">#define ZR_NOALLOC    0x00000300     </span><span class="sc2">// failed to allocate some resource
</span><span class="sc9">#define ZR_WRITE      0x00000400     </span><span class="sc2">// a general error writing to the file
</span><span class="sc9">#define ZR_NOTFOUND   0x00000500     </span><span class="sc2">// couldn't find that file in the zip
</span><span class="sc9">#define ZR_MORE       0x00000600     </span><span class="sc2">// there's still more data to be unzipped
</span><span class="sc9">#define ZR_CORRUPT    0x00000700     </span><span class="sc2">// the zipfile is corrupt or not a zipfile
</span><span class="sc9">#define ZR_READ       0x00000800     </span><span class="sc2">// a general error reading the file
// The following come from mistakes on the part of the caller
</span><span class="sc9">#define ZR_CALLERMASK 0x00FF0000
#define ZR_ARGS       0x00010000     </span><span class="sc2">// general mistake with the arguments
</span><span class="sc9">#define ZR_NOTMMAP    0x00020000     </span><span class="sc2">// tried to ZipGetMemory, but that only works on mmap zipfiles, which yours wasn't
</span><span class="sc9">#define ZR_MEMSIZE    0x00030000     </span><span class="sc2">// the memory size is too small
</span><span class="sc9">#define ZR_FAILED     0x00040000     </span><span class="sc2">// the thing was already failed when you called this function
</span><span class="sc9">#define ZR_ENDED      0x00050000     </span><span class="sc2">// the zip creation has already been closed
</span><span class="sc9">#define ZR_MISSIZE    0x00060000     </span><span class="sc2">// the indicated input file size turned out mistaken
</span><span class="sc9">#define ZR_PARTIALUNZ 0x00070000     </span><span class="sc2">// the file had already been partially unzipped
</span><span class="sc9">#define ZR_ZMODE      0x00080000     </span><span class="sc2">// tried to mix creating/opening a zip 
// The following come from bugs within the zip library itself
</span><span class="sc9">#define ZR_BUGMASK    0xFF000000
#define ZR_NOTINITED  0x01000000     </span><span class="sc2">// initialisation didn't work
</span><span class="sc9">#define ZR_SEEK       0x02000000     </span><span class="sc2">// trying to seek in an unseekable file
</span><span class="sc9">#define ZR_NOCHANGE   0x04000000     </span><span class="sc2">// changed its mind on storage, but not allowed
</span><span class="sc9">#define ZR_FLATE      0x05000000     </span><span class="sc2">// an internal error in the de/inflation code
</span><span class="sc0">


</span><span class="sc2">// e.g.
//
// (1) Traditional use, creating a zipfile from existing files
//     HZIP hz = CreateZip("c:\\temp.zip",0,ZIP_FILENAME);
//     ZipAdd(hz,"src1.txt",  "c:\\src1.txt",0,ZIP_FILENAME);
//     ZipAdd(hz,"src2.bmp",  "c:\\src2_origfn.bmp",0,ZIP_FILENAME);
//     CloseZip(hz);
//
// (2) Memory use, creating an auto-allocated mem-based zip file from various sources
//     HZIP hz = CreateZip(0,100000,ZIP_MEMORY);
//     // adding a conventional file...
//     ZipAdd(hz,"src1.txt",  "c:\\src1.txt",0,ZIP_FILENAME);
//     // adding something from memory...
//     char buf[1000]; for (int i=0; i&lt;1000; i++) buf[i]=(char)(i&amp;0x7F);
//     ZipAdd(hz,"file.dat",  buf,1000,ZIP_MEMORY);
//     // adding something from a pipe...
//     HANDLE hread,hwrite; CreatePipe(&amp;hread,&amp;write,NULL,0);
//     HANDLE hthread = CreateThread(ThreadFunc,(void*)hwrite);
//     ZipAdd(hz,"unz3.dat",  hread,0,ZIP_HANDLE);
//     WaitForSingleObject(hthread,INFINITE);
//     CloseHandle(hthread); CloseHandle(hread);
//     ... meanwhile DWORD CALLBACK ThreadFunc(void *dat)
//                   { HANDLE hwrite = (HANDLE)dat;
//                     char buf[1000]={17};
//                     DWORD writ; WriteFile(hwrite,buf,1000,&amp;writ,NULL);
//                     CloseHandle(hwrite);
//                     return 0;
//                   }
//     // and now that the zip is created, let's do something with it:
//     void *zbuf; unsigned long zlen; ZipGetMemory(hz,&amp;zbuf,&amp;zlen);
//     HANDLE hfz = CreateFile("test2.zip",GENERIC_WRITE,CREATE_ALWAYS);
//     DWORD writ; WriteFile(hfz,zbuf,zlen,&amp;writ,NULL);
//     CloseHandle(hfz);
//     CloseZip(hz);
//
// (3) Handle use, for file handles and pipes
//     HANDLE hzread,hzwrite; CreatePipe(&amp;hzread,&amp;hzwrite);
//     HANDLE hthread = CreateThread(ZipReceiverThread,(void*)hread);
//     HZIP hz = ZipCreate(hzwrite,ZIP_HANDLE);
//     // ... add to it
//     CloseZip(hz);
//     CloseHandle(hzwrite);
//     WaitForSingleObject(hthread,INFINITE);
//     CloseHandle(hthread);
//     ... meanwhile DWORD CALLBACK ThreadFunc(void *dat)
//                   { HANDLE hread = (HANDLE)dat;
//                     char buf[1000];
//                     while (true)
//                     { DWORD red; ReadFile(hread,buf,1000,&amp;red,NULL);
//                       // ... and do something with this zip data we're receiving
//                       if (red==0) break;
//                     }
//                     CloseHandle(hread);
//                     return 0;
//                   }
//
</span><span class="sc0">

</span><span class="sc2">// Now we indulge in a little skullduggery so that the code works whether
// the user has included just zip or both zip and unzip.
// Idea: if header files for both zip and unzip are present, then presumably
// the cpp files for zip and unzip are both present, so we will call
// one or the other of them based on a dynamic choice. If the header file
// for only one is present, then we will bind to that particular one.
</span><span class="sc11">HZIP</span><span class="sc0"> </span><span class="sc11">CreateZipZ</span><span class="sc10">(</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">z</span><span class="sc10">,</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">,</span><span class="sc11">DWORD</span><span class="sc0"> </span><span class="sc11">flags</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">CloseZipZ</span><span class="sc10">(</span><span class="sc11">HZIP</span><span class="sc0"> </span><span class="sc11">hz</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">FormatZipMessageZ</span><span class="sc10">(</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc16">bool</span><span class="sc0"> </span><span class="sc11">IsZipHandleZ</span><span class="sc10">(</span><span class="sc11">HZIP</span><span class="sc0"> </span><span class="sc11">hz</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc9">#define CreateZip CreateZipZ
</span><span class="sc0">
</span><span class="sc9">#ifdef XUNZIP_H
#undef CloseZip
#define CloseZip(hz) (IsZipHandleZ(hz)?CloseZipZ(hz):CloseZipU(hz))
#else
#define CloseZip CloseZipZ
#define FormatZipMessage FormatZipMessageZ
#endif
</span><span class="sc0">

</span><span class="sc9">#endif </span><span class="sc2">//XZIP_H
</span><span class="sc0">
</span><span class="sc2">// XZip.cpp  Version 1.1
//
// Authors:      Mark Adler et al. (see below)
//
// Modified by:  Lucian Wischik
//               lu@wischik.com
//
// Version 1.0   - Turned C files into just a single CPP file
//               - Made them compile cleanly as C++ files
//               - Gave them simpler APIs
//               - Added the ability to zip/unzip directly in memory without 
//                 any intermediate files
// 
// Modified by:  Hans Dietrich
//               hdietrich2@hotmail.com
//
// Version 1.1:  - Added Unicode support to CreateZip() and ZipAdd()
//               - Changed file names to avoid conflicts with Lucian's files
//
///////////////////////////////////////////////////////////////////////////////
//
// Lucian Wischik's comments:
// --------------------------
// THIS FILE is almost entirely based upon code by Info-ZIP.
// It has been modified by Lucian Wischik.
// The original code may be found at http://www.info-zip.org
// The original copyright text follows.
//
///////////////////////////////////////////////////////////////////////////////
//
// Original authors' comments:
// ---------------------------
// This is version 2002-Feb-16 of the Info-ZIP copyright and license. The 
// definitive version of this document should be available at 
// ftp://ftp.info-zip.org/pub/infozip/license.html indefinitely.
// 
// Copyright (c) 1990-2002 Info-ZIP.  All rights reserved.
//
// For the purposes of this copyright and license, "Info-ZIP" is defined as
// the following set of individuals:
//
//   Mark Adler, John Bush, Karl Davis, Harald Denker, Jean-Michel Dubois,
//   Jean-loup Gailly, Hunter Goatley, Ian Gorman, Chris Herborth, Dirk Haase,
//   Greg Hartwig, Robert Heath, Jonathan Hudson, Paul Kienitz, 
//   David Kirschbaum, Johnny Lee, Onno van der Linden, Igor Mandrichenko, 
//   Steve P. Miller, Sergio Monesi, Keith Owens, George Petrov, Greg Roelofs, 
//   Kai Uwe Rommel, Steve Salisbury, Dave Smith, Christian Spieler, 
//   Antoine Verheijen, Paul von Behren, Rich Wales, Mike White
//
// This software is provided "as is", without warranty of any kind, express
// or implied.  In no event shall Info-ZIP or its contributors be held liable
// for any direct, indirect, incidental, special or consequential damages
// arising out of the use of or inability to use this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       definition, disclaimer, and this list of conditions.
//
//    2. Redistributions in binary form (compiled executables) must reproduce 
//       the above copyright notice, definition, disclaimer, and this list of 
//       conditions in documentation and/or other materials provided with the 
//       distribution. The sole exception to this condition is redistribution 
//       of a standard UnZipSFX binary as part of a self-extracting archive; 
//       that is permitted without inclusion of this license, as long as the 
//       normal UnZipSFX banner has not been removed from the binary or disabled.
//
//    3. Altered versions--including, but not limited to, ports to new 
//       operating systems, existing ports with new graphical interfaces, and 
//       dynamic, shared, or static library versions--must be plainly marked 
//       as such and must not be misrepresented as being the original source.  
//       Such altered versions also must not be misrepresented as being 
//       Info-ZIP releases--including, but not limited to, labeling of the 
//       altered versions with the names "Info-ZIP" (or any variation thereof, 
//       including, but not limited to, different capitalizations), 
//       "Pocket UnZip", "WiZ" or "MacZip" without the explicit permission of 
//       Info-ZIP.  Such altered versions are further prohibited from 
//       misrepresentative use of the Zip-Bugs or Info-ZIP e-mail addresses or 
//       of the Info-ZIP URL(s).
//
//    4. Info-ZIP retains the right to use the names "Info-ZIP", "Zip", "UnZip",
//       "UnZipSFX", "WiZ", "Pocket UnZip", "Pocket Zip", and "MacZip" for its 
//       own source and binary releases.
//
///////////////////////////////////////////////////////////////////////////////
</span><span class="sc0">
</span><span class="sc2">//#define STRICT
//#define WIN32_LEAN_AND_MEAN
//#include &lt;windows.h&gt;
//#include &lt;time.h&gt;
//#include "xzip.h"
</span><span class="sc0">

</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc11">uch</span><span class="sc10">;</span><span class="sc0">      </span><span class="sc2">// unsigned 8-bit value
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">short</span><span class="sc0"> </span><span class="sc11">ush</span><span class="sc10">;</span><span class="sc0">     </span><span class="sc2">// unsigned 16-bit value
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc0"> </span><span class="sc11">ulg</span><span class="sc10">;</span><span class="sc0">      </span><span class="sc2">// unsigned 32-bit value
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc11">size_t</span><span class="sc0"> </span><span class="sc11">extent</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc2">// file size
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">Pos</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc2">// must be at least 32 bits
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">IPos</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// A Pos is an index in the character window. Pos is used only for parameter passing
</span><span class="sc0">
</span><span class="sc9">#ifndef EOF
#define EOF (-1)
#endif
</span><span class="sc0">

</span><span class="sc2">// Error return values.  The values 0..4 and 12..18 follow the conventions
// of PKZIP.   The values 4..10 are all assigned to "insufficient memory"
// by PKZIP, so the codes 5..10 are used here for other purposes.
</span><span class="sc9">#define ZE_MISS         -1      </span><span class="sc2">// used by procname(), zipbare()
</span><span class="sc9">#define ZE_OK           0       </span><span class="sc2">// success
</span><span class="sc9">#define ZE_EOF          2       </span><span class="sc2">// unexpected end of zip file
</span><span class="sc9">#define ZE_FORM         3       </span><span class="sc2">// zip file structure error
</span><span class="sc9">#define ZE_MEM          4       </span><span class="sc2">// out of memory
</span><span class="sc9">#define ZE_LOGIC        5       </span><span class="sc2">// internal logic error
</span><span class="sc9">#define ZE_BIG          6       </span><span class="sc2">// entry too large to split
</span><span class="sc9">#define ZE_NOTE         7       </span><span class="sc2">// invalid comment format
</span><span class="sc9">#define ZE_TEST         8       </span><span class="sc2">// zip test (-T) failed or out of memory
</span><span class="sc9">#define ZE_ABORT        9       </span><span class="sc2">// user interrupt or termination
</span><span class="sc9">#define ZE_TEMP         10      </span><span class="sc2">// error using a temp file
</span><span class="sc9">#define ZE_READ         11      </span><span class="sc2">// read or seek error
</span><span class="sc9">#define ZE_NONE         12      </span><span class="sc2">// nothing to do
</span><span class="sc9">#define ZE_NAME         13      </span><span class="sc2">// missing or empty zip file
</span><span class="sc9">#define ZE_WRITE        14      </span><span class="sc2">// error writing to a file
</span><span class="sc9">#define ZE_CREAT        15      </span><span class="sc2">// couldn't open to write
</span><span class="sc9">#define ZE_PARMS        16      </span><span class="sc2">// bad command line
</span><span class="sc9">#define ZE_OPEN         18      </span><span class="sc2">// could not open a specified file to read
</span><span class="sc9">#define ZE_MAXERR       18      </span><span class="sc2">// the highest error number
</span><span class="sc0">

</span><span class="sc2">// internal file attribute
</span><span class="sc9">#define UNKNOWN (-1)
#define BINARY  0
#define ASCII   1
</span><span class="sc0">
</span><span class="sc9">#define BEST -1                 </span><span class="sc2">// Use best method (deflation or store)
</span><span class="sc9">#define STORE 0                 </span><span class="sc2">// Store method
</span><span class="sc9">#define DEFLATE 8               </span><span class="sc2">// Deflation method
</span><span class="sc0">
</span><span class="sc9">#define CRCVAL_INITIAL  0L
</span><span class="sc0">
</span><span class="sc2">// MSDOS file or directory attributes
</span><span class="sc9">#define MSDOS_HIDDEN_ATTR 0x02
#define MSDOS_DIR_ATTR 0x10
</span><span class="sc0">
</span><span class="sc2">// Lengths of headers after signatures in bytes
</span><span class="sc9">#define LOCHEAD 26
#define CENHEAD 42
#define ENDHEAD 18
</span><span class="sc0">
</span><span class="sc2">// Definitions for extra field handling:
</span><span class="sc9">#define EB_HEADSIZE       4     </span><span class="sc1">/* length of a extra field block header */</span><span class="sc0">
</span><span class="sc9">#define EB_LEN            2     </span><span class="sc1">/* offset of data length field in header */</span><span class="sc0">
</span><span class="sc9">#define EB_UT_MINLEN      1     </span><span class="sc1">/* minimal UT field contains Flags byte */</span><span class="sc0">
</span><span class="sc9">#define EB_UT_FLAGS       0     </span><span class="sc1">/* byte offset of Flags field */</span><span class="sc0">
</span><span class="sc9">#define EB_UT_TIME1       1     </span><span class="sc1">/* byte offset of 1st time value */</span><span class="sc0">
</span><span class="sc9">#define EB_UT_FL_MTIME    (1 &lt;&lt; 0)      </span><span class="sc1">/* mtime present */</span><span class="sc0">
</span><span class="sc9">#define EB_UT_FL_ATIME    (1 &lt;&lt; 1)      </span><span class="sc1">/* atime present */</span><span class="sc0">
</span><span class="sc9">#define EB_UT_FL_CTIME    (1 &lt;&lt; 2)      </span><span class="sc1">/* ctime present */</span><span class="sc0">
</span><span class="sc9">#define EB_UT_LEN(n)      (EB_UT_MINLEN + 4 * (n))
#define EB_L_UT_SIZE    (EB_HEADSIZE + EB_UT_LEN(3))
#define EB_C_UT_SIZE    (EB_HEADSIZE + EB_UT_LEN(1))
</span><span class="sc0">

</span><span class="sc2">// Macros for writing machine integers to little-endian format
</span><span class="sc9">#define PUTSH(a,f) {char _putsh_c=(char)((a)&amp;0xff); wfunc(param,&amp;_putsh_c,1); _putsh_c=(char)((a)&gt;&gt;8); wfunc(param,&amp;_putsh_c,1);}
#define PUTLG(a,f) {PUTSH((a) &amp; 0xffff,(f)) PUTSH((a) &gt;&gt; 16,(f))}
</span><span class="sc0">

</span><span class="sc2">// -- Structure of a ZIP file --
// Signatures for zip file information headers
</span><span class="sc9">#define LOCSIG     0x04034b50L
#define CENSIG     0x02014b50L
#define ENDSIG     0x06054b50L
#define EXTLOCSIG  0x08074b50L
</span><span class="sc0">

</span><span class="sc9">#define MIN_MATCH  3
#define MAX_MATCH  258
</span><span class="sc2">// The minimum and maximum match lengths
</span><span class="sc0">

</span><span class="sc9">#define WSIZE  (0x8000)
</span><span class="sc2">// Maximum window size = 32K. If you are really short of memory, compile
// with a smaller WSIZE but this reduces the compression ratio for files
// of size &gt; WSIZE. WSIZE must be a power of two in the current implementation.
//
</span><span class="sc0">
</span><span class="sc9">#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
</span><span class="sc2">// Minimum amount of lookahead, except at the end of the input file.
// See deflate.c for comments about the MIN_MATCH+1.
//
</span><span class="sc0">
</span><span class="sc9">#define MAX_DIST  (WSIZE-MIN_LOOKAHEAD)
</span><span class="sc2">// In order to simplify the code, particularly on 16 bit machines, match
// distances are limited to MAX_DIST instead of WSIZE.
//
</span><span class="sc0">




</span><span class="sc2">// ===========================================================================
// Constants
//
</span><span class="sc0">
</span><span class="sc9">#define MAX_BITS 15
</span><span class="sc2">// All codes must not exceed MAX_BITS bits
</span><span class="sc0">
</span><span class="sc9">#define MAX_BL_BITS 7
</span><span class="sc2">// Bit length codes must not exceed MAX_BL_BITS bits
</span><span class="sc0">
</span><span class="sc9">#define LENGTH_CODES 29
</span><span class="sc2">// number of length codes, not counting the special END_BLOCK code
</span><span class="sc0">
</span><span class="sc9">#define LITERALS  256
</span><span class="sc2">// number of literal bytes 0..255
</span><span class="sc0">
</span><span class="sc9">#define END_BLOCK 256
</span><span class="sc2">// end of block literal code
</span><span class="sc0">
</span><span class="sc9">#define L_CODES (LITERALS+1+LENGTH_CODES)
</span><span class="sc2">// number of Literal or Length codes, including the END_BLOCK code
</span><span class="sc0">
</span><span class="sc9">#define D_CODES   30
</span><span class="sc2">// number of distance codes
</span><span class="sc0">
</span><span class="sc9">#define BL_CODES  19
</span><span class="sc2">// number of codes used to transfer the bit lengths
</span><span class="sc0">

</span><span class="sc9">#define STORED_BLOCK 0
#define STATIC_TREES 1
#define DYN_TREES    2
</span><span class="sc2">// The three kinds of block type
</span><span class="sc0">
</span><span class="sc9">#define LIT_BUFSIZE  0x8000
#define DIST_BUFSIZE  LIT_BUFSIZE
</span><span class="sc2">// Sizes of match buffers for literals/lengths and distances.  There are
// 4 reasons for limiting LIT_BUFSIZE to 64K:
//   - frequencies can be kept in 16 bit counters
//   - if compression is not successful for the first block, all input data is
//     still in the window so we can still emit a stored block even when input
//     comes from standard input.  (This can also be done for all blocks if
//     LIT_BUFSIZE is not greater than 32K.)
//   - if compression is not successful for a file smaller than 64K, we can
//     even emit a stored file instead of a stored block (saving 5 bytes).
//   - creating new Huffman trees less frequently may not provide fast
//     adaptation to changes in the input data statistics. (Take for
//     example a binary file with poorly compressible code followed by
//     a highly compressible string table.) Smaller buffer sizes give
//     fast adaptation but have of course the overhead of transmitting trees
//     more frequently.
//   - I can't count above 4
// The current code is general and allows DIST_BUFSIZE &lt; LIT_BUFSIZE (to save
// memory at the expense of compression). Some optimizations would be possible
// if we rely on DIST_BUFSIZE == LIT_BUFSIZE.
//
</span><span class="sc0">
</span><span class="sc9">#define REP_3_6      16
</span><span class="sc2">// repeat previous bit length 3-6 times (2 bits of repeat count)
</span><span class="sc0">
</span><span class="sc9">#define REPZ_3_10    17
</span><span class="sc2">// repeat a zero length 3-10 times  (3 bits of repeat count)
</span><span class="sc0">
</span><span class="sc9">#define REPZ_11_138  18
</span><span class="sc2">// repeat a zero length 11-138 times  (7 bits of repeat count)
</span><span class="sc0">
</span><span class="sc9">#define HEAP_SIZE (2*L_CODES+1)
</span><span class="sc2">// maximum heap size
</span><span class="sc0">

</span><span class="sc2">// ===========================================================================
// Local data used by the "bit string" routines.
//
</span><span class="sc0">
</span><span class="sc9">#define Buf_size (8 * 2*sizeof(char))
</span><span class="sc2">// Number of bits used within bi_buf. (bi_buf may be implemented on
// more than 16 bits on some systems.)
</span><span class="sc0">
</span><span class="sc2">// Output a 16 bit value to the bit stream, lower (oldest) byte first
</span><span class="sc9">#define PUTSHORT(state,w) \
{ if (state.bs.out_offset &gt;= state.bs.out_size-1) \
    state.flush_outbuf(state.param,state.bs.out_buf, &amp;state.bs.out_offset); \
  state.bs.out_buf[state.bs.out_offset++] = (char) ((w) &amp; 0xff); \
  state.bs.out_buf[state.bs.out_offset++] = (char) ((ush)(w) &gt;&gt; 8); \
}
</span><span class="sc0">
</span><span class="sc9">#define PUTBYTE(state,b) \
{ if (state.bs.out_offset &gt;= state.bs.out_size) \
    state.flush_outbuf(state.param,state.bs.out_buf, &amp;state.bs.out_offset); \
  state.bs.out_buf[state.bs.out_offset++] = (char) (b); \
}
</span><span class="sc0">
</span><span class="sc2">// DEFLATE.CPP HEADER
</span><span class="sc0">
</span><span class="sc9">#define HASH_BITS  15
</span><span class="sc2">// For portability to 16 bit machines, do not use values above 15.
</span><span class="sc0">
</span><span class="sc9">#define HASH_SIZE (unsigned)(1&lt;&lt;HASH_BITS)
#define HASH_MASK (HASH_SIZE-1)
#define WMASK     (WSIZE-1)
</span><span class="sc2">// HASH_SIZE and WSIZE must be powers of two
</span><span class="sc0">
</span><span class="sc9">#define NIL 0
</span><span class="sc2">// Tail of hash chains
</span><span class="sc0">
</span><span class="sc9">#define FAST 4
#define SLOW 2
</span><span class="sc2">// speed options for the general purpose bit flag
</span><span class="sc0">
</span><span class="sc9">#define TOO_FAR 4096
</span><span class="sc2">// Matches of length 3 are discarded if their distance exceeds TOO_FAR
</span><span class="sc0">


</span><span class="sc9">#define EQUAL 0
</span><span class="sc2">// result of memcmp for equal strings
</span><span class="sc0">

</span><span class="sc2">// ===========================================================================
// Local data used by the "longest match" routines.
</span><span class="sc0">
</span><span class="sc9">#define H_SHIFT  ((HASH_BITS+MIN_MATCH-1)/MIN_MATCH)
</span><span class="sc2">// Number of bits by which ins_h and del_h must be shifted at each
// input step. It must be such that after MIN_MATCH steps, the oldest
// byte no longer takes part in the hash key, that is:
//   H_SHIFT * MIN_MATCH &gt;= HASH_BITS
</span><span class="sc0">
</span><span class="sc9">#define max_insert_length  max_lazy_match
</span><span class="sc2">// Insert new strings in the hash table only if the match length
// is not greater than this length. This saves time but degrades compression.
// max_insert_length is used only for compression levels &lt;= 3.
</span><span class="sc0">


</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">extra_lbits</span><span class="sc10">[</span><span class="sc11">LENGTH_CODES</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc2">// extra bits for each length code
</span><span class="sc0">   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc4">2</span><span class="sc10">,</span><span class="sc4">2</span><span class="sc10">,</span><span class="sc4">2</span><span class="sc10">,</span><span class="sc4">2</span><span class="sc10">,</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc4">5</span><span class="sc10">,</span><span class="sc4">5</span><span class="sc10">,</span><span class="sc4">5</span><span class="sc10">,</span><span class="sc4">5</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">};</span><span class="sc0">

</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">extra_dbits</span><span class="sc10">[</span><span class="sc11">D_CODES</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc2">// extra bits for each distance code
</span><span class="sc0">   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc4">2</span><span class="sc10">,</span><span class="sc4">2</span><span class="sc10">,</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc4">5</span><span class="sc10">,</span><span class="sc4">5</span><span class="sc10">,</span><span class="sc4">6</span><span class="sc10">,</span><span class="sc4">6</span><span class="sc10">,</span><span class="sc4">7</span><span class="sc10">,</span><span class="sc4">7</span><span class="sc10">,</span><span class="sc4">8</span><span class="sc10">,</span><span class="sc4">8</span><span class="sc10">,</span><span class="sc4">9</span><span class="sc10">,</span><span class="sc4">9</span><span class="sc10">,</span><span class="sc4">10</span><span class="sc10">,</span><span class="sc4">10</span><span class="sc10">,</span><span class="sc4">11</span><span class="sc10">,</span><span class="sc4">11</span><span class="sc10">,</span><span class="sc4">12</span><span class="sc10">,</span><span class="sc4">12</span><span class="sc10">,</span><span class="sc4">13</span><span class="sc10">,</span><span class="sc4">13</span><span class="sc10">};</span><span class="sc0">

</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">extra_blbits</span><span class="sc10">[</span><span class="sc11">BL_CODES</span><span class="sc10">]</span><span class="sc2">// extra bits for each bit length code
</span><span class="sc0">   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">2</span><span class="sc10">,</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc4">7</span><span class="sc10">};</span><span class="sc0">

</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">bl_order</span><span class="sc10">[</span><span class="sc11">BL_CODES</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">16</span><span class="sc10">,</span><span class="sc4">17</span><span class="sc10">,</span><span class="sc4">18</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">8</span><span class="sc10">,</span><span class="sc4">7</span><span class="sc10">,</span><span class="sc4">9</span><span class="sc10">,</span><span class="sc4">6</span><span class="sc10">,</span><span class="sc4">10</span><span class="sc10">,</span><span class="sc4">5</span><span class="sc10">,</span><span class="sc4">11</span><span class="sc10">,</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc4">12</span><span class="sc10">,</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc4">13</span><span class="sc10">,</span><span class="sc4">2</span><span class="sc10">,</span><span class="sc4">14</span><span class="sc10">,</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc4">15</span><span class="sc10">};</span><span class="sc0">
</span><span class="sc2">// The lengths of the bit length codes are sent in order of decreasing
// probability, to avoid transmitting the lengths for unused bit length codes.
</span><span class="sc0">

</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">config</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
   </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">good_length</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// reduce lazy search above this match length
</span><span class="sc0">   </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">max_lazy</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc2">// do not perform lazy search above this match length
</span><span class="sc0">   </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">nice_length</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// quit search above this match length
</span><span class="sc0">   </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">max_chain</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">config</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc2">// Values for max_lazy_match, good_match, nice_match and max_chain_length,
// depending on the desired pack level (0..9). The values given below have
// been tuned to exclude worst case performance for pathological files.
// Better values may be found for specific files.
//
</span><span class="sc0">
</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">config</span><span class="sc0"> </span><span class="sc11">configuration_table</span><span class="sc10">[</span><span class="sc4">10</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
</span><span class="sc2">//  good lazy nice chain
</span><span class="sc0">    </span><span class="sc10">{</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0">  </span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">0</span><span class="sc10">},</span><span class="sc0">  </span><span class="sc2">// 0 store only
</span><span class="sc0">    </span><span class="sc10">{</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0">  </span><span class="sc4">8</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">4</span><span class="sc10">},</span><span class="sc0">  </span><span class="sc2">// 1 maximum speed, no lazy matches
</span><span class="sc0">    </span><span class="sc10">{</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">5</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">16</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">8</span><span class="sc10">},</span><span class="sc0">  </span><span class="sc2">// 2
</span><span class="sc0">    </span><span class="sc10">{</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">6</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">32</span><span class="sc10">,</span><span class="sc0">   </span><span class="sc4">32</span><span class="sc10">},</span><span class="sc0">  </span><span class="sc2">// 3
</span><span class="sc0">    </span><span class="sc10">{</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0">    </span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">16</span><span class="sc10">,</span><span class="sc0">   </span><span class="sc4">16</span><span class="sc10">},</span><span class="sc0">  </span><span class="sc2">// 4 lazy matches */
</span><span class="sc0">    </span><span class="sc10">{</span><span class="sc4">8</span><span class="sc10">,</span><span class="sc0">   </span><span class="sc4">16</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">32</span><span class="sc10">,</span><span class="sc0">   </span><span class="sc4">32</span><span class="sc10">},</span><span class="sc0">  </span><span class="sc2">// 5
</span><span class="sc0">    </span><span class="sc10">{</span><span class="sc4">8</span><span class="sc10">,</span><span class="sc0">   </span><span class="sc4">16</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">128</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">128</span><span class="sc10">},</span><span class="sc0">  </span><span class="sc2">// 6
</span><span class="sc0">    </span><span class="sc10">{</span><span class="sc4">8</span><span class="sc10">,</span><span class="sc0">   </span><span class="sc4">32</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">128</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">256</span><span class="sc10">},</span><span class="sc0">  </span><span class="sc2">// 7
</span><span class="sc0">    </span><span class="sc10">{</span><span class="sc4">32</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">128</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">258</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">1024</span><span class="sc10">},</span><span class="sc0"> </span><span class="sc2">// 8
</span><span class="sc0">    </span><span class="sc10">{</span><span class="sc4">32</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">258</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">258</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">4096</span><span class="sc10">}};</span><span class="sc2">// 9 maximum compression */
</span><span class="sc0">
</span><span class="sc2">// Note: the deflate() code requires max_lazy &gt;= MIN_MATCH and max_chain &gt;= 4
// For deflate_fast() (levels &lt;= 3) good is ignored and lazy has a different meaning.
</span><span class="sc0">




</span><span class="sc2">// Data structure describing a single value and its code string.
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">union</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">ush</span><span class="sc0">  </span><span class="sc11">freq</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc2">// frequency count
</span><span class="sc0">        </span><span class="sc11">ush</span><span class="sc0">  </span><span class="sc11">code</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc2">// bit string
</span><span class="sc0">    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">fc</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">union</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">ush</span><span class="sc0">  </span><span class="sc11">dad</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc2">// father node in Huffman tree
</span><span class="sc0">        </span><span class="sc11">ush</span><span class="sc0">  </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc2">// length of bit string
</span><span class="sc0">    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">dl</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">ct_data</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">dyn_tree</span><span class="sc10">;</span><span class="sc0">      </span><span class="sc2">// the dynamic tree
</span><span class="sc0">    </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">static_tree</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc2">// corresponding static tree or NULL
</span><span class="sc0">    </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">extra_bits</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc2">// extra bits for each code or NULL
</span><span class="sc0">    </span><span class="sc16">int</span><span class="sc0">     </span><span class="sc11">extra_base</span><span class="sc10">;</span><span class="sc0">     </span><span class="sc2">// base index for extra_bits
</span><span class="sc0">    </span><span class="sc16">int</span><span class="sc0">     </span><span class="sc11">elems</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc2">// max number of elements in the tree
</span><span class="sc0">    </span><span class="sc16">int</span><span class="sc0">     </span><span class="sc11">max_length</span><span class="sc10">;</span><span class="sc0">     </span><span class="sc2">// max bit length for the codes
</span><span class="sc0">    </span><span class="sc16">int</span><span class="sc0">     </span><span class="sc11">max_code</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc2">// largest code with non zero frequency
</span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">tree_desc</span><span class="sc10">;</span><span class="sc0">




</span><span class="sc16">class</span><span class="sc0"> </span><span class="sc11">TTreeState</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc16">public</span><span class="sc10">:</span><span class="sc0">
  </span><span class="sc11">TTreeState</span><span class="sc10">();</span><span class="sc0">

  </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc11">dyn_ltree</span><span class="sc10">[</span><span class="sc11">HEAP_SIZE</span><span class="sc10">];</span><span class="sc0">    </span><span class="sc2">// literal and length tree
</span><span class="sc0">  </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc11">dyn_dtree</span><span class="sc10">[</span><span class="sc4">2</span><span class="sc10">*</span><span class="sc11">D_CODES</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">];</span><span class="sc0">  </span><span class="sc2">// distance tree
</span><span class="sc0">  </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc11">static_ltree</span><span class="sc10">[</span><span class="sc11">L_CODES</span><span class="sc10">+</span><span class="sc4">2</span><span class="sc10">];</span><span class="sc0"> </span><span class="sc2">// the static literal tree...
</span><span class="sc0">  </span><span class="sc2">// ... Since the bit lengths are imposed, there is no need for the L_CODES
</span><span class="sc0">  </span><span class="sc2">// extra codes used during heap construction. However the codes 286 and 287
</span><span class="sc0">  </span><span class="sc2">// are needed to build a canonical tree (see ct_init below).
</span><span class="sc0">  </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc11">static_dtree</span><span class="sc10">[</span><span class="sc11">D_CODES</span><span class="sc10">];</span><span class="sc0"> </span><span class="sc2">// the static distance tree...
</span><span class="sc0">  </span><span class="sc2">// ... (Actually a trivial tree since all codes use 5 bits.)
</span><span class="sc0">  </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc11">bl_tree</span><span class="sc10">[</span><span class="sc4">2</span><span class="sc10">*</span><span class="sc11">BL_CODES</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">];</span><span class="sc0">  </span><span class="sc2">// Huffman tree for the bit lengths
</span><span class="sc0">
  </span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc11">l_desc</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc11">d_desc</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc11">bl_desc</span><span class="sc10">;</span><span class="sc0">

  </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">MAX_BITS</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">];</span><span class="sc0">  </span><span class="sc2">// number of codes at each bit length for an optimal tree
</span><span class="sc0">
  </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc4">2</span><span class="sc10">*</span><span class="sc11">L_CODES</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">];</span><span class="sc0"> </span><span class="sc2">// heap used to build the Huffman trees
</span><span class="sc0">  </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">heap_len</span><span class="sc10">;</span><span class="sc0">               </span><span class="sc2">// number of elements in the heap
</span><span class="sc0">  </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">heap_max</span><span class="sc10">;</span><span class="sc0">               </span><span class="sc2">// element of largest frequency
</span><span class="sc0">  </span><span class="sc2">// The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
</span><span class="sc0">  </span><span class="sc2">// The same heap array is used to build all trees.
</span><span class="sc0">
  </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">depth</span><span class="sc10">[</span><span class="sc4">2</span><span class="sc10">*</span><span class="sc11">L_CODES</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">];</span><span class="sc0">
  </span><span class="sc2">// Depth of each subtree used as tie breaker for trees of equal frequency
</span><span class="sc0">
  </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">length_code</span><span class="sc10">[</span><span class="sc11">MAX_MATCH</span><span class="sc10">-</span><span class="sc11">MIN_MATCH</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">];</span><span class="sc0">
  </span><span class="sc2">// length code for each normalized match length (0 == MIN_MATCH)
</span><span class="sc0">
  </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">dist_code</span><span class="sc10">[</span><span class="sc4">512</span><span class="sc10">];</span><span class="sc0">
  </span><span class="sc2">// distance codes. The first 256 values correspond to the distances
</span><span class="sc0">  </span><span class="sc2">// 3 .. 258, the last 256 values correspond to the top 8 bits of
</span><span class="sc0">  </span><span class="sc2">// the 15 bit distances.
</span><span class="sc0">
  </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">base_length</span><span class="sc10">[</span><span class="sc11">LENGTH_CODES</span><span class="sc10">];</span><span class="sc0">
  </span><span class="sc2">// First normalized length for each code (0 = MIN_MATCH)
</span><span class="sc0">
  </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">base_dist</span><span class="sc10">[</span><span class="sc11">D_CODES</span><span class="sc10">];</span><span class="sc0">
  </span><span class="sc2">// First normalized distance for each code (0 = distance of 1)
</span><span class="sc0">
  </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">far</span><span class="sc0"> </span><span class="sc11">l_buf</span><span class="sc10">[</span><span class="sc11">LIT_BUFSIZE</span><span class="sc10">];</span><span class="sc0">  </span><span class="sc2">// buffer for literals/lengths
</span><span class="sc0">  </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">far</span><span class="sc0"> </span><span class="sc11">d_buf</span><span class="sc10">[</span><span class="sc11">DIST_BUFSIZE</span><span class="sc10">];</span><span class="sc0"> </span><span class="sc2">// buffer for distances
</span><span class="sc0">
  </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">flag_buf</span><span class="sc10">[(</span><span class="sc11">LIT_BUFSIZE</span><span class="sc10">/</span><span class="sc4">8</span><span class="sc10">)];</span><span class="sc0">
  </span><span class="sc2">// flag_buf is a bit array distinguishing literals from lengths in
</span><span class="sc0">  </span><span class="sc2">// l_buf, and thus indicating the presence or absence of a distance.
</span><span class="sc0">
  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">last_lit</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc2">// running index in l_buf
</span><span class="sc0">  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">last_dist</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc2">// running index in d_buf
</span><span class="sc0">  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">last_flags</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc2">// running index in flag_buf
</span><span class="sc0">  </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">flags</span><span class="sc10">;</span><span class="sc0">            </span><span class="sc2">// current flags not yet saved in flag_buf
</span><span class="sc0">  </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">flag_bit</span><span class="sc10">;</span><span class="sc0">         </span><span class="sc2">// current bit used in flags
</span><span class="sc0">  </span><span class="sc2">// bits are filled in flags starting at bit 0 (least significant).
</span><span class="sc0">  </span><span class="sc2">// Note: these flags are overkill in the current code since we don't
</span><span class="sc0">  </span><span class="sc2">// take advantage of DIST_BUFSIZE == LIT_BUFSIZE.
</span><span class="sc0">
  </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">opt_len</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc2">// bit length of current block with optimal trees
</span><span class="sc0">  </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">static_len</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc2">// bit length of current block with static trees
</span><span class="sc0">
  </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">cmpr_bytelen</span><span class="sc10">;</span><span class="sc0">     </span><span class="sc2">// total byte length of compressed file
</span><span class="sc0">  </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">cmpr_len_bits</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc2">// number of bits past 'cmpr_bytelen'
</span><span class="sc0">
  </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">input_len</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc2">// total byte length of input file
</span><span class="sc0">  </span><span class="sc2">// input_len is for debugging only since we can get it by other means.
</span><span class="sc0">
  </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">file_type</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc2">// pointer to UNKNOWN, BINARY or ASCII
//  int *file_method;     // pointer to DEFLATE or STORE
</span><span class="sc10">};</span><span class="sc0">

</span><span class="sc11">TTreeState</span><span class="sc10">::</span><span class="sc11">TTreeState</span><span class="sc10">()</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc11">a</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc11">dyn_ltree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">static_ltree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">extra_lbits</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">LITERALS</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">L_CODES</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">MAX_BITS</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">};</span><span class="sc0">  </span><span class="sc11">l_desc</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">a</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc11">b</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc11">dyn_dtree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">static_dtree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">extra_dbits</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0">          </span><span class="sc11">D_CODES</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">MAX_BITS</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">};</span><span class="sc0">  </span><span class="sc11">d_desc</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">b</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc11">c</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc11">bl_tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc5">NULL</span><span class="sc10">,</span><span class="sc0">       </span><span class="sc11">extra_blbits</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0">         </span><span class="sc11">BL_CODES</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">MAX_BL_BITS</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">};</span><span class="sc0">  </span><span class="sc11">bl_desc</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">c</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">last_lit</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">last_dist</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">last_flags</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">



</span><span class="sc16">class</span><span class="sc0"> </span><span class="sc11">TBitState</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc16">public</span><span class="sc10">:</span><span class="sc0">

  </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">flush_flg</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc2">//
</span><span class="sc0">  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">bi_buf</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc2">// Output buffer. bits are inserted starting at the bottom (least significant
</span><span class="sc0">  </span><span class="sc2">// bits). The width of bi_buf must be at least 16 bits.
</span><span class="sc0">  </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">bi_valid</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc2">// Number of valid bits in bi_buf.  All bits above the last valid bit
</span><span class="sc0">  </span><span class="sc2">// are always zero.
</span><span class="sc0">  </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">out_buf</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc2">// Current output buffer.
</span><span class="sc0">  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">out_offset</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc2">// Current offset in output buffer.
</span><span class="sc0">  </span><span class="sc2">// On 16 bit machines, the buffer is limited to 64K.
</span><span class="sc0">  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">out_size</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc2">// Size of current output buffer
</span><span class="sc0">  </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">bits_sent</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc2">// bit length of the compressed data  only needed for debugging???
</span><span class="sc10">};</span><span class="sc0">







</span><span class="sc16">class</span><span class="sc0"> </span><span class="sc11">TDeflateState</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc16">public</span><span class="sc10">:</span><span class="sc0">
  </span><span class="sc11">TDeflateState</span><span class="sc10">()</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc11">window_size</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;}</span><span class="sc0">

  </span><span class="sc11">uch</span><span class="sc0">    </span><span class="sc11">window</span><span class="sc10">[</span><span class="sc4">2L</span><span class="sc10">*</span><span class="sc11">WSIZE</span><span class="sc10">];</span><span class="sc0">
  </span><span class="sc2">// Sliding window. Input bytes are read into the second half of the window,
</span><span class="sc0">  </span><span class="sc2">// and move to the first half later to keep a dictionary of at least WSIZE
</span><span class="sc0">  </span><span class="sc2">// bytes. With this organization, matches are limited to a distance of
</span><span class="sc0">  </span><span class="sc2">// WSIZE-MAX_MATCH bytes, but this ensures that IO is always
</span><span class="sc0">  </span><span class="sc2">// performed with a length multiple of the block size. Also, it limits
</span><span class="sc0">  </span><span class="sc2">// the window size to 64K, which is quite useful on MSDOS.
</span><span class="sc0">  </span><span class="sc2">// To do: limit the window size to WSIZE+CBSZ if SMALL_MEM (the code would
</span><span class="sc0">  </span><span class="sc2">// be less efficient since the data would have to be copied WSIZE/CBSZ times)
</span><span class="sc0">  </span><span class="sc11">Pos</span><span class="sc0">    </span><span class="sc11">prev</span><span class="sc10">[</span><span class="sc11">WSIZE</span><span class="sc10">];</span><span class="sc0">
  </span><span class="sc2">// Link to older string with same hash index. To limit the size of this
</span><span class="sc0">  </span><span class="sc2">// array to 64K, this link is maintained only for the last 32K strings.
</span><span class="sc0">  </span><span class="sc2">// An index in this array is thus a window index modulo 32K.
</span><span class="sc0">  </span><span class="sc11">Pos</span><span class="sc0">    </span><span class="sc11">head</span><span class="sc10">[</span><span class="sc11">HASH_SIZE</span><span class="sc10">];</span><span class="sc0">
  </span><span class="sc2">// Heads of the hash chains or NIL. If your compiler thinks that
</span><span class="sc0">  </span><span class="sc2">// HASH_SIZE is a dynamic value, recompile with -DDYN_ALLOC.
</span><span class="sc0">
  </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">window_size</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc2">// window size, 2*WSIZE except for MMAP or BIG_MEM, where it is the
</span><span class="sc0">  </span><span class="sc2">// input file length plus MIN_LOOKAHEAD.
</span><span class="sc0">
  </span><span class="sc16">long</span><span class="sc0"> </span><span class="sc11">block_start</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc2">// window position at the beginning of the current output block. Gets
</span><span class="sc0">  </span><span class="sc2">// negative when the window is moved backwards.
</span><span class="sc0">
  </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">sliding</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc2">// Set to false when the input file is already in memory
</span><span class="sc0">
  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">ins_h</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc2">// hash index of string to be inserted
</span><span class="sc0">
  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">prev_length</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc2">// Length of the best match at previous step. Matches not greater than this
</span><span class="sc0">  </span><span class="sc2">// are discarded. This is used in the lazy match evaluation.
</span><span class="sc0">
  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">strstart</span><span class="sc10">;</span><span class="sc0">         </span><span class="sc2">// start of string to insert
</span><span class="sc0">  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">match_start</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// start of matching string
</span><span class="sc0">  </span><span class="sc16">int</span><span class="sc0">      </span><span class="sc11">eofile</span><span class="sc10">;</span><span class="sc0">           </span><span class="sc2">// flag set at end of input file
</span><span class="sc0">  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">lookahead</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc2">// number of valid bytes ahead in window
</span><span class="sc0">
  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">max_chain_length</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc2">// To speed up deflation, hash chains are never searched beyond this length.
</span><span class="sc0">  </span><span class="sc2">// A higher limit improves compression ratio but degrades the speed.
</span><span class="sc0">
  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_lazy_match</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc2">// Attempt to find a better match only when the current match is strictly
</span><span class="sc0">  </span><span class="sc2">// smaller than this value. This mechanism is used only for compression
</span><span class="sc0">  </span><span class="sc2">// levels &gt;= 4.
</span><span class="sc0">
  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">good_match</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc2">// Use a faster search when the previous match is longer than this
</span><span class="sc0">
  </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">nice_match</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// Stop searching when current match exceeds this
</span><span class="sc10">};</span><span class="sc0">


</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">iztimes</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
  </span><span class="sc11">time_t</span><span class="sc0"> </span><span class="sc11">atime</span><span class="sc10">,</span><span class="sc11">mtime</span><span class="sc10">,</span><span class="sc11">ctime</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">iztimes</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// access, modify, create times
</span><span class="sc0">
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">zlist</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
  </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">vem</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ver</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">flg</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">how</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc2">// See central header in zipfile.c for what vem..off are
</span><span class="sc0">  </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">tim</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">crc</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">siz</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">extent</span><span class="sc0"> </span><span class="sc11">nam</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ext</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">cext</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">com</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc2">// offset of ext must be &gt;= LOCHEAD
</span><span class="sc0">  </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">dsk</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">att</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">lflg</span><span class="sc10">;</span><span class="sc0">           </span><span class="sc2">// offset of lflg must be &gt;= LOCHEAD
</span><span class="sc0">  </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">atx</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">off</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc11">name</span><span class="sc10">[</span><span class="sc11">MAX_PATH</span><span class="sc10">];</span><span class="sc0">                   </span><span class="sc2">// File name in zip file
</span><span class="sc0">  </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">extra</span><span class="sc10">;</span><span class="sc0">                  </span><span class="sc2">// Extra field (set only if ext != 0)
</span><span class="sc0">  </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">cextra</span><span class="sc10">;</span><span class="sc0">                 </span><span class="sc2">// Extra in central (set only if cext != 0)
</span><span class="sc0">  </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">comment</span><span class="sc10">;</span><span class="sc0">                </span><span class="sc2">// Comment (set only if com != 0)
</span><span class="sc0">  </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc11">iname</span><span class="sc10">[</span><span class="sc11">MAX_PATH</span><span class="sc10">];</span><span class="sc0">                  </span><span class="sc2">// Internal file name after cleanup
</span><span class="sc0">  </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc11">zname</span><span class="sc10">[</span><span class="sc11">MAX_PATH</span><span class="sc10">];</span><span class="sc0">                  </span><span class="sc2">// External version of internal name
</span><span class="sc0">  </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">mark</span><span class="sc10">;</span><span class="sc0">                     </span><span class="sc2">// Marker for files to operate on
</span><span class="sc0">  </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">trash</span><span class="sc10">;</span><span class="sc0">                    </span><span class="sc2">// Marker for files to delete
</span><span class="sc0">  </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">dosflag</span><span class="sc10">;</span><span class="sc0">                  </span><span class="sc2">// Set to force MSDOS file attributes
</span><span class="sc0">  </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">zlist</span><span class="sc0"> </span><span class="sc11">far</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">nxt</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc2">// Pointer to next header in list
</span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">TZipFileInfo</span><span class="sc10">;</span><span class="sc0">


</span><span class="sc16">class</span><span class="sc0"> </span><span class="sc11">TState</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc10">(*</span><span class="sc11">READFUNC</span><span class="sc10">)(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc10">(*</span><span class="sc11">FLUSHFUNC</span><span class="sc10">)(</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">param</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">size</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc10">(*</span><span class="sc11">WRITEFUNC</span><span class="sc10">)(</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">param</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc16">class</span><span class="sc0"> </span><span class="sc11">TState</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc16">public</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">TState</span><span class="sc10">()</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc11">err</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;}</span><span class="sc0">
  </span><span class="sc2">//
</span><span class="sc0">  </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">param</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">level</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc16">bool</span><span class="sc0"> </span><span class="sc11">seekable</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">READFUNC</span><span class="sc0"> </span><span class="sc11">readfunc</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">FLUSHFUNC</span><span class="sc0"> </span><span class="sc11">flush_outbuf</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">TTreeState</span><span class="sc0"> </span><span class="sc11">ts</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">TBitState</span><span class="sc0"> </span><span class="sc11">bs</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">TDeflateState</span><span class="sc0"> </span><span class="sc11">ds</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">err</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">};</span><span class="sc0">









</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc16">bool</span><span class="sc0"> </span><span class="sc11">cond</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">msg</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">cond</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">err</span><span class="sc10">=</span><span class="sc11">msg</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">__cdecl</span><span class="sc0"> </span><span class="sc11">Trace</span><span class="sc10">(</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">x</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">...)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc11">va_list</span><span class="sc0"> </span><span class="sc11">paramList</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">va_start</span><span class="sc10">(</span><span class="sc11">paramList</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">x</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc11">paramList</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">va_end</span><span class="sc10">(</span><span class="sc11">paramList</span><span class="sc10">);}</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">__cdecl</span><span class="sc0"> </span><span class="sc11">Tracec</span><span class="sc10">(</span><span class="sc16">bool</span><span class="sc0"> </span><span class="sc10">,</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">x</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">...)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc11">va_list</span><span class="sc0"> </span><span class="sc11">paramList</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">va_start</span><span class="sc10">(</span><span class="sc11">paramList</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">x</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc11">paramList</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">va_end</span><span class="sc10">(</span><span class="sc11">paramList</span><span class="sc10">);}</span><span class="sc0">



</span><span class="sc2">// ===========================================================================
// Local (static) routines in this file.
//
</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">init_block</span><span class="sc0">     </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;);</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">pqdownheap</span><span class="sc0">     </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;,</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">k</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">gen_bitlen</span><span class="sc0">     </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;,</span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">desc</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">gen_codes</span><span class="sc0">      </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">build_tree</span><span class="sc0">     </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;,</span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">desc</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">scan_tree</span><span class="sc0">      </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;,</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">send_tree</span><span class="sc0">      </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc16">int</span><span class="sc0">  </span><span class="sc11">build_bl_tree</span><span class="sc0">  </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;);</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">send_all_trees</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">lcodes</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">dcodes</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">blcodes</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">compress_block</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">ltree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">dtree</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">set_file_type</span><span class="sc0">  </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;);</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">send_bits</span><span class="sc0">      </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">value</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">bi_reverse</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">bi_windup</span><span class="sc0">      </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">copy_block</span><span class="sc0">     </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">header</span><span class="sc10">);</span><span class="sc0">


</span><span class="sc9">#define send_code(state, c, tree) send_bits(state, tree[c].fc.code, tree[c].dl.len)
</span><span class="sc2">// Send a code of the given tree. c and tree must not have side effects
</span><span class="sc0">
</span><span class="sc2">// alternatively...
//#define send_code(state, c, tree)
//     { if (state.verbose&gt;1) fprintf(stderr,"\ncd %3d ",(c));
//       send_bits(state, tree[c].fc.code, tree[c].dl.len); }
</span><span class="sc0">
</span><span class="sc9">#define d_code(dist) ((dist) &lt; 256 ? state.ts.dist_code[dist] : state.ts.dist_code[256+((dist)&gt;&gt;7)])
</span><span class="sc2">// Mapping from a distance to a distance code. dist is the distance - 1 and
// must not have side effects. dist_code[256] and dist_code[257] are never used.
</span><span class="sc0">
</span><span class="sc9">#define Max(a,b) (a &gt;= b ? a : b)
</span><span class="sc1">/* the arguments must not have side effects */</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Allocate the match buffer, initialize the various tables and save the
 * location of the internal file attribute (ascii/binary) and method
 * (DEFLATE/STORE).
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">ct_init</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">attr</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc1">/* iterates over tree elements */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">;</span><span class="sc0">     </span><span class="sc1">/* bit counter */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc1">/* length value */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc10">;</span><span class="sc0">     </span><span class="sc1">/* code value */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">dist</span><span class="sc10">;</span><span class="sc0">     </span><span class="sc1">/* distance index */</span><span class="sc0">

    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">file_type</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">attr</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc2">//state.ts.file_method = method;
</span><span class="sc0">    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">cmpr_bytelen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">cmpr_len_bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0L</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">input_len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0L</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_dtree</span><span class="sc10">[</span><span class="sc4">0</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* ct_init already called */</span><span class="sc0">

    </span><span class="sc1">/* Initialize the mapping length (0..255) -&gt; length code (0..28) */</span><span class="sc0">
    </span><span class="sc11">length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">LENGTH_CODES</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">base_length</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc4">1</span><span class="sc10">&lt;&lt;</span><span class="sc11">extra_lbits</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">]);</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">length_code</span><span class="sc10">[</span><span class="sc11">length</span><span class="sc10">++]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uch</span><span class="sc10">)</span><span class="sc11">code</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">length</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">256</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"ct_init: length != 256"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc1">/* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">length_code</span><span class="sc10">[</span><span class="sc11">length</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uch</span><span class="sc10">)</span><span class="sc11">code</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* Initialize the mapping dist (0..32K) -&gt; dist code (0..29) */</span><span class="sc0">
    </span><span class="sc11">dist</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">16</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">base_dist</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">dist</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc4">1</span><span class="sc10">&lt;&lt;</span><span class="sc11">extra_dbits</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">]);</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">dist_code</span><span class="sc10">[</span><span class="sc11">dist</span><span class="sc10">++]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uch</span><span class="sc10">)</span><span class="sc11">code</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">dist</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">256</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"ct_init: dist != 256"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">dist</span><span class="sc0"> </span><span class="sc10">&gt;&gt;=</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* from now on, all distances are divided by 128 */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc0"> </span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">D_CODES</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">base_dist</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">dist</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc4">1</span><span class="sc10">&lt;&lt;(</span><span class="sc11">extra_dbits</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">]-</span><span class="sc4">7</span><span class="sc10">));</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">dist_code</span><span class="sc10">[</span><span class="sc4">256</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">dist</span><span class="sc10">++]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uch</span><span class="sc10">)</span><span class="sc11">code</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">dist</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">256</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"ct_init: 256+dist != 512"</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc1">/* Construct the codes of the static literal tree */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">MAX_BITS</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">bits</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">143</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_ltree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">++].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc4">8</span><span class="sc10">]++;</span><span class="sc0">
    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">255</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_ltree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">++].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">9</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc4">9</span><span class="sc10">]++;</span><span class="sc0">
    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">279</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_ltree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">++].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc4">7</span><span class="sc10">]++;</span><span class="sc0">
    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">287</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_ltree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">++].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc4">8</span><span class="sc10">]++;</span><span class="sc0">
    </span><span class="sc1">/* fc.codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */</span><span class="sc0">
    </span><span class="sc11">gen_codes</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,(</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_ltree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">L_CODES</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc1">/* The static distance tree is trivial: */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">D_CODES</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_dtree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">5</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_dtree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">bi_reverse</span><span class="sc10">(</span><span class="sc11">n</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">5</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc1">/* Initialize the first block of the first file: */</span><span class="sc0">
    </span><span class="sc11">init_block</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Initialize a new block.
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">init_block</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* iterates over tree elements */</span><span class="sc0">

    </span><span class="sc1">/* Initialize the trees. */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">L_CODES</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">dyn_ltree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">D_CODES</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">dyn_dtree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">BL_CODES</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">dyn_ltree</span><span class="sc10">[</span><span class="sc11">END_BLOCK</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">opt_len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0L</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_lit</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_dist</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_flags</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">flag_bit</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc9">#define SMALLEST 1
</span><span class="sc1">/* Index within the heap array of least frequent node in the Huffman tree */</span><span class="sc0">


</span><span class="sc1">/* ===========================================================================
 * Remove the smallest element from the heap and recreate the heap with
 * one less element. Updates heap and heap_len.
 */</span><span class="sc0">
</span><span class="sc9">#define pqremove(tree, top) \
{\
    top = state.ts.heap[SMALLEST]; \
    state.ts.heap[SMALLEST] = state.ts.heap[state.ts.heap_len--]; \
    pqdownheap(state,tree, SMALLEST); \
}
</span><span class="sc0">
</span><span class="sc1">/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */</span><span class="sc0">
</span><span class="sc9">#define smaller(tree, n, m) \
   (tree[n].fc.freq &lt; tree[m].fc.freq || \
   (tree[n].fc.freq == tree[m].fc.freq &amp;&amp; state.ts.depth[n] &lt;= state.ts.depth[m]))
</span><span class="sc0">
</span><span class="sc1">/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">pqdownheap</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">k</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">v</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">k</span><span class="sc10">];</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">j</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">k</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* left son of k */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">htemp</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc1">/* required because of bug in SASC compiler */</span><span class="sc0">

    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">j</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap_len</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc1">/* Set j to the smallest of the two sons: */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">j</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap_len</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">smaller</span><span class="sc10">(</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">j</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">],</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">j</span><span class="sc10">]))</span><span class="sc0"> </span><span class="sc11">j</span><span class="sc10">++;</span><span class="sc0">

        </span><span class="sc1">/* Exit if v is smaller than both sons */</span><span class="sc0">
        </span><span class="sc11">htemp</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">j</span><span class="sc10">];</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">smaller</span><span class="sc10">(</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">v</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">htemp</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc1">/* Exchange v with the smallest son */</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">k</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">htemp</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">k</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">j</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc1">/* And continue down the tree, setting j to the left son of k */</span><span class="sc0">
        </span><span class="sc11">j</span><span class="sc0"> </span><span class="sc10">&lt;&lt;=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">k</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">v</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">gen_bitlen</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">desc</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc0">  </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">dyn_tree</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">extra</span><span class="sc0">     </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">extra_bits</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">base</span><span class="sc0">            </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">extra_base</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc0">        </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">max_code</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_length</span><span class="sc0">      </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">max_length</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">stree</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">static_tree</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">h</span><span class="sc10">;</span><span class="sc0">              </span><span class="sc1">/* heap index */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">m</span><span class="sc10">;</span><span class="sc0">           </span><span class="sc1">/* iterate over the tree elements */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">;</span><span class="sc0">           </span><span class="sc1">/* bit length */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">xbits</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* extra bits */</span><span class="sc0">
    </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">;</span><span class="sc0">              </span><span class="sc1">/* frequency */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">overflow</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc1">/* number of elements with bit length too large */</span><span class="sc0">

    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">MAX_BITS</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">bits</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */</span><span class="sc0">
    </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap_max</span><span class="sc10">]].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* root of the heap */</span><span class="sc0">

    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">h</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap_max</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">h</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">HEAP_SIZE</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">h</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">h</span><span class="sc10">];</span><span class="sc0">
        </span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">dad</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">max_length</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">max_length</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">overflow</span><span class="sc10">++;</span><span class="sc0">
        </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">bits</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc1">/* We overwrite tree[n].dl.dad which is no longer needed */</span><span class="sc0">

        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">continue</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* not a leaf node */</span><span class="sc0">

        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">bits</span><span class="sc10">]++;</span><span class="sc0">
        </span><span class="sc11">xbits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">base</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">xbits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">extra</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">-</span><span class="sc11">base</span><span class="sc10">];</span><span class="sc0">
        </span><span class="sc11">f</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">opt_len</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">f</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">xbits</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stree</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_len</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">f</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">xbits</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">overflow</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">Trace</span><span class="sc10">(</span><span class="sc6">"\nbit length overflow\n"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc1">/* This happens for example on obj2 and pic of the Calgary corpus */</span><span class="sc0">

    </span><span class="sc1">/* Find the first bit length which could increase: */</span><span class="sc0">
    </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">max_length</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">bits</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">--;</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">bits</span><span class="sc10">]--;</span><span class="sc0">           </span><span class="sc1">/* move one leaf down the tree */</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">bits</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* move one overflow item as its brother */</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">max_length</span><span class="sc10">]--;</span><span class="sc0">
        </span><span class="sc1">/* The brother of the overflow item also moves one step up,
         * but this does not affect bl_count[max_length]
         */</span><span class="sc0">
        </span><span class="sc11">overflow</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">overflow</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc1">/* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">max_length</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">--)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">bits</span><span class="sc10">];</span><span class="sc0">
        </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">m</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap</span><span class="sc10">[--</span><span class="sc11">h</span><span class="sc10">];</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">m</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">continue</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">m</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">bits</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">Trace</span><span class="sc10">(</span><span class="sc6">"code %d bits %d-&gt;%d\n"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">m</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">m</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">);</span><span class="sc0">
                </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">opt_len</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc16">long</span><span class="sc10">)</span><span class="sc11">bits</span><span class="sc10">-(</span><span class="sc16">long</span><span class="sc10">)</span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">m</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc10">)*(</span><span class="sc16">long</span><span class="sc10">)</span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">m</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc10">;</span><span class="sc0">
                </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">m</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">bits</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc11">n</span><span class="sc10">--;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">gen_codes</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">next_code</span><span class="sc10">[</span><span class="sc11">MAX_BITS</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">];</span><span class="sc0"> </span><span class="sc1">/* next code value for each bit length */</span><span class="sc0">
    </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">              </span><span class="sc1">/* running code value */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">;</span><span class="sc0">                  </span><span class="sc1">/* bit index */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0">                     </span><span class="sc1">/* code index */</span><span class="sc0">

    </span><span class="sc1">/* The distribution counts are first used to generate the code values
     * without bit reversal.
     */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">MAX_BITS</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bits</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">next_code</span><span class="sc10">[</span><span class="sc11">bits</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)((</span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">bits</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">])</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc1">/* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_count</span><span class="sc10">[</span><span class="sc11">MAX_BITS</span><span class="sc10">]-</span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc4">1</span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">MAX_BITS</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0">
            </span><span class="sc6">"inconsistent bit counts"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">Trace</span><span class="sc10">(</span><span class="sc6">"\ngen_codes: max_code %d "</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">continue</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc1">/* Now reverse the bits */</span><span class="sc0">
        </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">bi_reverse</span><span class="sc10">(</span><span class="sc11">next_code</span><span class="sc10">[</span><span class="sc11">len</span><span class="sc10">]++,</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc2">//Tracec(tree != state.ts.static_ltree, "\nn %3d %c l %2d c %4x (%x) ", n, (isgraph(n) ? n : ' '), len, tree[n].fc.code, next_code[len]-1);
</span><span class="sc0">    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">build_tree</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">desc</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc0">   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">dyn_tree</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">stree</span><span class="sc0">  </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">static_tree</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">elems</span><span class="sc0">            </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">elems</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">m</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* iterate over heap elements */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* largest code with non zero frequency */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">node</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">elems</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* next internal node of the tree */</span><span class="sc0">

    </span><span class="sc1">/* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap_len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap_max</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">HEAP_SIZE</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">elems</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap</span><span class="sc10">[++</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap_len</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">depth</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc1">/* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */</span><span class="sc0">
    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap_len</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">newcp</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap</span><span class="sc10">[++</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap_len</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">max_code</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc10">++</span><span class="sc11">max_code</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">newcp</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">depth</span><span class="sc10">[</span><span class="sc11">newcp</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">opt_len</span><span class="sc10">--;</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stree</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_len</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc11">stree</span><span class="sc10">[</span><span class="sc11">newcp</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc1">/* new is 0 or 1 so it does not have extra bits */</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">desc</span><span class="sc10">-&gt;</span><span class="sc11">max_code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap_len</span><span class="sc10">/</span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">--)</span><span class="sc0"> </span><span class="sc11">pqdownheap</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc1">/* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */</span><span class="sc0">
    </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">pqremove</span><span class="sc10">(</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">);</span><span class="sc0">   </span><span class="sc1">/* n = node of least frequency */</span><span class="sc0">
        </span><span class="sc11">m</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">SMALLEST</span><span class="sc10">];</span><span class="sc0">  </span><span class="sc1">/* m = node of next least frequency */</span><span class="sc0">

        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap</span><span class="sc10">[--</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap_max</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* keep the nodes sorted by frequency */</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap</span><span class="sc10">[--</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap_max</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">m</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc1">/* Create a new node father of n and m */</span><span class="sc0">
        </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">node</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)(</span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">m</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">depth</span><span class="sc10">[</span><span class="sc11">node</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uch</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Max</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">depth</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">],</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">depth</span><span class="sc10">[</span><span class="sc11">m</span><span class="sc10">])</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">dad</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">m</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">dad</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">node</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc1">/* and insert the new node in the heap */</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">SMALLEST</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">node</span><span class="sc10">++;</span><span class="sc0">
        </span><span class="sc11">pqdownheap</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">SMALLEST</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap_len</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap</span><span class="sc10">[--</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap_max</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">heap</span><span class="sc10">[</span><span class="sc11">SMALLEST</span><span class="sc10">];</span><span class="sc0">

    </span><span class="sc1">/* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */</span><span class="sc0">
    </span><span class="sc11">gen_bitlen</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,(</span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">desc</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc1">/* The field len is now set, we can generate the bit codes */</span><span class="sc0">
    </span><span class="sc11">gen_codes</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,(</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree. Updates opt_len to take into account the repeat
 * counts. (The contribution of the bit length codes will be added later
 * during the construction of bl_tree.)
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">scan_tree</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0">                     </span><span class="sc1">/* iterates over all tree elements */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">prevlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* last emitted length */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">curlen</span><span class="sc10">;</span><span class="sc0">                </span><span class="sc1">/* length of current code */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc4">0</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* length of next code */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">             </span><span class="sc1">/* repeat count of the current code */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">;</span><span class="sc0">         </span><span class="sc1">/* max repeat count */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">;</span><span class="sc0">         </span><span class="sc1">/* min repeat count */</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">nextlen</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">138</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">max_code</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* guard */</span><span class="sc0">

    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(++</span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc5">continue</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_tree</span><span class="sc10">[</span><span class="sc11">curlen</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_tree</span><span class="sc10">[</span><span class="sc11">curlen</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">count</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">prevlen</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_tree</span><span class="sc10">[</span><span class="sc11">curlen</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc10">++;</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_tree</span><span class="sc10">[</span><span class="sc11">REP_3_6</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc10">++;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">10</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_tree</span><span class="sc10">[</span><span class="sc11">REPZ_3_10</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc10">++;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_tree</span><span class="sc10">[</span><span class="sc11">REPZ_11_138</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc10">++;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">prevlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">curlen</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">nextlen</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">138</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">6</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">send_tree</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0">                     </span><span class="sc1">/* iterates over all tree elements */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">prevlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* last emitted length */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">curlen</span><span class="sc10">;</span><span class="sc0">                </span><span class="sc1">/* length of current code */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc4">0</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* length of next code */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">             </span><span class="sc1">/* repeat count of the current code */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">;</span><span class="sc0">         </span><span class="sc1">/* max repeat count */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">;</span><span class="sc0">         </span><span class="sc1">/* min repeat count */</span><span class="sc0">

    </span><span class="sc1">/* tree[max_code+1].dl.len = -1; */</span><span class="sc0">  </span><span class="sc1">/* guard already set */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">nextlen</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">138</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">max_code</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">tree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(++</span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc5">continue</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">curlen</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_tree</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(--</span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">prevlen</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">curlen</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_tree</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc11">count</span><span class="sc10">--;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">6</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">" 3_6?"</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">REP_3_6</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_tree</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">count</span><span class="sc10">-</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">10</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">REPZ_3_10</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_tree</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">count</span><span class="sc10">-</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">REPZ_11_138</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_tree</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">count</span><span class="sc10">-</span><span class="sc4">11</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc11">count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">prevlen</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">curlen</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">nextlen</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">138</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">curlen</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">nextlen</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">6</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">max_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">min_count</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */</span><span class="sc0">
</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">build_bl_tree</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_blindex</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* index of last bit length code of non zero freq */</span><span class="sc0">

    </span><span class="sc1">/* Determine the bit length frequencies for literal and distance trees */</span><span class="sc0">
    </span><span class="sc11">scan_tree</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,(</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">dyn_ltree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">l_desc</span><span class="sc10">.</span><span class="sc11">max_code</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">scan_tree</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,(</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">dyn_dtree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">d_desc</span><span class="sc10">.</span><span class="sc11">max_code</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc1">/* Build the bit length tree: */</span><span class="sc0">
    </span><span class="sc11">build_tree</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,(</span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc10">*)(&amp;</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_desc</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc1">/* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */</span><span class="sc0">

    </span><span class="sc1">/* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">max_blindex</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">BL_CODES</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">max_blindex</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">max_blindex</span><span class="sc10">--)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_tree</span><span class="sc10">[</span><span class="sc11">bl_order</span><span class="sc10">[</span><span class="sc11">max_blindex</span><span class="sc10">]].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc1">/* Update opt_len to include the bit length tree and counts */</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">opt_len</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">*(</span><span class="sc11">max_blindex</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">5</span><span class="sc10">+</span><span class="sc4">5</span><span class="sc10">+</span><span class="sc4">4</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">Trace</span><span class="sc10">(</span><span class="sc6">"\ndyn trees: dyn %ld, stat %ld"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">opt_len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_len</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">max_blindex</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes &gt;= 257, dcodes &gt;= 1, blcodes &gt;= 4.
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">send_all_trees</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">lcodes</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">dcodes</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">blcodes</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">rank</span><span class="sc10">;</span><span class="sc0">                    </span><span class="sc1">/* index in bl_order */</span><span class="sc0">

    </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">lcodes</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">257</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">dcodes</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">blcodes</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"not enough codes"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">lcodes</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">L_CODES</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">dcodes</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">D_CODES</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">blcodes</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">BL_CODES</span><span class="sc10">,</span><span class="sc0">
            </span><span class="sc6">"too many codes"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">Trace</span><span class="sc10">(</span><span class="sc6">"\nbl counts: "</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">lcodes</span><span class="sc10">-</span><span class="sc4">257</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">5</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc1">/* not +255 as stated in appnote.txt 1.93a or -256 in 2.04c */</span><span class="sc0">
    </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">dcodes</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0">   </span><span class="sc4">5</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">blcodes</span><span class="sc10">-</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc0">  </span><span class="sc4">4</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc1">/* not -3 as stated in appnote.txt */</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">rank</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">rank</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">blcodes</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">rank</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">Trace</span><span class="sc10">(</span><span class="sc6">"\nbl code %2d "</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">bl_order</span><span class="sc10">[</span><span class="sc11">rank</span><span class="sc10">]);</span><span class="sc0">
        </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">bl_tree</span><span class="sc10">[</span><span class="sc11">bl_order</span><span class="sc10">[</span><span class="sc11">rank</span><span class="sc10">]].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">    
    </span><span class="sc11">Trace</span><span class="sc10">(</span><span class="sc6">"\nbl tree: sent %ld"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bits_sent</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">send_tree</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,(</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">dyn_ltree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">lcodes</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc1">/* send the literal tree */</span><span class="sc0">
    </span><span class="sc11">Trace</span><span class="sc10">(</span><span class="sc6">"\nlit tree: sent %ld"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bits_sent</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">send_tree</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,(</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">dyn_dtree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">dcodes</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc1">/* send the distance tree */</span><span class="sc0">
    </span><span class="sc11">Trace</span><span class="sc10">(</span><span class="sc6">"\ndist tree: sent %ld"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bits_sent</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file. This function
 * returns the total compressed length (in bytes) for the file so far.
 */</span><span class="sc0">
</span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">flush_block</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">stored_len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">eof</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">opt_lenb</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">static_lenb</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* opt_len and static_len in bytes */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">max_blindex</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* index of last bit length code of non zero freq */</span><span class="sc0">

    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">flag_buf</span><span class="sc10">[</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_flags</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">flags</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* Save the flags for the last 8 items */</span><span class="sc0">

     </span><span class="sc1">/* Check if the file is ascii or binary */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(*</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">file_type</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">UNKNOWN</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">set_file_type</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc1">/* Construct the literal and distance trees */</span><span class="sc0">
    </span><span class="sc11">build_tree</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,(</span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc10">*)(&amp;</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">l_desc</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc11">Trace</span><span class="sc10">(</span><span class="sc6">"\nlit data: dyn %ld, stat %ld"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">opt_len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_len</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">build_tree</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,(</span><span class="sc11">tree_desc</span><span class="sc0"> </span><span class="sc10">*)(&amp;</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">d_desc</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc11">Trace</span><span class="sc10">(</span><span class="sc6">"\ndist data: dyn %ld, stat %ld"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">opt_len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_len</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc1">/* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */</span><span class="sc0">

    </span><span class="sc1">/* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */</span><span class="sc0">
    </span><span class="sc11">max_blindex</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">build_bl_tree</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc1">/* Determine the best encoding. Compute first the block length in bytes */</span><span class="sc0">
    </span><span class="sc11">opt_lenb</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">opt_len</span><span class="sc10">+</span><span class="sc4">3</span><span class="sc10">+</span><span class="sc4">7</span><span class="sc10">)&gt;&gt;</span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">static_lenb</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_len</span><span class="sc10">+</span><span class="sc4">3</span><span class="sc10">+</span><span class="sc4">7</span><span class="sc10">)&gt;&gt;</span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">input_len</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">stored_len</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* for debugging only */</span><span class="sc0">

    </span><span class="sc11">Trace</span><span class="sc10">(</span><span class="sc6">"\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u "</span><span class="sc10">,</span><span class="sc0">
            </span><span class="sc11">opt_lenb</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">opt_len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">static_lenb</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">stored_len</span><span class="sc10">,</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_lit</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_dist</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">static_lenb</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">opt_lenb</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">opt_lenb</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">static_lenb</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc2">// Originally, zip allowed the file to be transformed from a compressed
</span><span class="sc0">    </span><span class="sc2">// into a stored file in the case where compression failed, there
</span><span class="sc0">    </span><span class="sc2">// was only one block, and it was allowed to change. I've removed this
</span><span class="sc0">    </span><span class="sc2">// possibility since the code's cleaner if no changes are allowed.
</span><span class="sc0">    </span><span class="sc2">//if (stored_len &lt;= opt_lenb &amp;&amp; eof &amp;&amp; state.ts.cmpr_bytelen == 0L
</span><span class="sc0">    </span><span class="sc2">//   &amp;&amp; state.ts.cmpr_len_bits == 0L &amp;&amp; state.seekable)
</span><span class="sc0">    </span><span class="sc2">//{   // &amp;&amp; state.ts.file_method != NULL
</span><span class="sc0">    </span><span class="sc2">//    // Since LIT_BUFSIZE &lt;= 2*WSIZE, the input data must be there:
</span><span class="sc0">    </span><span class="sc2">//    Assert(state,buf!=NULL,"block vanished");
</span><span class="sc0">    </span><span class="sc2">//    copy_block(state,buf, (unsigned)stored_len, 0); // without header
</span><span class="sc0">    </span><span class="sc2">//    state.ts.cmpr_bytelen = stored_len;
</span><span class="sc0">    </span><span class="sc2">//    Assert(state,false,"unimplemented *state.ts.file_method = STORE;");
</span><span class="sc0">    </span><span class="sc2">//    //*state.ts.file_method = STORE;
</span><span class="sc0">    </span><span class="sc2">//}
</span><span class="sc0">    </span><span class="sc2">//else
</span><span class="sc0">    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stored_len</span><span class="sc10">+</span><span class="sc4">4</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">opt_lenb</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">buf</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">*)</span><span class="sc5">NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                       </span><span class="sc1">/* 4: two words for the lengths */</span><span class="sc0">
        </span><span class="sc1">/* The test buf != NULL is only necessary if LIT_BUFSIZE &gt; WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE &lt;= WSIZE, it is never too late to
         * transform a block into a stored block.
         */</span><span class="sc0">
        </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,(</span><span class="sc11">STORED_BLOCK</span><span class="sc10">&lt;&lt;</span><span class="sc4">1</span><span class="sc10">)+</span><span class="sc11">eof</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">);</span><span class="sc0">  </span><span class="sc1">/* send block type */</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">cmpr_bytelen</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">cmpr_len_bits</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">stored_len</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">cmpr_len_bits</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0L</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc11">copy_block</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc10">)</span><span class="sc11">stored_len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc1">/* with header */</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">static_lenb</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">opt_lenb</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,(</span><span class="sc11">STATIC_TREES</span><span class="sc10">&lt;&lt;</span><span class="sc4">1</span><span class="sc10">)+</span><span class="sc11">eof</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">compress_block</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,(</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_ltree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_dtree</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">cmpr_len_bits</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_len</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">cmpr_bytelen</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">cmpr_len_bits</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">cmpr_len_bits</span><span class="sc0"> </span><span class="sc10">&amp;=</span><span class="sc0"> </span><span class="sc4">7L</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,(</span><span class="sc11">DYN_TREES</span><span class="sc10">&lt;&lt;</span><span class="sc4">1</span><span class="sc10">)+</span><span class="sc11">eof</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">send_all_trees</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">l_desc</span><span class="sc10">.</span><span class="sc11">max_code</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">d_desc</span><span class="sc10">.</span><span class="sc11">max_code</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">max_blindex</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">compress_block</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,(</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">dyn_ltree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">dyn_dtree</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">cmpr_len_bits</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">opt_len</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">cmpr_bytelen</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">cmpr_len_bits</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">cmpr_len_bits</span><span class="sc0"> </span><span class="sc10">&amp;=</span><span class="sc0"> </span><span class="sc4">7L</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,((</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">cmpr_bytelen</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">cmpr_len_bits</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bits_sent</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"bad compressed size"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">init_block</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">eof</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc2">// Assert(state,input_len == isize, "bad input size");
</span><span class="sc0">        </span><span class="sc11">bi_windup</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">cmpr_len_bits</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* align on byte boundary */</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">Trace</span><span class="sc10">(</span><span class="sc6">"\n"</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">cmpr_bytelen</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">cmpr_len_bits</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */</span><span class="sc0">
</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">ct_tally</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">dist</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">lc</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">l_buf</span><span class="sc10">[</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_lit</span><span class="sc10">++]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uch</span><span class="sc10">)</span><span class="sc11">lc</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">dist</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc1">/* lc is the unmatched char */</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">dyn_ltree</span><span class="sc10">[</span><span class="sc11">lc</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc10">++;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc1">/* Here, lc is the match length - MIN_MATCH */</span><span class="sc0">
        </span><span class="sc11">dist</span><span class="sc10">--;</span><span class="sc0">             </span><span class="sc1">/* dist = match distance - 1 */</span><span class="sc0">
        </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">dist</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">MAX_DIST</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
               </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">lc</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)(</span><span class="sc11">MAX_MATCH</span><span class="sc10">-</span><span class="sc11">MIN_MATCH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
               </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">d_code</span><span class="sc10">(</span><span class="sc11">dist</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">D_CODES</span><span class="sc10">,</span><span class="sc0">  </span><span class="sc6">"ct_tally: bad match"</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">dyn_ltree</span><span class="sc10">[</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">length_code</span><span class="sc10">[</span><span class="sc11">lc</span><span class="sc10">]+</span><span class="sc11">LITERALS</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc10">++;</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">dyn_dtree</span><span class="sc10">[</span><span class="sc11">d_code</span><span class="sc10">(</span><span class="sc11">dist</span><span class="sc10">)].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc10">++;</span><span class="sc0">

        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">d_buf</span><span class="sc10">[</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_dist</span><span class="sc10">++]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">dist</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">|=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">flag_bit</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">flag_bit</span><span class="sc0"> </span><span class="sc10">&lt;&lt;=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc1">/* Output the flags if they fill a byte: */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_lit</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">flag_buf</span><span class="sc10">[</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_flags</span><span class="sc10">++]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">flags</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">flag_bit</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc1">/* Try to guess if it is profitable to stop the current block here */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_lit</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">0xfff</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc1">/* Compute an upper bound for the compressed length */</span><span class="sc0">
        </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">out_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_lit</span><span class="sc10">*</span><span class="sc4">8L</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">in_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">-</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">block_start</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">dcode</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">dcode</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">dcode</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">D_CODES</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">dcode</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">out_length</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">dyn_dtree</span><span class="sc10">[</span><span class="sc11">dcode</span><span class="sc10">].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc10">*(</span><span class="sc4">5L</span><span class="sc10">+</span><span class="sc11">extra_dbits</span><span class="sc10">[</span><span class="sc11">dcode</span><span class="sc10">]);</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc11">out_length</span><span class="sc0"> </span><span class="sc10">&gt;&gt;=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">Trace</span><span class="sc10">(</span><span class="sc6">"\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) "</span><span class="sc10">,</span><span class="sc0">
               </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_lit</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_dist</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">in_length</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">out_length</span><span class="sc10">,</span><span class="sc0">
               </span><span class="sc4">100L</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">out_length</span><span class="sc10">*</span><span class="sc4">100L</span><span class="sc10">/</span><span class="sc11">in_length</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_dist</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_lit</span><span class="sc10">/</span><span class="sc4">2</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">out_length</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">in_length</span><span class="sc10">/</span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_lit</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">LIT_BUFSIZE</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_dist</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">DIST_BUFSIZE</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc1">/* We avoid equality with LIT_BUFSIZE because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">compress_block</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">ltree</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ct_data</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">dtree</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">dist</span><span class="sc10">;</span><span class="sc0">      </span><span class="sc1">/* distance of matched string */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">lc</span><span class="sc10">;</span><span class="sc0">             </span><span class="sc1">/* match length or unmatched char (if dist == 0) */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">lx</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc1">/* running index in l_buf */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">dx</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc1">/* running index in d_buf */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">fx</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc1">/* running index in flag_buf */</span><span class="sc0">
    </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">flag</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc1">/* current flags */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc10">;</span><span class="sc0">      </span><span class="sc1">/* the code to send */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">extra</span><span class="sc10">;</span><span class="sc0">          </span><span class="sc1">/* number of extra bits to send */</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_lit</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">lx</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">flag</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">flag_buf</span><span class="sc10">[</span><span class="sc11">fx</span><span class="sc10">++];</span><span class="sc0">
        </span><span class="sc11">lc</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">l_buf</span><span class="sc10">[</span><span class="sc11">lx</span><span class="sc10">++];</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">flag</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">lc</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ltree</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc1">/* send a literal byte */</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc1">/* Here, lc is the match length - MIN_MATCH */</span><span class="sc0">
            </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">length_code</span><span class="sc10">[</span><span class="sc11">lc</span><span class="sc10">];</span><span class="sc0">
            </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">code</span><span class="sc10">+</span><span class="sc11">LITERALS</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ltree</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc1">/* send the length code */</span><span class="sc0">
            </span><span class="sc11">extra</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">extra_lbits</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">];</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">extra</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">lc</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">base_length</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">];</span><span class="sc0">
                </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">lc</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">extra</span><span class="sc10">);</span><span class="sc0">        </span><span class="sc1">/* send the extra length bits */</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc11">dist</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">d_buf</span><span class="sc10">[</span><span class="sc11">dx</span><span class="sc10">++];</span><span class="sc0">
            </span><span class="sc1">/* Here, dist is the match distance - 1 */</span><span class="sc0">
            </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">d_code</span><span class="sc10">(</span><span class="sc11">dist</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">D_CODES</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"bad d_code"</span><span class="sc10">);</span><span class="sc0">

            </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">code</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">dtree</span><span class="sc10">);</span><span class="sc0">       </span><span class="sc1">/* send the distance code */</span><span class="sc0">
            </span><span class="sc11">extra</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">extra_dbits</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">];</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">extra</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">dist</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">base_dist</span><span class="sc10">[</span><span class="sc11">code</span><span class="sc10">];</span><span class="sc0">
                </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">dist</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">extra</span><span class="sc10">);</span><span class="sc0">   </span><span class="sc1">/* send the extra distance bits */</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc1">/* literal or match pair ? */</span><span class="sc0">
        </span><span class="sc11">flag</span><span class="sc0"> </span><span class="sc10">&gt;&gt;=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">lx</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">last_lit</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">send_code</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">END_BLOCK</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ltree</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Set the file type to ASCII or BINARY, using a crude approximation:
 * binary if more than 20% of the bytes are &lt;= 6 or &gt;= 128, ascii otherwise.
 * IN assertion: the fields freq of dyn_ltree are set and the total of all
 * frequencies does not exceed 64K (to fit in an int on 16 bit machines).
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">set_file_type</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">ascii_freq</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">bin_freq</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">)</span><span class="sc0">        </span><span class="sc11">bin_freq</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">dyn_ltree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">++].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc4">128</span><span class="sc10">)</span><span class="sc0">    </span><span class="sc11">ascii_freq</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">dyn_ltree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">++].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">LITERALS</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">bin_freq</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">dyn_ltree</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">++].</span><span class="sc11">fc</span><span class="sc10">.</span><span class="sc11">freq</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">*</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">file_type</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)(</span><span class="sc11">bin_freq</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ascii_freq</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc11">BINARY</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">ASCII</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">


</span><span class="sc1">/* ===========================================================================
 * Initialize the bit string routines.
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">bi_init</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">tgt_buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">tgt_size</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">flsh_allowed</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">out_buf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">tgt_buf</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">out_size</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">tgt_size</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">out_offset</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">flush_flg</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">flsh_allowed</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bi_buf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bits_sent</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0L</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length &lt;= 16 and value fits in length bits.
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">send_bits</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">value</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">length</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">15</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"invalid length"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bits_sent</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">length</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc1">/* If not enough room in bi_buf, use (bi_valid) bits from bi_buf and
     * (Buf_size - bi_valid) bits from value to flush the filled bi_buf,
     * then fill in the rest of (value), leaving (length - (Buf_size-bi_valid))
     * unused bits in bi_buf.
     */</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bi_buf</span><span class="sc0"> </span><span class="sc10">|=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">value</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bi_valid</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">int</span><span class="sc10">)</span><span class="sc11">Buf_size</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">PUTSHORT</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bi_buf</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc11">Buf_size</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bi_buf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc10">)</span><span class="sc11">value</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">length</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bi_valid</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 &lt;= len &lt;= 15
 */</span><span class="sc0">
</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">bi_reverse</span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">res</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">res</span><span class="sc0"> </span><span class="sc10">|=</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">code</span><span class="sc0"> </span><span class="sc10">&gt;&gt;=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">res</span><span class="sc0"> </span><span class="sc10">&lt;&lt;=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(--</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">res</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Write out any remaining bits in an incomplete byte.
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">bi_windup</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">PUTSHORT</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bi_buf</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">PUTBYTE</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bi_buf</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">flush_flg</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">flush_outbuf</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">param</span><span class="sc10">,</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">out_buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">out_offset</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bi_buf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bi_valid</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bits_sent</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bits_sent</span><span class="sc10">+</span><span class="sc4">7</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc10">~</span><span class="sc4">7</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Copy a stored block to the zip file, storing first the length and its
 * one's complement if requested.
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">copy_block</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">block</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">header</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">bi_windup</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">);</span><span class="sc0">              </span><span class="sc1">/* align on byte boundary */</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">header</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">PUTSHORT</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">PUTSHORT</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,(</span><span class="sc11">ush</span><span class="sc10">)~</span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bits_sent</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">*</span><span class="sc4">16</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">flush_flg</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">flush_outbuf</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">param</span><span class="sc10">,</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">out_buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">out_offset</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">out_offset</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">flush_outbuf</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">param</span><span class="sc10">,</span><span class="sc11">block</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">out_offset</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">out_offset</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">out_size</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc5">false</span><span class="sc10">,</span><span class="sc6">"output buffer too small for in-memory compression"</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">memcpy</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">out_buf</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">out_offset</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">block</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">out_offset</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">bs</span><span class="sc10">.</span><span class="sc11">bits_sent</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">len</span><span class="sc10">&lt;&lt;</span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">








</span><span class="sc1">/* ===========================================================================
 *  Prototypes for functions.
 */</span><span class="sc0">

</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">fill_window</span><span class="sc0">  </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">deflate_fast</span><span class="sc0">  </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">);</span><span class="sc0">

</span><span class="sc16">int</span><span class="sc0">  </span><span class="sc11">longest_match</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">IPos</span><span class="sc0"> </span><span class="sc11">cur_match</span><span class="sc10">);</span><span class="sc0">


</span><span class="sc1">/* ===========================================================================
 * Update a hash value with the given input byte
 * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
 *    input characters, so that a running hash key can be computed from the
 *    previous key instead of complete recalculation each time.
 */</span><span class="sc0">
</span><span class="sc9">#define UPDATE_HASH(h,c) (h = (((h)&lt;&lt;H_SHIFT) ^ (c)) &amp; HASH_MASK)
</span><span class="sc0">
</span><span class="sc1">/* ===========================================================================
 * Insert string s in the dictionary and set match_head to the previous head
 * of the hash chain (the most recent string with same hash key). Return
 * the previous length of the hash chain.
 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
 *    input characters and the first MIN_MATCH bytes of s are valid
 *    (except for the last MIN_MATCH-1 bytes of the input file).
 */</span><span class="sc0">
</span><span class="sc9">#define INSERT_STRING(s, match_head) \
   (UPDATE_HASH(state.ds.ins_h, state.ds.window[(s) + (MIN_MATCH-1)]), \
    state.ds.prev[(s) &amp; WMASK] = match_head = state.ds.head[state.ds.ins_h], \
    state.ds.head[state.ds.ins_h] = (s))
</span><span class="sc0">
</span><span class="sc1">/* ===========================================================================
 * Initialize the "longest match" routines for a new file
 *
 * IN assertion: window_size is &gt; 0 if the input file is already read or
 *    mmap'ed in the window[] array, 0 otherwise. In the first case,
 *    window_size is sufficient to contain the whole input file plus
 *    MIN_LOOKAHEAD bytes (to avoid referencing memory beyond the end
 *    of window[] when looking for matches towards the end).
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">lm_init</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">pack_level</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ush</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">flags</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">j</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">pack_level</span><span class="sc10">&gt;=</span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">pack_level</span><span class="sc10">&lt;=</span><span class="sc4">8</span><span class="sc10">,</span><span class="sc6">"bad pack level"</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc1">/* Do not slide the window if the whole input is already in memory
     * (window_size &gt; 0)
     */</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">sliding</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">window_size</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0L</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">sliding</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">window_size</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc4">2L</span><span class="sc10">*</span><span class="sc11">WSIZE</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc1">/* Initialize the hash table (avoiding 64K overflow for 16 bit systems).
     * prev[] will be initialized on the fly.
     */</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">head</span><span class="sc10">[</span><span class="sc11">HASH_SIZE</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">NIL</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">memset</span><span class="sc10">((</span><span class="sc16">char</span><span class="sc10">*)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">head</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">NIL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc10">)(</span><span class="sc11">HASH_SIZE</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">)*</span><span class="sc5">sizeof</span><span class="sc10">(*</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">head</span><span class="sc10">));</span><span class="sc0">

    </span><span class="sc1">/* Set the default configuration parameters:
     */</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">max_lazy_match</span><span class="sc0">   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">configuration_table</span><span class="sc10">[</span><span class="sc11">pack_level</span><span class="sc10">].</span><span class="sc11">max_lazy</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">good_match</span><span class="sc0">       </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">configuration_table</span><span class="sc10">[</span><span class="sc11">pack_level</span><span class="sc10">].</span><span class="sc11">good_length</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">nice_match</span><span class="sc0">       </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">configuration_table</span><span class="sc10">[</span><span class="sc11">pack_level</span><span class="sc10">].</span><span class="sc11">nice_length</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">max_chain_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">configuration_table</span><span class="sc10">[</span><span class="sc11">pack_level</span><span class="sc10">].</span><span class="sc11">max_chain</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">pack_level</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
       </span><span class="sc10">*</span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">|=</span><span class="sc0"> </span><span class="sc11">FAST</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">pack_level</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
       </span><span class="sc10">*</span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">|=</span><span class="sc0"> </span><span class="sc11">SLOW</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc1">/* ??? reduce max_chain_length for binary files */</span><span class="sc0">

    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">block_start</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0L</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc11">j</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">WSIZE</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">j</span><span class="sc0"> </span><span class="sc10">&lt;&lt;=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// Can read 64K in one step
</span><span class="sc0">    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">readfunc</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">*)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">window</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">j</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc10">)</span><span class="sc11">EOF</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
       </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">eofile</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
       </span><span class="sc5">return</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">eofile</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc1">/* Make sure that we always have enough lookahead. This is important
     * if input comes from a device such as a tty.
     */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">MIN_LOOKAHEAD</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">fill_window</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">ins_h</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">j</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">j</span><span class="sc10">&lt;</span><span class="sc11">MIN_MATCH</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">j</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc11">UPDATE_HASH</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">ins_h</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">j</span><span class="sc10">]);</span><span class="sc0">
    </span><span class="sc1">/* If lookahead &lt; MIN_MATCH, ins_h is garbage, but this is
     * not important since only literal bytes will be emitted.
     */</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">


</span><span class="sc1">/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is &lt;= MAX_DIST, and prev_length &gt;= 1
 */</span><span class="sc0">
</span><span class="sc2">// For 80x86 and 680x0 and ARM, an optimized version is in match.asm or
// match.S. The code is functionally equivalent, so you can use the C version
// if desired. Which I do so desire!
</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">longest_match</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">IPos</span><span class="sc0"> </span><span class="sc11">cur_match</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">chain_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">max_chain_length</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc1">/* max hash chain length */</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">far</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">window</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* current string */</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">far</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">match</span><span class="sc10">;</span><span class="sc0">                    </span><span class="sc1">/* matched string */</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">                           </span><span class="sc1">/* length of current match */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">best_len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">prev_length</span><span class="sc10">;</span><span class="sc0">                 </span><span class="sc1">/* best match length so far */</span><span class="sc0">
    </span><span class="sc11">IPos</span><span class="sc0"> </span><span class="sc11">limit</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">IPos</span><span class="sc10">)</span><span class="sc11">MAX_DIST</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">IPos</span><span class="sc10">)</span><span class="sc11">MAX_DIST</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">NIL</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc1">/* Stop when cur_match becomes &lt;= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */</span><span class="sc0">

  </span><span class="sc2">// The code is optimized for HASH_BITS &gt;= 8 and MAX_MATCH-2 multiple of 16.
</span><span class="sc0">  </span><span class="sc2">// It is easy to get rid of this optimization if necessary.
</span><span class="sc0">    </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">HASH_BITS</span><span class="sc10">&gt;=</span><span class="sc4">8</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">MAX_MATCH</span><span class="sc10">==</span><span class="sc4">258</span><span class="sc10">,</span><span class="sc6">"Code too clever"</span><span class="sc10">);</span><span class="sc0">



    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">far</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">strend</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">window</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">MAX_MATCH</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">scan_end1</span><span class="sc0">  </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">scan</span><span class="sc10">[</span><span class="sc11">best_len</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">];</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc11">scan_end</span><span class="sc0">   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">scan</span><span class="sc10">[</span><span class="sc11">best_len</span><span class="sc10">];</span><span class="sc0">

    </span><span class="sc1">/* Do not waste too much time if we already have a good match: */</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">prev_length</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">good_match</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">chain_length</span><span class="sc0"> </span><span class="sc10">&gt;&gt;=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">window_size</span><span class="sc10">-</span><span class="sc11">MIN_LOOKAHEAD</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"insufficient lookahead"</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">cur_match</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"no future"</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">window</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">cur_match</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc1">/* Skip to next match if the match length cannot increase
         * or if the match length is less than 2:
         */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">match</span><span class="sc10">[</span><span class="sc11">best_len</span><span class="sc10">]</span><span class="sc0">   </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">scan_end</span><span class="sc0">  </span><span class="sc10">||</span><span class="sc0">
            </span><span class="sc11">match</span><span class="sc10">[</span><span class="sc11">best_len</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">scan_end1</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0">
            </span><span class="sc10">*</span><span class="sc11">match</span><span class="sc0">            </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">scan</span><span class="sc0">     </span><span class="sc10">||</span><span class="sc0">
            </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0">          </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">scan</span><span class="sc10">[</span><span class="sc4">1</span><span class="sc10">])</span><span class="sc0">      </span><span class="sc5">continue</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc1">/* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS &gt;= 8.
         */</span><span class="sc0">
        </span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">match</span><span class="sc10">++;</span><span class="sc0">

        </span><span class="sc1">/* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */</span><span class="sc0">
        </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
                 </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
                 </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
                 </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">*++</span><span class="sc11">match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
                 </span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">strend</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">window</span><span class="sc10">+(</span><span class="sc16">unsigned</span><span class="sc10">)(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">window_size</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">),</span><span class="sc0"> </span><span class="sc6">"wild scan"</span><span class="sc10">);</span><span class="sc0">
                          
        </span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">MAX_MATCH</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">int</span><span class="sc10">)(</span><span class="sc11">strend</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">scan</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">scan</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">strend</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">MAX_MATCH</span><span class="sc10">;</span><span class="sc0">


        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">best_len</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">match_start</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">cur_match</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">best_len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">nice_match</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">scan_end1</span><span class="sc0">  </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">scan</span><span class="sc10">[</span><span class="sc11">best_len</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">];</span><span class="sc0">
            </span><span class="sc11">scan_end</span><span class="sc0">   </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">scan</span><span class="sc10">[</span><span class="sc11">best_len</span><span class="sc10">];</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">cur_match</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">prev</span><span class="sc10">[</span><span class="sc11">cur_match</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc11">WMASK</span><span class="sc10">])</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">limit</span><span class="sc0">
             </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">--</span><span class="sc11">chain_length</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">best_len</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">



</span><span class="sc9">#define check_match(state,start, match, length)
</span><span class="sc2">// or alternatively...
//void check_match(TState &amp;state,IPos start, IPos match, int length)
//{ // check that the match is indeed a match
//    if (memcmp((char*)state.ds.window + match,
//                (char*)state.ds.window + start, length) != EQUAL) {
//        fprintf(stderr,
//            " start %d, match %d, length %d\n",
//            start, match, length);
//        error("invalid match");
//    }
//    if (state.verbose &gt; 1) {
//        fprintf(stderr,"\\[%d,%d]", start-match, length);
//        do { fprintf(stdout,"%c",state.ds.window[start++]); } while (--length != 0);
//    }
//}
</span><span class="sc0">
</span><span class="sc1">/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead, and sets eofile if end of input file.
 *
 * IN assertion: lookahead &lt; MIN_LOOKAHEAD &amp;&amp; strstart + lookahead &gt; 0
 * OUT assertions: strstart &lt;= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or eofile is set; file reads are
 *    performed for at least two bytes (required for the translate_eol option).
 */</span><span class="sc0">
</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc11">fill_window</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">m</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">more</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc1">/* Amount of free space at the end of the window. */</span><span class="sc0">

    </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">more</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc10">)(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">window_size</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc1">/* If the window is almost full and there is insufficient lookahead,
         * move the upper half to the lower one to make room in the upper half.
         */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">more</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc10">)</span><span class="sc11">EOF</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc1">/* Very unlikely, but possible on 16 bit machine if strstart == 0
             * and lookahead == 1 (input done one byte at time)
             */</span><span class="sc0">
            </span><span class="sc11">more</span><span class="sc10">--;</span><span class="sc0">

        </span><span class="sc1">/* For MMAP or BIG_MEM, the whole input file is already in memory so
         * we must not perform sliding. We must however call (*read_buf)() in
         * order to compute the crc, update lookahead and possibly set eofile.
         */</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">WSIZE</span><span class="sc10">+</span><span class="sc11">MAX_DIST</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">sliding</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">

            </span><span class="sc1">/* By the IN assertion, the window is not empty so we can't confuse
             * more == 0 with more == 64K on a 16 bit machine.
             */</span><span class="sc0">
            </span><span class="sc11">memcpy</span><span class="sc10">((</span><span class="sc16">char</span><span class="sc10">*)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">window</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">*)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">window</span><span class="sc10">+</span><span class="sc11">WSIZE</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc10">)</span><span class="sc11">WSIZE</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">match_start</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc11">WSIZE</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc0">    </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc11">WSIZE</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* we now have strstart &gt;= MAX_DIST: */</span><span class="sc0">

            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">block_start</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">long</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">WSIZE</span><span class="sc10">;</span><span class="sc0">

            </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">HASH_SIZE</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">m</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">head</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">];</span><span class="sc0">
                </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">head</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Pos</span><span class="sc10">)(</span><span class="sc11">m</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">WSIZE</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc11">m</span><span class="sc10">-</span><span class="sc11">WSIZE</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">NIL</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">WSIZE</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">++)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">m</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">prev</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">];</span><span class="sc0">
                </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">prev</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">Pos</span><span class="sc10">)(</span><span class="sc11">m</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">WSIZE</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc11">m</span><span class="sc10">-</span><span class="sc11">WSIZE</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">NIL</span><span class="sc10">);</span><span class="sc0">
                </span><span class="sc1">/* If n is not on any hash chain, prev[n] is garbage but
                 * its value will never be used.
                 */</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc11">more</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">WSIZE</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">eofile</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc1">/* If there was no sliding:
         *    strstart &lt;= WSIZE+MAX_DIST-1 &amp;&amp; lookahead &lt;= MIN_LOOKAHEAD - 1 &amp;&amp;
         *    more == window_size - lookahead - strstart
         * =&gt; more &gt;= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
         * =&gt; more &gt;= window_size - 2*WSIZE + 2
         * In the MMAP or BIG_MEM case (not yet supported in gzip),
         *   window_size == input_size + MIN_LOOKAHEAD  &amp;&amp;
         *   strstart + lookahead &lt;= input_size =&gt; more &gt;= MIN_LOOKAHEAD.
         * Otherwise, window_size == 2*WSIZE so more &gt;= 2.
         * If there was sliding, more &gt;= WSIZE. So in all cases, more &gt;= 2.
         */</span><span class="sc0">
        </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">more</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc6">"more &lt; 2"</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">readfunc</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">*)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">window</span><span class="sc10">+</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">+</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">more</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc10">)</span><span class="sc11">EOF</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">eofile</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">MIN_LOOKAHEAD</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">!</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">eofile</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Flush the current block, with given end-of-file flag.
 * IN assertion: strstart is set to the end of the current match.
 */</span><span class="sc0">
</span><span class="sc9">#define FLUSH_BLOCK(state,eof) \
   flush_block(state,state.ds.block_start &gt;= 0L ? (char*)&amp;state.ds.window[(unsigned)state.ds.block_start] : \
                (char*)NULL, (long)state.ds.strstart - state.ds.block_start, (eof))
</span><span class="sc0">
</span><span class="sc1">/* ===========================================================================
 * Processes a new input file and return its compressed length. This
 * function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */</span><span class="sc0">
</span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">deflate_fast</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">IPos</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">NIL</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc1">/* head of the hash chain */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc10">;</span><span class="sc0">                  </span><span class="sc1">/* set if current block must be flushed */</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc1">/* length of best match */</span><span class="sc0">

    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">prev_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc1">/* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">)</span><span class="sc0">
        </span><span class="sc11">INSERT_STRING</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc1">/* Find the longest match, discarding those &lt;= prev_length.
         * At this point we have always match_length &lt; MIN_MATCH
         */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hash_head</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">NIL</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">MAX_DIST</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc1">/* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */</span><span class="sc0">
            </span><span class="sc1">/* Do not look for matches beyond the end of the input.
             * This is necessary to make deflate deterministic.
             */</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc16">unsigned</span><span class="sc10">)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">nice_match</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">nice_match</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">int</span><span class="sc10">)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">longest_match</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">hash_head</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc1">/* longest_match() sets match_start */</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">check_match</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">match_start</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">match_length</span><span class="sc10">);</span><span class="sc0">

            </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">ct_tally</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">-</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">match_start</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">);</span><span class="sc0">

            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc11">match_length</span><span class="sc10">;</span><span class="sc0">

            </span><span class="sc1">/* Insert new strings in the hash table only if the match length
             * is not too large. This saves time but degrades compression.
             */</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">max_insert_length</span><span class="sc0">
                </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">match_length</span><span class="sc10">--;</span><span class="sc0"> </span><span class="sc1">/* string at strstart already in hash table */</span><span class="sc0">
                </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                    </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">++;</span><span class="sc0">
                    </span><span class="sc11">INSERT_STRING</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc10">);</span><span class="sc0">
                    </span><span class="sc1">/* strstart never exceeds WSIZE-MAX_MATCH, so there are
                     * always MIN_MATCH bytes ahead.
                     */</span><span class="sc0">
                </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(--</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
                </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">++;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">match_length</span><span class="sc10">;</span><span class="sc0">
                </span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
                </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">ins_h</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">];</span><span class="sc0">
                </span><span class="sc11">UPDATE_HASH</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">ins_h</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">]);</span><span class="sc0">
                </span><span class="sc11">Assert</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">MIN_MATCH</span><span class="sc10">==</span><span class="sc4">3</span><span class="sc10">,</span><span class="sc6">"Call UPDATE_HASH() MIN_MATCH-3 more times"</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc1">/* No match, output a literal byte */</span><span class="sc0">
            </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">ct_tally</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">]);</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc10">--;</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">++;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">flush</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">FLUSH_BLOCK</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">),</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">block_start</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc1">/* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">MIN_LOOKAHEAD</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">fill_window</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">FLUSH_BLOCK</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc1">/* eof */</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc1">/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */</span><span class="sc0">
</span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">deflate</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">state</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc11">IPos</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">NIL</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc1">/* head of hash chain */</span><span class="sc0">
    </span><span class="sc11">IPos</span><span class="sc0"> </span><span class="sc11">prev_match</span><span class="sc10">;</span><span class="sc0">            </span><span class="sc1">/* previous match */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">flush</span><span class="sc10">;</span><span class="sc0">                  </span><span class="sc1">/* set if current block must be flushed */</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">match_available</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc1">/* set if previous match exists */</span><span class="sc0">
    </span><span class="sc16">register</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc1">/* length of best match */</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">level</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">deflate_fast</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc1">/* optimized for speed */</span><span class="sc0">

    </span><span class="sc1">/* Process the input block. */</span><span class="sc0">
    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc1">/* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">)</span><span class="sc0">
        </span><span class="sc11">INSERT_STRING</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc10">);</span><span class="sc0">

        </span><span class="sc1">/* Find the longest match, discarding those &lt;= prev_length.
         */</span><span class="sc0">
        </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">prev_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">match_length</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">prev_match</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">match_start</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hash_head</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">NIL</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">prev_length</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">max_lazy_match</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">MAX_DIST</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc1">/* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */</span><span class="sc0">
            </span><span class="sc1">/* Do not look for matches beyond the end of the input.
             * This is necessary to make deflate deterministic.
             */</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc16">unsigned</span><span class="sc10">)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">nice_match</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">nice_match</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">int</span><span class="sc10">)</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">longest_match</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">hash_head</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc1">/* longest_match() sets match_start */</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc10">;</span><span class="sc0">

            </span><span class="sc1">/* Ignore a length 3 match if it is too distant: */</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">-</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">match_start</span><span class="sc0"> </span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">TOO_FAR</span><span class="sc10">){</span><span class="sc0">
                </span><span class="sc1">/* If prev_match is also MIN_MATCH, match_start is garbage
                 * but we will ignore the current match anyway.
                 */</span><span class="sc0">
                </span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc1">/* If there was a match at the previous step and the current
         * match is not better, output the previous match:
         */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">prev_length</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">prev_length</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">max_insert</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">check_match</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">prev_match</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">prev_length</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc11">flush</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">ct_tally</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">-</span><span class="sc11">prev_match</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">prev_length</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">);</span><span class="sc0">

            </span><span class="sc1">/* Insert in hash table all strings up to the end of the match.
             * strstart-1 and strstart are already inserted.
             */</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">prev_length</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">prev_length</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(++</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc0"> </span><span class="sc10">&lt;=</span><span class="sc0"> </span><span class="sc11">max_insert</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                    </span><span class="sc11">INSERT_STRING</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">hash_head</span><span class="sc10">);</span><span class="sc0">
                    </span><span class="sc1">/* strstart never exceeds WSIZE-MAX_MATCH, so there are
                     * always MIN_MATCH bytes ahead.
                     */</span><span class="sc0">
                </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(--</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">prev_length</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">++;</span><span class="sc0">
            </span><span class="sc11">match_available</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">match_length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">MIN_MATCH</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">

            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">flush</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">FLUSH_BLOCK</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">),</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">block_start</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">match_available</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc1">/* If there was no match at the previous position, output a
             * single literal. If there was a match but the current match
             * is longer, truncate the previous match to a single literal.
             */</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ct_tally</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">]))</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">FLUSH_BLOCK</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">),</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">block_start</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">++;</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc10">--;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0"> </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc1">/* There is no previous match to compare with, wait for
             * the next step to decide.
             */</span><span class="sc0">
            </span><span class="sc11">match_available</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">++;</span><span class="sc0">
            </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc10">--;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc2">//        Assert(state,strstart &lt;= isize &amp;&amp; lookahead &lt;= isize, "a bit too far");
</span><span class="sc0">
        </span><span class="sc1">/* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">lookahead</span><span class="sc0"> </span><span class="sc10">&lt;</span><span class="sc0"> </span><span class="sc11">MIN_LOOKAHEAD</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">fill_window</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">match_available</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">ct_tally</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">window</span><span class="sc10">[</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ds</span><span class="sc10">.</span><span class="sc11">strstart</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">]);</span><span class="sc0">

    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">FLUSH_BLOCK</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc1">/* eof */</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">












</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">putlocal</span><span class="sc10">(</span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">zlist</span><span class="sc0"> </span><span class="sc11">far</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">z</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">WRITEFUNC</span><span class="sc0"> </span><span class="sc11">wfunc</span><span class="sc10">,</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">param</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc2">// Write a local header described by *z to file *f.  Return a ZE_ error code.
</span><span class="sc0">  </span><span class="sc11">PUTLG</span><span class="sc10">(</span><span class="sc11">LOCSIG</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTSH</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">ver</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTSH</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">lflg</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTSH</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">how</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTLG</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">tim</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTLG</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">crc</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTLG</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">siz</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTLG</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTSH</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">nam</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTSH</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">ext</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">size_t</span><span class="sc0"> </span><span class="sc11">res</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">size_t</span><span class="sc10">)</span><span class="sc11">wfunc</span><span class="sc10">(</span><span class="sc11">param</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">iname</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc10">)</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">nam</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">res</span><span class="sc10">!=</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">nam</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZE_TEMP</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">ext</span><span class="sc10">)</span><span class="sc0">
  </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">res</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">size_t</span><span class="sc10">)</span><span class="sc11">wfunc</span><span class="sc10">(</span><span class="sc11">param</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">extra</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc10">)</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">ext</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">res</span><span class="sc10">!=</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">ext</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZE_TEMP</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc10">}</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZE_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">putextended</span><span class="sc10">(</span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">zlist</span><span class="sc0"> </span><span class="sc11">far</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">z</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">WRITEFUNC</span><span class="sc0"> </span><span class="sc11">wfunc</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">param</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc2">// Write an extended local header described by *z to file *f. Returns a ZE_ code
</span><span class="sc0">  </span><span class="sc11">PUTLG</span><span class="sc10">(</span><span class="sc11">EXTLOCSIG</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTLG</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">crc</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTLG</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">siz</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTLG</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZE_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">putcentral</span><span class="sc10">(</span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">zlist</span><span class="sc0"> </span><span class="sc11">far</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">z</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">WRITEFUNC</span><span class="sc0"> </span><span class="sc11">wfunc</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">param</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc2">// Write a central header entry of *z to file *f. Returns a ZE_ code.
</span><span class="sc0">  </span><span class="sc11">PUTLG</span><span class="sc10">(</span><span class="sc11">CENSIG</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTSH</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">vem</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTSH</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">ver</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTSH</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">flg</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTSH</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">how</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTLG</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">tim</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTLG</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">crc</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTLG</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">siz</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTLG</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTSH</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">nam</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTSH</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">cext</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTSH</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">com</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTSH</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">dsk</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTSH</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">att</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTLG</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">atx</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTLG</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">off</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">size_t</span><span class="sc10">)</span><span class="sc11">wfunc</span><span class="sc10">(</span><span class="sc11">param</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">iname</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc10">)</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">nam</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">nam</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0">
      </span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">cext</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">size_t</span><span class="sc10">)</span><span class="sc11">wfunc</span><span class="sc10">(</span><span class="sc11">param</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">cextra</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc10">)</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">cext</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">cext</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0">
      </span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">com</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">size_t</span><span class="sc10">)</span><span class="sc11">wfunc</span><span class="sc10">(</span><span class="sc11">param</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">comment</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc10">)</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">com</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">com</span><span class="sc10">))</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZE_TEMP</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZE_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">


</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">putend</span><span class="sc10">(</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">c</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">extent</span><span class="sc0"> </span><span class="sc11">m</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">z</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">WRITEFUNC</span><span class="sc0"> </span><span class="sc11">wfunc</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">param</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc2">// write the end of the central-directory-data to file *f.
</span><span class="sc0">  </span><span class="sc11">PUTLG</span><span class="sc10">(</span><span class="sc11">ENDSIG</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTSH</span><span class="sc10">(</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTSH</span><span class="sc10">(</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTSH</span><span class="sc10">(</span><span class="sc11">n</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTSH</span><span class="sc10">(</span><span class="sc11">n</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTLG</span><span class="sc10">(</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTLG</span><span class="sc10">(</span><span class="sc11">c</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">PUTSH</span><span class="sc10">(</span><span class="sc11">m</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">f</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc2">// Write the comment, if any
</span><span class="sc0">  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">m</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">wfunc</span><span class="sc10">(</span><span class="sc11">param</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">z</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc10">)</span><span class="sc11">m</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">m</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZE_TEMP</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZE_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">






</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">crc_table</span><span class="sc10">[</span><span class="sc4">256</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
  </span><span class="sc4">0x00000000L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x77073096L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xee0e612cL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x990951baL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x076dc419L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x706af48fL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xe963a535L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x9e6495a3L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x0edb8832L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x79dcb8a4L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0xe0d5e91eL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x97d2d988L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x09b64c2bL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x7eb17cbdL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xe7b82d07L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x90bf1d91L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x1db71064L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x6ab020f2L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xf3b97148L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x84be41deL</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x1adad47dL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x6ddde4ebL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xf4d4b551L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x83d385c7L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x136c9856L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x646ba8c0L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xfd62f97aL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x8a65c9ecL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x14015c4fL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x63066cd9L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0xfa0f3d63L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x8d080df5L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x3b6e20c8L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x4c69105eL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xd56041e4L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0xa2677172L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x3c03e4d1L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x4b04d447L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xd20d85fdL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xa50ab56bL</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x35b5a8faL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x42b2986cL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xdbbbc9d6L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xacbcf940L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x32d86ce3L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x45df5c75L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xdcd60dcfL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xabd13d59L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x26d930acL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x51de003aL</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0xc8d75180L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xbfd06116L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x21b4f4b5L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x56b3c423L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xcfba9599L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0xb8bda50fL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x2802b89eL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x5f058808L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xc60cd9b2L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xb10be924L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x2f6f7c87L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x58684c11L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xc1611dabL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xb6662d3dL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x76dc4190L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x01db7106L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x98d220bcL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xefd5102aL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x71b18589L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x06b6b51fL</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x9fbfe4a5L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xe8b8d433L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x7807c9a2L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x0f00f934L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x9609a88eL</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0xe10e9818L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x7f6a0dbbL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x086d3d2dL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x91646c97L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xe6635c01L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x6b6b51f4L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x1c6c6162L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x856530d8L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xf262004eL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x6c0695edL</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x1b01a57bL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x8208f4c1L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xf50fc457L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x65b0d9c6L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x12b7e950L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x8bbeb8eaL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xfcb9887cL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x62dd1ddfL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x15da2d49L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x8cd37cf3L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0xfbd44c65L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x4db26158L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x3ab551ceL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xa3bc0074L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xd4bb30e2L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x4adfa541L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x3dd895d7L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xa4d1c46dL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xd3d6f4fbL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x4369e96aL</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x346ed9fcL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xad678846L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xda60b8d0L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x44042d73L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x33031de5L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0xaa0a4c5fL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xdd0d7cc9L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x5005713cL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x270241aaL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xbe0b1010L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0xc90c2086L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x5768b525L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x206f85b3L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xb966d409L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xce61e49fL</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x5edef90eL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x29d9c998L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xb0d09822L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xc7d7a8b4L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x59b33d17L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x2eb40d81L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xb7bd5c3bL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xc0ba6cadL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xedb88320L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x9abfb3b6L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x03b6e20cL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x74b1d29aL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xead54739L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x9dd277afL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x04db2615L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x73dc1683L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xe3630b12L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x94643b84L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x0d6d6a3eL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x7a6a5aa8L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0xe40ecf0bL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x9309ff9dL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x0a00ae27L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x7d079eb1L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xf00f9344L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x8708a3d2L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x1e01f268L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x6906c2feL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xf762575dL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x806567cbL</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x196c3671L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x6e6b06e7L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xfed41b76L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x89d32be0L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x10da7a5aL</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x67dd4accL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xf9b9df6fL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x8ebeeff9L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x17b7be43L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x60b08ed5L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0xd6d6a3e8L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xa1d1937eL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x38d8c2c4L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x4fdff252L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xd1bb67f1L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0xa6bc5767L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x3fb506ddL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x48b2364bL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xd80d2bdaL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xaf0a1b4cL</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x36034af6L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x41047a60L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xdf60efc3L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xa867df55L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x316e8eefL</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x4669be79L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xcb61b38cL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xbc66831aL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x256fd2a0L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x5268e236L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0xcc0c7795L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xbb0b4703L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x220216b9L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x5505262fL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xc5ba3bbeL</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0xb2bd0b28L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x2bb45a92L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x5cb36a04L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xc2d7ffa7L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xb5d0cf31L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x2cd99e8bL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x5bdeae1dL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x9b64c2b0L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xec63f226L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x756aa39cL</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x026d930aL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x9c0906a9L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xeb0e363fL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x72076785L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x05005713L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x95bf4a82L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xe2b87a14L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x7bb12baeL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x0cb61b38L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x92d28e9bL</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0xe5d5be0dL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x7cdcefb7L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x0bdbdf21L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x86d3d2d4L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xf1d4e242L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x68ddb3f8L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x1fda836eL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x81be16cdL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xf6b9265bL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x6fb077e1L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x18b74777L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x88085ae6L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xff0f6a70L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x66063bcaL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x11010b5cL</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x8f659effL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xf862ae69L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x616bffd3L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x166ccf45L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xa00ae278L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0xd70dd2eeL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x4e048354L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x3903b3c2L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xa7672661L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xd06016f7L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x4969474dL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x3e6e77dbL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xaed16a4aL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xd9d65adcL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x40df0b66L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x37d83bf0L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xa9bcae53L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xdebb9ec5L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x47b2cf7fL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x30b5ffe9L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0xbdbdf21cL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xcabac28aL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x53b39330L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x24b4a3a6L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xbad03605L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0xcdd70693L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x54de5729L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x23d967bfL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xb3667a2eL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xc4614ab8L</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x5d681b02L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x2a6f2b94L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xb40bbe37L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0xc30c8ea1L</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0x5a05df1bL</span><span class="sc10">,</span><span class="sc0">
  </span><span class="sc4">0x2d02ef8dL</span><span class="sc0">
</span><span class="sc10">};</span><span class="sc0">

</span><span class="sc9">#define CRC32(c, b) (crc_table[((int)(c) ^ (b)) &amp; 0xff] ^ ((c) &gt;&gt; 8))
#define DO1(buf)  crc = CRC32(crc, *buf++)
#define DO2(buf)  DO1(buf); DO1(buf)
#define DO4(buf)  DO2(buf); DO2(buf)
#define DO8(buf)  DO4(buf); DO4(buf)
</span><span class="sc0">
</span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">crc32</span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">crc</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">uch</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">extent</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">buf</span><span class="sc10">==</span><span class="sc5">NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc4">0L</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">crc</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">crc</span><span class="sc0"> </span><span class="sc10">^</span><span class="sc0"> </span><span class="sc4">0xffffffffL</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">&gt;=</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc11">DO8</span><span class="sc10">(</span><span class="sc11">buf</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">-=</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">;}</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">len</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">do</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc11">DO1</span><span class="sc10">(</span><span class="sc11">buf</span><span class="sc10">);}</span><span class="sc0"> </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(--</span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">crc</span><span class="sc0"> </span><span class="sc10">^</span><span class="sc0"> </span><span class="sc4">0xffffffffL</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc2">// (instead of ~c for 64-bit machines)
</span><span class="sc10">}</span><span class="sc0">








</span><span class="sc16">bool</span><span class="sc0"> </span><span class="sc11">HasZipSuffix</span><span class="sc10">(</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">fn</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">ext</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">fn</span><span class="sc10">+</span><span class="sc11">strlen</span><span class="sc10">(</span><span class="sc11">fn</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ext</span><span class="sc10">&gt;</span><span class="sc11">fn</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">ext</span><span class="sc10">!=</span><span class="sc7">'.'</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">ext</span><span class="sc10">--;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ext</span><span class="sc10">==</span><span class="sc11">fn</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">ext</span><span class="sc10">!=</span><span class="sc7">'.'</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc5">false</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stricmp</span><span class="sc10">(</span><span class="sc11">ext</span><span class="sc10">,</span><span class="sc6">".Z"</span><span class="sc10">)==</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc5">true</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stricmp</span><span class="sc10">(</span><span class="sc11">ext</span><span class="sc10">,</span><span class="sc6">".zip"</span><span class="sc10">)==</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc5">true</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stricmp</span><span class="sc10">(</span><span class="sc11">ext</span><span class="sc10">,</span><span class="sc6">".zoo"</span><span class="sc10">)==</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc5">true</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stricmp</span><span class="sc10">(</span><span class="sc11">ext</span><span class="sc10">,</span><span class="sc6">".arc"</span><span class="sc10">)==</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc5">true</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stricmp</span><span class="sc10">(</span><span class="sc11">ext</span><span class="sc10">,</span><span class="sc6">".lzh"</span><span class="sc10">)==</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc5">true</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stricmp</span><span class="sc10">(</span><span class="sc11">ext</span><span class="sc10">,</span><span class="sc6">".arj"</span><span class="sc10">)==</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc5">true</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stricmp</span><span class="sc10">(</span><span class="sc11">ext</span><span class="sc10">,</span><span class="sc6">".gz"</span><span class="sc10">)==</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc5">true</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">stricmp</span><span class="sc10">(</span><span class="sc11">ext</span><span class="sc10">,</span><span class="sc6">".tgz"</span><span class="sc10">)==</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc5">true</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc5">false</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">


</span><span class="sc11">time_t</span><span class="sc0"> </span><span class="sc11">filetime2timet</span><span class="sc10">(</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">FILETIME</span><span class="sc0"> </span><span class="sc11">ft</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">SYSTEMTIME</span><span class="sc0"> </span><span class="sc11">st</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">FileTimeToSystemTime</span><span class="sc10">(&amp;</span><span class="sc11">ft</span><span class="sc10">,&amp;</span><span class="sc11">st</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">st</span><span class="sc10">.</span><span class="sc11">wYear</span><span class="sc10">&lt;</span><span class="sc4">1970</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc11">st</span><span class="sc10">.</span><span class="sc11">wYear</span><span class="sc10">=</span><span class="sc4">1970</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">st</span><span class="sc10">.</span><span class="sc11">wMonth</span><span class="sc10">=</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">st</span><span class="sc10">.</span><span class="sc11">wDay</span><span class="sc10">=</span><span class="sc4">1</span><span class="sc10">;}</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">st</span><span class="sc10">.</span><span class="sc11">wYear</span><span class="sc10">&gt;=</span><span class="sc4">2038</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc11">st</span><span class="sc10">.</span><span class="sc11">wYear</span><span class="sc10">=</span><span class="sc4">2037</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">st</span><span class="sc10">.</span><span class="sc11">wMonth</span><span class="sc10">=</span><span class="sc4">12</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">st</span><span class="sc10">.</span><span class="sc11">wDay</span><span class="sc10">=</span><span class="sc4">31</span><span class="sc10">;}</span><span class="sc0">
  </span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">tm</span><span class="sc0"> </span><span class="sc11">tm</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">tm</span><span class="sc10">.</span><span class="sc11">tm_sec</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">st</span><span class="sc10">.</span><span class="sc11">wSecond</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">tm</span><span class="sc10">.</span><span class="sc11">tm_min</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">st</span><span class="sc10">.</span><span class="sc11">wMinute</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">tm</span><span class="sc10">.</span><span class="sc11">tm_hour</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">st</span><span class="sc10">.</span><span class="sc11">wHour</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">tm</span><span class="sc10">.</span><span class="sc11">tm_mday</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">st</span><span class="sc10">.</span><span class="sc11">wDay</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">tm</span><span class="sc10">.</span><span class="sc11">tm_mon</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">st</span><span class="sc10">.</span><span class="sc11">wMonth</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">tm</span><span class="sc10">.</span><span class="sc11">tm_year</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">st</span><span class="sc10">.</span><span class="sc11">wYear</span><span class="sc10">-</span><span class="sc4">1900</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">tm</span><span class="sc10">.</span><span class="sc11">tm_isdst</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">time_t</span><span class="sc0"> </span><span class="sc11">t</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">mktime</span><span class="sc10">(&amp;</span><span class="sc11">tm</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">t</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">


</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">GetFileInfo</span><span class="sc10">(</span><span class="sc11">HANDLE</span><span class="sc0"> </span><span class="sc11">hf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">attr</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">size</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">iztimes</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">times</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">timestamp</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> 
    </span><span class="sc11">DWORD</span><span class="sc0"> </span><span class="sc11">type</span><span class="sc10">=</span><span class="sc11">GetFileType</span><span class="sc10">(</span><span class="sc11">hf</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">type</span><span class="sc10">!=</span><span class="sc11">FILE_TYPE_DISK</span><span class="sc10">)</span><span class="sc0"> 
      </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_NOTINITED</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc2">// The handle must be a handle to a file
</span><span class="sc0">  </span><span class="sc2">// The date and time is returned in a long with the date most significant to allow
</span><span class="sc0">  </span><span class="sc2">// unsigned integer comparison of absolute times. The attributes have two
</span><span class="sc0">  </span><span class="sc2">// high bytes unix attr, and two low bytes a mapping of that to DOS attr.
</span><span class="sc0">  </span><span class="sc2">//struct stat s; int res=stat(fn,&amp;s); if (res!=0) return false;
</span><span class="sc0">  </span><span class="sc2">// translate windows file attributes into zip ones.
</span><span class="sc0">  </span><span class="sc11">BY_HANDLE_FILE_INFORMATION</span><span class="sc0"> </span><span class="sc11">bhi</span><span class="sc10">;</span><span class="sc0"> 
  </span><span class="sc11">BOOL</span><span class="sc0"> </span><span class="sc11">res</span><span class="sc10">=</span><span class="sc11">GetFileInformationByHandle</span><span class="sc10">(</span><span class="sc11">hf</span><span class="sc10">,&amp;</span><span class="sc11">bhi</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(!</span><span class="sc11">res</span><span class="sc10">)</span><span class="sc0"> 
      </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_NOFILE</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">DWORD</span><span class="sc0"> </span><span class="sc11">fa</span><span class="sc10">=</span><span class="sc11">bhi</span><span class="sc10">.</span><span class="sc11">dwFileAttributes</span><span class="sc10">;</span><span class="sc0"> 
  </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">a</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc2">// Zip uses the lower word for its interpretation of windows stuff
</span><span class="sc0">  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">fa</span><span class="sc10">&amp;</span><span class="sc11">FILE_ATTRIBUTE_READONLY</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">a</span><span class="sc10">|=</span><span class="sc4">0x01</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">fa</span><span class="sc10">&amp;</span><span class="sc11">FILE_ATTRIBUTE_HIDDEN</span><span class="sc10">)</span><span class="sc0">   </span><span class="sc11">a</span><span class="sc10">|=</span><span class="sc4">0x02</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">fa</span><span class="sc10">&amp;</span><span class="sc11">FILE_ATTRIBUTE_SYSTEM</span><span class="sc10">)</span><span class="sc0">   </span><span class="sc11">a</span><span class="sc10">|=</span><span class="sc4">0x04</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">fa</span><span class="sc10">&amp;</span><span class="sc11">FILE_ATTRIBUTE_DIRECTORY</span><span class="sc10">)</span><span class="sc11">a</span><span class="sc10">|=</span><span class="sc4">0x10</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">fa</span><span class="sc10">&amp;</span><span class="sc11">FILE_ATTRIBUTE_ARCHIVE</span><span class="sc10">)</span><span class="sc0">  </span><span class="sc11">a</span><span class="sc10">|=</span><span class="sc4">0x20</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc2">// It uses the upper word for standard unix attr, which we must manually construct
</span><span class="sc0">  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">fa</span><span class="sc10">&amp;</span><span class="sc11">FILE_ATTRIBUTE_DIRECTORY</span><span class="sc10">)</span><span class="sc11">a</span><span class="sc10">|=</span><span class="sc4">0x40000000</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc2">// directory
</span><span class="sc0">  </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc11">a</span><span class="sc10">|=</span><span class="sc4">0x80000000</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc2">// normal file
</span><span class="sc0">  </span><span class="sc11">a</span><span class="sc10">|=</span><span class="sc4">0x01000000</span><span class="sc10">;</span><span class="sc0">      </span><span class="sc2">// readable
</span><span class="sc0">  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">fa</span><span class="sc10">&amp;</span><span class="sc11">FILE_ATTRIBUTE_READONLY</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{}</span><span class="sc0">
  </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc11">a</span><span class="sc10">|=</span><span class="sc4">0x00800000</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// writeable
</span><span class="sc0">  </span><span class="sc2">// now just a small heuristic to check if it's an executable:
</span><span class="sc0">  </span><span class="sc11">DWORD</span><span class="sc0"> </span><span class="sc11">red</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">hsize</span><span class="sc10">=</span><span class="sc11">GetFileSize</span><span class="sc10">(</span><span class="sc11">hf</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hsize</span><span class="sc10">&gt;</span><span class="sc4">40</span><span class="sc10">)</span><span class="sc0">
  </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">SetFilePointer</span><span class="sc10">(</span><span class="sc11">hf</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">,</span><span class="sc11">FILE_BEGIN</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">short</span><span class="sc0"> </span><span class="sc11">magic</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">ReadFile</span><span class="sc10">(</span><span class="sc11">hf</span><span class="sc10">,&amp;</span><span class="sc11">magic</span><span class="sc10">,</span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">magic</span><span class="sc10">),&amp;</span><span class="sc11">red</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">SetFilePointer</span><span class="sc10">(</span><span class="sc11">hf</span><span class="sc10">,</span><span class="sc4">36</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">,</span><span class="sc11">FILE_BEGIN</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc0"> </span><span class="sc11">hpos</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc11">ReadFile</span><span class="sc10">(</span><span class="sc11">hf</span><span class="sc10">,&amp;</span><span class="sc11">hpos</span><span class="sc10">,</span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">hpos</span><span class="sc10">),&amp;</span><span class="sc11">red</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">magic</span><span class="sc10">==</span><span class="sc4">0x54AD</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">hsize</span><span class="sc10">&gt;</span><span class="sc11">hpos</span><span class="sc10">+</span><span class="sc4">4</span><span class="sc10">+</span><span class="sc4">20</span><span class="sc10">+</span><span class="sc4">28</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">SetFilePointer</span><span class="sc10">(</span><span class="sc11">hf</span><span class="sc10">,</span><span class="sc11">hpos</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">,</span><span class="sc11">FILE_BEGIN</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc0"> </span><span class="sc11">signature</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">ReadFile</span><span class="sc10">(</span><span class="sc11">hf</span><span class="sc10">,&amp;</span><span class="sc11">signature</span><span class="sc10">,</span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">signature</span><span class="sc10">),&amp;</span><span class="sc11">red</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">);</span><span class="sc0">
      </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">signature</span><span class="sc10">==</span><span class="sc11">IMAGE_DOS_SIGNATURE</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">signature</span><span class="sc10">==</span><span class="sc11">IMAGE_OS2_SIGNATURE</span><span class="sc0">
         </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">signature</span><span class="sc10">==</span><span class="sc11">IMAGE_OS2_SIGNATURE_LE</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">signature</span><span class="sc10">==</span><span class="sc11">IMAGE_NT_SIGNATURE</span><span class="sc10">)</span><span class="sc0">
      </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">a</span><span class="sc0"> </span><span class="sc10">|=</span><span class="sc0"> </span><span class="sc4">0x00400000</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// executable
</span><span class="sc0">      </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
  </span><span class="sc10">}</span><span class="sc0">
  </span><span class="sc2">//
</span><span class="sc0">  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">attr</span><span class="sc10">!=</span><span class="sc5">NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">attr</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">a</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">size</span><span class="sc10">!=</span><span class="sc5">NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">size</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">hsize</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">times</span><span class="sc10">!=</span><span class="sc5">NULL</span><span class="sc10">)</span><span class="sc0">
  </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc2">// time_t is 32bit number of seconds elapsed since 0:0:0GMT, Jan1, 1970.
</span><span class="sc0">    </span><span class="sc2">// but FILETIME is 64bit number of 100-nanosecs since Jan1, 1601
</span><span class="sc0">    </span><span class="sc11">times</span><span class="sc10">-&gt;</span><span class="sc11">atime</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">filetime2timet</span><span class="sc10">(</span><span class="sc11">bhi</span><span class="sc10">.</span><span class="sc11">ftLastAccessTime</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">times</span><span class="sc10">-&gt;</span><span class="sc11">mtime</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">filetime2timet</span><span class="sc10">(</span><span class="sc11">bhi</span><span class="sc10">.</span><span class="sc11">ftLastWriteTime</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">times</span><span class="sc10">-&gt;</span><span class="sc11">ctime</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">filetime2timet</span><span class="sc10">(</span><span class="sc11">bhi</span><span class="sc10">.</span><span class="sc11">ftCreationTime</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc10">}</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">timestamp</span><span class="sc10">!=</span><span class="sc5">NULL</span><span class="sc10">)</span><span class="sc0">
  </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">WORD</span><span class="sc0"> </span><span class="sc11">dosdate</span><span class="sc10">,</span><span class="sc11">dostime</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">FileTimeToDosDateTime</span><span class="sc10">(&amp;</span><span class="sc11">bhi</span><span class="sc10">.</span><span class="sc11">ftLastWriteTime</span><span class="sc10">,&amp;</span><span class="sc11">dosdate</span><span class="sc10">,&amp;</span><span class="sc11">dostime</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">*</span><span class="sc11">timestamp</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">WORD</span><span class="sc10">)</span><span class="sc11">dostime</span><span class="sc0"> </span><span class="sc10">|</span><span class="sc0"> </span><span class="sc10">(((</span><span class="sc11">DWORD</span><span class="sc10">)</span><span class="sc11">dosdate</span><span class="sc10">)&lt;&lt;</span><span class="sc4">16</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc10">}</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">





</span><span class="sc2">///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
</span><span class="sc0">
</span><span class="sc16">class</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc16">public</span><span class="sc10">:</span><span class="sc0">
  </span><span class="sc11">TZip</span><span class="sc10">()</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">hfout</span><span class="sc10">(</span><span class="sc4">0</span><span class="sc10">),</span><span class="sc11">hmapout</span><span class="sc10">(</span><span class="sc4">0</span><span class="sc10">),</span><span class="sc11">zfis</span><span class="sc10">(</span><span class="sc4">0</span><span class="sc10">),</span><span class="sc11">obuf</span><span class="sc10">(</span><span class="sc4">0</span><span class="sc10">),</span><span class="sc11">hfin</span><span class="sc10">(</span><span class="sc4">0</span><span class="sc10">),</span><span class="sc11">writ</span><span class="sc10">(</span><span class="sc4">0</span><span class="sc10">),</span><span class="sc11">oerr</span><span class="sc10">(</span><span class="sc5">false</span><span class="sc10">),</span><span class="sc11">hasputcen</span><span class="sc10">(</span><span class="sc5">false</span><span class="sc10">),</span><span class="sc11">ooffset</span><span class="sc10">(</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{}</span><span class="sc0">
  </span><span class="sc10">~</span><span class="sc11">TZip</span><span class="sc10">()</span><span class="sc0"> </span><span class="sc10">{}</span><span class="sc0">

  </span><span class="sc2">// These variables say about the file we're writing into
</span><span class="sc0">  </span><span class="sc2">// We can write to pipe, file-by-handle, file-by-name, memory-to-memmapfile
</span><span class="sc0">  </span><span class="sc11">HANDLE</span><span class="sc0"> </span><span class="sc11">hfout</span><span class="sc10">;</span><span class="sc0">             </span><span class="sc2">// if valid, we'll write here (for files or pipes)
</span><span class="sc0">  </span><span class="sc11">HANDLE</span><span class="sc0"> </span><span class="sc11">hmapout</span><span class="sc10">;</span><span class="sc0">           </span><span class="sc2">// otherwise, we'll write here (for memmap)
</span><span class="sc0">  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">ooffset</span><span class="sc10">;</span><span class="sc0">         </span><span class="sc2">// for hfout, this is where the pointer was initially
</span><span class="sc0">  </span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">oerr</span><span class="sc10">;</span><span class="sc0">             </span><span class="sc2">// did a write operation give rise to an error?
</span><span class="sc0">  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">writ</span><span class="sc10">;</span><span class="sc0">            </span><span class="sc2">// how far have we written. This is maintained by Add, not write(), to avoid confusion over seeks
</span><span class="sc0">  </span><span class="sc16">bool</span><span class="sc0"> </span><span class="sc11">ocanseek</span><span class="sc10">;</span><span class="sc0">            </span><span class="sc2">// can we seek?
</span><span class="sc0">  </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">obuf</span><span class="sc10">;</span><span class="sc0">               </span><span class="sc2">// this is where we've locked mmap to view.
</span><span class="sc0">  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">opos</span><span class="sc10">;</span><span class="sc0">        </span><span class="sc2">// current pos in the mmap
</span><span class="sc0">  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">mapsize</span><span class="sc10">;</span><span class="sc0">     </span><span class="sc2">// the size of the map we created
</span><span class="sc0">  </span><span class="sc16">bool</span><span class="sc0"> </span><span class="sc11">hasputcen</span><span class="sc10">;</span><span class="sc0">           </span><span class="sc2">// have we yet placed the central directory?
</span><span class="sc0">  </span><span class="sc2">//
</span><span class="sc0">  </span><span class="sc11">TZipFileInfo</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">zfis</span><span class="sc10">;</span><span class="sc0">       </span><span class="sc2">// each file gets added onto this list, for writing the table at the end
</span><span class="sc0">
  </span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">Create</span><span class="sc10">(</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">z</span><span class="sc10">,</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">,</span><span class="sc11">DWORD</span><span class="sc0"> </span><span class="sc11">flags</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc16">static</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">sflush</span><span class="sc10">(</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">param</span><span class="sc10">,</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">size</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc16">static</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">swrite</span><span class="sc10">(</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">param</span><span class="sc10">,</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">write</span><span class="sc10">(</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc16">bool</span><span class="sc0"> </span><span class="sc11">oseek</span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">pos</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">GetMemory</span><span class="sc10">(</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">**</span><span class="sc11">pbuf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">plen</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">Close</span><span class="sc10">();</span><span class="sc0">

  </span><span class="sc2">// some variables to do with the file currently being read:
</span><span class="sc0">  </span><span class="sc2">// I haven't done it object-orientedly here, just put them all
</span><span class="sc0">  </span><span class="sc2">// together, since OO didn't seem to make the design any clearer.
</span><span class="sc0">  </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">attr</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">iztimes</span><span class="sc0"> </span><span class="sc11">times</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">timestamp</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc2">// all open_* methods set these
</span><span class="sc0">  </span><span class="sc16">bool</span><span class="sc0"> </span><span class="sc11">iseekable</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc0"> </span><span class="sc11">isize</span><span class="sc10">,</span><span class="sc11">ired</span><span class="sc10">;</span><span class="sc0">         </span><span class="sc2">// size is not set until close() on pips
</span><span class="sc0">  </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">crc</span><span class="sc10">;</span><span class="sc0">                                 </span><span class="sc2">// crc is not set until close(). iwrit is cumulative
</span><span class="sc0">  </span><span class="sc11">HANDLE</span><span class="sc0"> </span><span class="sc11">hfin</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc16">bool</span><span class="sc0"> </span><span class="sc11">selfclosehf</span><span class="sc10">;</span><span class="sc0">           </span><span class="sc2">// for input files and pipes
</span><span class="sc0">  </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">bufin</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">lenin</span><span class="sc10">,</span><span class="sc11">posin</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// for memory
</span><span class="sc0">  </span><span class="sc2">// and a variable for what we've done with the input: (i.e. compressed it!)
</span><span class="sc0">  </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">csize</span><span class="sc10">;</span><span class="sc0">                               </span><span class="sc2">// compressed size, set by the compression routines
</span><span class="sc0">  </span><span class="sc2">// and this is used by some of the compression routines
</span><span class="sc0">  </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc11">buf</span><span class="sc10">[</span><span class="sc4">16384</span><span class="sc10">];</span><span class="sc0">


  </span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">open_file</span><span class="sc10">(</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">TCHAR</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">fn</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">open_handle</span><span class="sc10">(</span><span class="sc11">HANDLE</span><span class="sc0"> </span><span class="sc11">hf</span><span class="sc10">,</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">open_mem</span><span class="sc10">(</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">src</span><span class="sc10">,</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">open_dir</span><span class="sc10">();</span><span class="sc0">
  </span><span class="sc16">static</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">sread</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">read</span><span class="sc10">(</span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">iclose</span><span class="sc10">();</span><span class="sc0">

  </span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">ideflate</span><span class="sc10">(</span><span class="sc11">TZipFileInfo</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">zfi</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">istore</span><span class="sc10">();</span><span class="sc0">

  </span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">Add</span><span class="sc10">(</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">odstzn</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">src</span><span class="sc10">,</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">DWORD</span><span class="sc0"> </span><span class="sc11">flags</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">AddCentral</span><span class="sc10">();</span><span class="sc0">

</span><span class="sc10">};</span><span class="sc0">

</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc10">::</span><span class="sc11">Create</span><span class="sc10">(</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">z</span><span class="sc10">,</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">,</span><span class="sc11">DWORD</span><span class="sc0"> </span><span class="sc11">flags</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> 
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hfout</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">hmapout</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">obuf</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">writ</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">oerr</span><span class="sc10">!=</span><span class="sc11">ZR_OK</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">hasputcen</span><span class="sc10">)</span><span class="sc0"> 
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_NOTINITED</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc2">//
</span><span class="sc0">    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">flags</span><span class="sc10">==</span><span class="sc11">ZIP_HANDLE</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc10">{</span><span class="sc0"> 
        </span><span class="sc11">HANDLE</span><span class="sc0"> </span><span class="sc11">hf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">HANDLE</span><span class="sc10">)</span><span class="sc11">z</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">BOOL</span><span class="sc0"> </span><span class="sc11">res</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">DuplicateHandle</span><span class="sc10">(</span><span class="sc11">GetCurrentProcess</span><span class="sc10">(),</span><span class="sc11">hf</span><span class="sc10">,</span><span class="sc11">GetCurrentProcess</span><span class="sc10">(),&amp;</span><span class="sc11">hfout</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc11">FALSE</span><span class="sc10">,</span><span class="sc11">DUPLICATE_SAME_ACCESS</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(!</span><span class="sc11">res</span><span class="sc10">)</span><span class="sc0"> 
            </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_NODUPH</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc2">// now we have our own hfout, which we must close. And the caller will close hf
</span><span class="sc0">        </span><span class="sc11">DWORD</span><span class="sc0"> </span><span class="sc11">type</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">GetFileType</span><span class="sc10">(</span><span class="sc11">hfout</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc11">ocanseek</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">type</span><span class="sc10">==</span><span class="sc11">FILE_TYPE_DISK</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">type</span><span class="sc10">==</span><span class="sc11">FILE_TYPE_DISK</span><span class="sc10">)</span><span class="sc0"> 
            </span><span class="sc11">ooffset</span><span class="sc10">=</span><span class="sc11">SetFilePointer</span><span class="sc10">(</span><span class="sc11">hfout</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">,</span><span class="sc11">FILE_CURRENT</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc5">else</span><span class="sc0"> 
            </span><span class="sc11">ooffset</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_OK</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">flags</span><span class="sc10">==</span><span class="sc11">ZIP_FILENAME</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc10">{</span><span class="sc0"> 
</span><span class="sc9">#ifdef _UNICODE
</span><span class="sc0">        </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">TCHAR</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">fn</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">TCHAR</span><span class="sc10">*)</span><span class="sc11">z</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">hfout</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">CreateFileW</span><span class="sc10">(</span><span class="sc11">fn</span><span class="sc10">,</span><span class="sc11">GENERIC_WRITE</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">,</span><span class="sc11">CREATE_ALWAYS</span><span class="sc10">,</span><span class="sc11">FILE_ATTRIBUTE_NORMAL</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc9">#else
</span><span class="sc0">        </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">fn</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc10">*)</span><span class="sc11">z</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">hfout</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">CreateFileA</span><span class="sc10">(</span><span class="sc11">fn</span><span class="sc10">,</span><span class="sc11">GENERIC_WRITE</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">,</span><span class="sc11">CREATE_ALWAYS</span><span class="sc10">,</span><span class="sc11">FILE_ATTRIBUTE_NORMAL</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hfout</span><span class="sc10">==</span><span class="sc11">INVALID_HANDLE_VALUE</span><span class="sc10">)</span><span class="sc0"> 
        </span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">hfout</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_NOFILE</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc11">ocanseek</span><span class="sc10">=</span><span class="sc5">true</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">ooffset</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_OK</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">flags</span><span class="sc10">==</span><span class="sc11">ZIP_MEMORY</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc10">{</span><span class="sc0"> 
        </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">size</span><span class="sc10">==</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> 
            </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_MEMSIZE</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> 
            </span><span class="sc11">obuf</span><span class="sc10">=(</span><span class="sc16">char</span><span class="sc10">*)</span><span class="sc11">z</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">else</span><span class="sc0">
        </span><span class="sc10">{</span><span class="sc0"> 
            </span><span class="sc11">hmapout</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">CreateFileMapping</span><span class="sc10">(</span><span class="sc11">INVALID_HANDLE_VALUE</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">,</span><span class="sc11">PAGE_READWRITE</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc11">size</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hmapout</span><span class="sc10">==</span><span class="sc5">NULL</span><span class="sc10">)</span><span class="sc0"> 
                </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_NOALLOC</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">obuf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">*)</span><span class="sc11">MapViewOfFile</span><span class="sc10">(</span><span class="sc11">hmapout</span><span class="sc10">,</span><span class="sc11">FILE_MAP_ALL_ACCESS</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc11">size</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">obuf</span><span class="sc10">==</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> 
            </span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">CloseHandle</span><span class="sc10">(</span><span class="sc11">hmapout</span><span class="sc10">);</span><span class="sc0"> 
                </span><span class="sc11">hmapout</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> 
                </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_NOALLOC</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc11">ocanseek</span><span class="sc10">=</span><span class="sc5">true</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">opos</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> 
        </span><span class="sc11">mapsize</span><span class="sc10">=</span><span class="sc11">size</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_OK</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">else</span><span class="sc0"> 
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_ARGS</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">


</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc10">::</span><span class="sc11">sflush</span><span class="sc10">(</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">param</span><span class="sc10">,</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">size</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc2">// static
</span><span class="sc0">  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(*</span><span class="sc11">size</span><span class="sc10">==</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">TZip</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">zip</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">TZip</span><span class="sc10">*)</span><span class="sc11">param</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">writ</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">zip</span><span class="sc10">-&gt;</span><span class="sc11">write</span><span class="sc10">(</span><span class="sc11">buf</span><span class="sc10">,*</span><span class="sc11">size</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">writ</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">size</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">writ</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">
</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc10">::</span><span class="sc11">swrite</span><span class="sc10">(</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">param</span><span class="sc10">,</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc2">// static
</span><span class="sc0">  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">size</span><span class="sc10">==</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">TZip</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">zip</span><span class="sc10">=(</span><span class="sc11">TZip</span><span class="sc10">*)</span><span class="sc11">param</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">zip</span><span class="sc10">-&gt;</span><span class="sc11">write</span><span class="sc10">(</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc11">size</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">
</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc10">::</span><span class="sc11">write</span><span class="sc10">(</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">obuf</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0">
  </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">opos</span><span class="sc10">+</span><span class="sc11">size</span><span class="sc10">&gt;=</span><span class="sc11">mapsize</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc11">oerr</span><span class="sc10">=</span><span class="sc11">ZR_MEMSIZE</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;}</span><span class="sc0">
    </span><span class="sc11">memcpy</span><span class="sc10">(</span><span class="sc11">obuf</span><span class="sc10">+</span><span class="sc11">opos</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">opos</span><span class="sc10">+=</span><span class="sc11">size</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc10">}</span><span class="sc0">
  </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hfout</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0">
  </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">DWORD</span><span class="sc0"> </span><span class="sc11">writ</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">WriteFile</span><span class="sc10">(</span><span class="sc11">hfout</span><span class="sc10">,</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc11">size</span><span class="sc10">,&amp;</span><span class="sc11">writ</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">writ</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc10">}</span><span class="sc0">
  </span><span class="sc11">oerr</span><span class="sc10">=</span><span class="sc11">ZR_NOTINITED</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc16">bool</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc10">::</span><span class="sc11">oseek</span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">pos</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(!</span><span class="sc11">ocanseek</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc11">oerr</span><span class="sc10">=</span><span class="sc11">ZR_SEEK</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc5">false</span><span class="sc10">;}</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">obuf</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0">
  </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">pos</span><span class="sc10">&gt;=</span><span class="sc11">mapsize</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc11">oerr</span><span class="sc10">=</span><span class="sc11">ZR_MEMSIZE</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc5">false</span><span class="sc10">;}</span><span class="sc0">
    </span><span class="sc11">opos</span><span class="sc10">=</span><span class="sc11">pos</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc5">true</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc10">}</span><span class="sc0">
  </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hfout</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0">
  </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">SetFilePointer</span><span class="sc10">(</span><span class="sc11">hfout</span><span class="sc10">,</span><span class="sc11">pos</span><span class="sc10">+</span><span class="sc11">ooffset</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">,</span><span class="sc11">FILE_BEGIN</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc5">true</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc10">}</span><span class="sc0">
  </span><span class="sc11">oerr</span><span class="sc10">=</span><span class="sc11">ZR_NOTINITED</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc10">::</span><span class="sc11">GetMemory</span><span class="sc10">(</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">**</span><span class="sc11">pbuf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">plen</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc2">// When the user calls GetMemory, they're presumably at the end
</span><span class="sc0">  </span><span class="sc2">// of all their adding. In any case, we have to add the central
</span><span class="sc0">  </span><span class="sc2">// directory now, otherwise the memory we tell them won't be complete.
</span><span class="sc0">  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(!</span><span class="sc11">hasputcen</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">AddCentral</span><span class="sc10">();</span><span class="sc0"> </span><span class="sc11">hasputcen</span><span class="sc10">=</span><span class="sc5">true</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">pbuf</span><span class="sc10">!=</span><span class="sc5">NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">pbuf</span><span class="sc10">=(</span><span class="sc16">void</span><span class="sc10">*)</span><span class="sc11">obuf</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">plen</span><span class="sc10">!=</span><span class="sc5">NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">plen</span><span class="sc10">=</span><span class="sc11">writ</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">obuf</span><span class="sc10">==</span><span class="sc5">NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_NOTMMAP</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc10">::</span><span class="sc11">Close</span><span class="sc10">()</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc2">// if the directory hadn't already been added through a call to GetMemory,
</span><span class="sc0">  </span><span class="sc2">// then we do it now
</span><span class="sc0">  </span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">res</span><span class="sc10">=</span><span class="sc11">ZR_OK</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(!</span><span class="sc11">hasputcen</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">res</span><span class="sc10">=</span><span class="sc11">AddCentral</span><span class="sc10">();</span><span class="sc0"> </span><span class="sc11">hasputcen</span><span class="sc10">=</span><span class="sc5">true</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">obuf</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">hmapout</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">UnmapViewOfFile</span><span class="sc10">(</span><span class="sc11">obuf</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc11">obuf</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hmapout</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">CloseHandle</span><span class="sc10">(</span><span class="sc11">hmapout</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc11">hmapout</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hfout</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">CloseHandle</span><span class="sc10">(</span><span class="sc11">hfout</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc11">hfout</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">res</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">




</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc10">::</span><span class="sc11">open_file</span><span class="sc10">(</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">TCHAR</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">fn</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">hfin</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bufin</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">selfclosehf</span><span class="sc10">=</span><span class="sc5">false</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">crc</span><span class="sc10">=</span><span class="sc11">CRCVAL_INITIAL</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">isize</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">csize</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">ired</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">fn</span><span class="sc10">==</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_ARGS</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">HANDLE</span><span class="sc0"> </span><span class="sc11">hf</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">CreateFile</span><span class="sc10">(</span><span class="sc11">fn</span><span class="sc10">,</span><span class="sc11">GENERIC_READ</span><span class="sc10">,</span><span class="sc11">FILE_SHARE_READ</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">,</span><span class="sc11">OPEN_EXISTING</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hf</span><span class="sc10">==</span><span class="sc11">INVALID_HANDLE_VALUE</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_NOFILE</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">res</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">open_handle</span><span class="sc10">(</span><span class="sc11">hf</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">res</span><span class="sc10">!=</span><span class="sc11">ZR_OK</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc11">CloseHandle</span><span class="sc10">(</span><span class="sc11">hf</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">res</span><span class="sc10">;}</span><span class="sc0">
  </span><span class="sc11">selfclosehf</span><span class="sc10">=</span><span class="sc5">true</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">
</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc10">::</span><span class="sc11">open_handle</span><span class="sc10">(</span><span class="sc11">HANDLE</span><span class="sc0"> </span><span class="sc11">hf</span><span class="sc10">,</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">hfin</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bufin</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">selfclosehf</span><span class="sc10">=</span><span class="sc5">false</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">crc</span><span class="sc10">=</span><span class="sc11">CRCVAL_INITIAL</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">isize</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">csize</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">ired</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hf</span><span class="sc10">==</span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">hf</span><span class="sc10">==</span><span class="sc11">INVALID_HANDLE_VALUE</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_ARGS</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">DWORD</span><span class="sc0"> </span><span class="sc11">type</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">GetFileType</span><span class="sc10">(</span><span class="sc11">hf</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">type</span><span class="sc10">==</span><span class="sc11">FILE_TYPE_DISK</span><span class="sc10">)</span><span class="sc0">
  </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">res</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">GetFileInfo</span><span class="sc10">(</span><span class="sc11">hf</span><span class="sc10">,&amp;</span><span class="sc11">attr</span><span class="sc10">,&amp;</span><span class="sc11">isize</span><span class="sc10">,&amp;</span><span class="sc11">times</span><span class="sc10">,&amp;</span><span class="sc11">timestamp</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">res</span><span class="sc10">!=</span><span class="sc11">ZR_OK</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">res</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">SetFilePointer</span><span class="sc10">(</span><span class="sc11">hf</span><span class="sc10">,</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">,</span><span class="sc11">FILE_BEGIN</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc2">// because GetFileInfo will have screwed it up
</span><span class="sc0">    </span><span class="sc11">iseekable</span><span class="sc10">=</span><span class="sc5">true</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">hfin</span><span class="sc10">=</span><span class="sc11">hf</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_OK</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc10">}</span><span class="sc0">
  </span><span class="sc5">else</span><span class="sc0">
  </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">attr</span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0x80000000</span><span class="sc10">;</span><span class="sc0">      </span><span class="sc2">// just a normal file
</span><span class="sc0">    </span><span class="sc11">isize</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">            </span><span class="sc2">// can't know size until at the end
</span><span class="sc0">    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">len</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">isize</span><span class="sc10">=</span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// unless we were told explicitly!
</span><span class="sc0">    </span><span class="sc11">iseekable</span><span class="sc10">=</span><span class="sc5">false</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">SYSTEMTIME</span><span class="sc0"> </span><span class="sc11">st</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">GetLocalTime</span><span class="sc10">(&amp;</span><span class="sc11">st</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">FILETIME</span><span class="sc0"> </span><span class="sc11">ft</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc11">SystemTimeToFileTime</span><span class="sc10">(&amp;</span><span class="sc11">st</span><span class="sc10">,&amp;</span><span class="sc11">ft</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">WORD</span><span class="sc0"> </span><span class="sc11">dosdate</span><span class="sc10">,</span><span class="sc11">dostime</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">FileTimeToDosDateTime</span><span class="sc10">(&amp;</span><span class="sc11">ft</span><span class="sc10">,&amp;</span><span class="sc11">dosdate</span><span class="sc10">,&amp;</span><span class="sc11">dostime</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">atime</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">filetime2timet</span><span class="sc10">(</span><span class="sc11">ft</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">mtime</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">atime</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">ctime</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">atime</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">timestamp</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">WORD</span><span class="sc10">)</span><span class="sc11">dostime</span><span class="sc0"> </span><span class="sc10">|</span><span class="sc0"> </span><span class="sc10">(((</span><span class="sc11">DWORD</span><span class="sc10">)</span><span class="sc11">dosdate</span><span class="sc10">)&lt;&lt;</span><span class="sc4">16</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">hfin</span><span class="sc10">=</span><span class="sc11">hf</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_OK</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc10">}</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">
</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc10">::</span><span class="sc11">open_mem</span><span class="sc10">(</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">src</span><span class="sc10">,</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">hfin</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bufin</span><span class="sc10">=(</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc10">*)</span><span class="sc11">src</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">selfclosehf</span><span class="sc10">=</span><span class="sc5">false</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">crc</span><span class="sc10">=</span><span class="sc11">CRCVAL_INITIAL</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">ired</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">csize</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">ired</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">lenin</span><span class="sc10">=</span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">posin</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">src</span><span class="sc10">==</span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">==</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_ARGS</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">attr</span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0x80000000</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// just a normal file
</span><span class="sc0">  </span><span class="sc11">isize</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">iseekable</span><span class="sc10">=</span><span class="sc5">true</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">SYSTEMTIME</span><span class="sc0"> </span><span class="sc11">st</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">GetLocalTime</span><span class="sc10">(&amp;</span><span class="sc11">st</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">FILETIME</span><span class="sc0"> </span><span class="sc11">ft</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc11">SystemTimeToFileTime</span><span class="sc10">(&amp;</span><span class="sc11">st</span><span class="sc10">,&amp;</span><span class="sc11">ft</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">WORD</span><span class="sc0"> </span><span class="sc11">dosdate</span><span class="sc10">,</span><span class="sc11">dostime</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">FileTimeToDosDateTime</span><span class="sc10">(&amp;</span><span class="sc11">ft</span><span class="sc10">,&amp;</span><span class="sc11">dosdate</span><span class="sc10">,&amp;</span><span class="sc11">dostime</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">atime</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">filetime2timet</span><span class="sc10">(</span><span class="sc11">ft</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">mtime</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">atime</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">ctime</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">atime</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">timestamp</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">WORD</span><span class="sc10">)</span><span class="sc11">dostime</span><span class="sc0"> </span><span class="sc10">|</span><span class="sc0"> </span><span class="sc10">(((</span><span class="sc11">DWORD</span><span class="sc10">)</span><span class="sc11">dosdate</span><span class="sc10">)&lt;&lt;</span><span class="sc4">16</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">
</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc10">::</span><span class="sc11">open_dir</span><span class="sc10">()</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">hfin</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">bufin</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">selfclosehf</span><span class="sc10">=</span><span class="sc5">false</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">crc</span><span class="sc10">=</span><span class="sc11">CRCVAL_INITIAL</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">isize</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">csize</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">ired</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">attr</span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0x41C00010</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// a readable writable directory, and again directory
</span><span class="sc0">  </span><span class="sc11">isize</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">iseekable</span><span class="sc10">=</span><span class="sc5">false</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">SYSTEMTIME</span><span class="sc0"> </span><span class="sc11">st</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">GetLocalTime</span><span class="sc10">(&amp;</span><span class="sc11">st</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">FILETIME</span><span class="sc0"> </span><span class="sc11">ft</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc11">SystemTimeToFileTime</span><span class="sc10">(&amp;</span><span class="sc11">st</span><span class="sc10">,&amp;</span><span class="sc11">ft</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">WORD</span><span class="sc0"> </span><span class="sc11">dosdate</span><span class="sc10">,</span><span class="sc11">dostime</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">FileTimeToDosDateTime</span><span class="sc10">(&amp;</span><span class="sc11">ft</span><span class="sc10">,&amp;</span><span class="sc11">dosdate</span><span class="sc10">,&amp;</span><span class="sc11">dostime</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">atime</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">filetime2timet</span><span class="sc10">(</span><span class="sc11">ft</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">mtime</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">atime</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">ctime</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">atime</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">timestamp</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">WORD</span><span class="sc10">)</span><span class="sc11">dostime</span><span class="sc0"> </span><span class="sc10">|</span><span class="sc0"> </span><span class="sc10">(((</span><span class="sc11">DWORD</span><span class="sc10">)</span><span class="sc11">dosdate</span><span class="sc10">)&lt;&lt;</span><span class="sc4">16</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc10">::</span><span class="sc11">sread</span><span class="sc10">(</span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">s</span><span class="sc10">,</span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc2">// static
</span><span class="sc0">  </span><span class="sc11">TZip</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">zip</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">TZip</span><span class="sc10">*)</span><span class="sc11">s</span><span class="sc10">.</span><span class="sc11">param</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">zip</span><span class="sc10">-&gt;</span><span class="sc11">read</span><span class="sc10">(</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc11">size</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc10">::</span><span class="sc11">read</span><span class="sc10">(</span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">bufin</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0">
  </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">posin</span><span class="sc10">&gt;=</span><span class="sc11">lenin</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// end of input
</span><span class="sc0">    </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">red</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">lenin</span><span class="sc10">-</span><span class="sc11">posin</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">red</span><span class="sc10">&gt;</span><span class="sc11">size</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">red</span><span class="sc10">=</span><span class="sc11">size</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">memcpy</span><span class="sc10">(</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">bufin</span><span class="sc10">+</span><span class="sc11">posin</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">red</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">posin</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">red</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">ired</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">red</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">crc</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">crc32</span><span class="sc10">(</span><span class="sc11">crc</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uch</span><span class="sc10">*)</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">red</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">red</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc10">}</span><span class="sc0">
  </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hfin</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0">
  </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">DWORD</span><span class="sc0"> </span><span class="sc11">red</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">BOOL</span><span class="sc0"> </span><span class="sc11">ok</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">ReadFile</span><span class="sc10">(</span><span class="sc11">hfin</span><span class="sc10">,</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc11">size</span><span class="sc10">,&amp;</span><span class="sc11">red</span><span class="sc10">,</span><span class="sc5">NULL</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(!</span><span class="sc11">ok</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">ired</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">red</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">crc</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">crc32</span><span class="sc10">(</span><span class="sc11">crc</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">uch</span><span class="sc10">*)</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">red</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">red</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc10">}</span><span class="sc0">
  </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc11">oerr</span><span class="sc10">=</span><span class="sc11">ZR_NOTINITED</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;}</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc10">::</span><span class="sc11">iclose</span><span class="sc10">()</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">selfclosehf</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">hfin</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">CloseHandle</span><span class="sc10">(</span><span class="sc11">hfin</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc11">hfin</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc16">bool</span><span class="sc0"> </span><span class="sc11">mismatch</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">isize</span><span class="sc10">!=-</span><span class="sc4">1</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">isize</span><span class="sc10">!=</span><span class="sc11">ired</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">isize</span><span class="sc10">=</span><span class="sc11">ired</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// and crc has been being updated anyway
</span><span class="sc0">  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">mismatch</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_MISSIZE</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">



</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc10">::</span><span class="sc11">ideflate</span><span class="sc10">(</span><span class="sc11">TZipFileInfo</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">zfi</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">TState</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">readfunc</span><span class="sc10">=</span><span class="sc11">sread</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">flush_outbuf</span><span class="sc10">=</span><span class="sc11">sflush</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">param</span><span class="sc10">=</span><span class="sc5">this</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">level</span><span class="sc10">=</span><span class="sc4">8</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">seekable</span><span class="sc10">=</span><span class="sc11">iseekable</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">err</span><span class="sc10">=</span><span class="sc5">NULL</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc2">// the following line will make ct_init realise it has to perform the init
</span><span class="sc0">  </span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">ts</span><span class="sc10">.</span><span class="sc11">static_dtree</span><span class="sc10">[</span><span class="sc4">0</span><span class="sc10">].</span><span class="sc11">dl</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc2">// It would be nicer if I could figure out precisely which data had to
</span><span class="sc0">  </span><span class="sc2">// be initted each time, and which didn't, but that's kind of difficult.
</span><span class="sc0">  </span><span class="sc2">// Maybe for the next version...
</span><span class="sc0">  </span><span class="sc2">//
</span><span class="sc0">  </span><span class="sc11">bi_init</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">buf</span><span class="sc10">),</span><span class="sc0"> </span><span class="sc11">TRUE</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc2">// it used to be just 1024-size, not 16384 as here
</span><span class="sc0">  </span><span class="sc11">ct_init</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,&amp;</span><span class="sc11">zfi</span><span class="sc10">-&gt;</span><span class="sc11">att</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">lm_init</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">,</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">level</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">zfi</span><span class="sc10">-&gt;</span><span class="sc11">flg</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">sz</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">deflate</span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc11">csize</span><span class="sc10">=</span><span class="sc11">sz</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">state</span><span class="sc10">.</span><span class="sc11">err</span><span class="sc10">!=</span><span class="sc5">NULL</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_FLATE</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc10">::</span><span class="sc11">istore</span><span class="sc10">()</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">size</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(;;)</span><span class="sc0">
  </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">cin</span><span class="sc10">=</span><span class="sc11">read</span><span class="sc10">(</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc4">16384</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">cin</span><span class="sc10">&lt;=</span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">cin</span><span class="sc10">==(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc10">)</span><span class="sc11">EOF</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">write</span><span class="sc10">(</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc11">cin</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">cout</span><span class="sc10">!=</span><span class="sc11">cin</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_MISSIZE</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">size</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">cin</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc10">}</span><span class="sc0">
  </span><span class="sc11">csize</span><span class="sc10">=</span><span class="sc11">size</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">




</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc10">::</span><span class="sc11">Add</span><span class="sc10">(</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">odstzn</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">src</span><span class="sc10">,</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">DWORD</span><span class="sc0"> </span><span class="sc11">flags</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> 
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">oerr</span><span class="sc10">)</span><span class="sc0"> 
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_FAILED</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hasputcen</span><span class="sc10">)</span><span class="sc0"> 
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_ENDED</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc2">// zip has its own notion of what its names should look like: i.e. dir/file.stuff
</span><span class="sc0">    </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc11">dstzn</span><span class="sc10">[</span><span class="sc11">MAX_PATH</span><span class="sc10">];</span><span class="sc0"> 
    </span><span class="sc11">strcpy</span><span class="sc10">(</span><span class="sc11">dstzn</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">odstzn</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(*</span><span class="sc11">dstzn</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> 
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_ARGS</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">d</span><span class="sc10">=</span><span class="sc11">dstzn</span><span class="sc10">;</span><span class="sc0"> 
    </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(*</span><span class="sc11">d</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> 
    </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(*</span><span class="sc11">d</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc7">'\\'</span><span class="sc10">)</span><span class="sc0"> 
            </span><span class="sc10">*</span><span class="sc11">d</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc7">'/'</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">d</span><span class="sc10">++;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc16">bool</span><span class="sc0"> </span><span class="sc11">isdir</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">flags</span><span class="sc10">==</span><span class="sc11">ZIP_FOLDER</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc16">bool</span><span class="sc0"> </span><span class="sc11">needs_trailing_slash</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">isdir</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">dstzn</span><span class="sc10">[</span><span class="sc11">strlen</span><span class="sc10">(</span><span class="sc11">dstzn</span><span class="sc10">)-</span><span class="sc4">1</span><span class="sc10">]!=</span><span class="sc7">'/'</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">method</span><span class="sc10">=</span><span class="sc11">DEFLATE</span><span class="sc10">;</span><span class="sc0"> 
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">isdir</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">HasZipSuffix</span><span class="sc10">(</span><span class="sc11">dstzn</span><span class="sc10">))</span><span class="sc0"> 
        </span><span class="sc11">method</span><span class="sc10">=</span><span class="sc11">STORE</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc2">// now open whatever was our input source:
</span><span class="sc0">    </span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">openres</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">flags</span><span class="sc10">==</span><span class="sc11">ZIP_FILENAME</span><span class="sc10">)</span><span class="sc0"> 
        </span><span class="sc11">openres</span><span class="sc10">=</span><span class="sc11">open_file</span><span class="sc10">((</span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">TCHAR</span><span class="sc10">*)</span><span class="sc11">src</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">flags</span><span class="sc10">==</span><span class="sc11">ZIP_HANDLE</span><span class="sc10">)</span><span class="sc0"> 
        </span><span class="sc11">openres</span><span class="sc10">=</span><span class="sc11">open_handle</span><span class="sc10">((</span><span class="sc11">HANDLE</span><span class="sc10">)</span><span class="sc11">src</span><span class="sc10">,</span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">flags</span><span class="sc10">==</span><span class="sc11">ZIP_MEMORY</span><span class="sc10">)</span><span class="sc0"> 
        </span><span class="sc11">openres</span><span class="sc10">=</span><span class="sc11">open_mem</span><span class="sc10">(</span><span class="sc11">src</span><span class="sc10">,</span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">flags</span><span class="sc10">==</span><span class="sc11">ZIP_FOLDER</span><span class="sc10">)</span><span class="sc0"> 
        </span><span class="sc11">openres</span><span class="sc10">=</span><span class="sc11">open_dir</span><span class="sc10">();</span><span class="sc0">
    </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_ARGS</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">openres</span><span class="sc10">!=</span><span class="sc11">ZR_OK</span><span class="sc10">)</span><span class="sc0"> 
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">openres</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc2">// A zip "entry" consists of a local header (which includes the file name),
</span><span class="sc0">    </span><span class="sc2">// then the compressed data, and possibly an extended local header.
</span><span class="sc0">
    </span><span class="sc2">// Initialize the local header
</span><span class="sc0">    </span><span class="sc11">TZipFileInfo</span><span class="sc0"> </span><span class="sc11">zfi</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">nxt</span><span class="sc10">=</span><span class="sc5">NULL</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">strcpy</span><span class="sc10">(</span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">name</span><span class="sc10">,</span><span class="sc6">""</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">strcpy</span><span class="sc10">(</span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">iname</span><span class="sc10">,</span><span class="sc11">dstzn</span><span class="sc10">);</span><span class="sc0"> 
    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">nam</span><span class="sc10">=</span><span class="sc11">strlen</span><span class="sc10">(</span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">iname</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">needs_trailing_slash</span><span class="sc10">)</span><span class="sc0"> 
    </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">strcat</span><span class="sc10">(</span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">iname</span><span class="sc10">,</span><span class="sc6">"/"</span><span class="sc10">);</span><span class="sc0"> 
        </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">nam</span><span class="sc10">++;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">strcpy</span><span class="sc10">(</span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">zname</span><span class="sc10">,</span><span class="sc6">""</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">extra</span><span class="sc10">=</span><span class="sc5">NULL</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">ext</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">   </span><span class="sc2">// extra header to go after this compressed data, and its length
</span><span class="sc0">    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">cextra</span><span class="sc10">=</span><span class="sc5">NULL</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">cext</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// extra header to go in the central end-of-zip directory, and its length
</span><span class="sc0">    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">comment</span><span class="sc10">=</span><span class="sc5">NULL</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">com</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// comment, and its length
</span><span class="sc0">    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">mark</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">dosflag</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">att</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">BINARY</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">vem</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc4">0xB17</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// 0xB00 is win32 os-code. 0x17 is 23 in decimal: zip 2.3
</span><span class="sc0">    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">ver</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc4">20</span><span class="sc10">;</span><span class="sc0">    </span><span class="sc2">// Needs PKUNZIP 2.0 to unzip it
</span><span class="sc0">    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">tim</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">timestamp</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc2">// Even though we write the header now, it will have to be rewritten, since we don't know compressed size or crc.
</span><span class="sc0">    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">crc</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">            </span><span class="sc2">// to be updated later
</span><span class="sc0">    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">flg</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">;</span><span class="sc0">            </span><span class="sc2">// 8 means 'there is an extra header'. Assume for the moment that we need it.
</span><span class="sc0">    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">lflg</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">flg</span><span class="sc10">;</span><span class="sc0">     </span><span class="sc2">// to be updated later
</span><span class="sc0">    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">how</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">method</span><span class="sc10">;</span><span class="sc0">  </span><span class="sc2">// to be updated later
</span><span class="sc0">    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">siz</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)(</span><span class="sc11">method</span><span class="sc10">==</span><span class="sc11">STORE</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">isize</span><span class="sc10">&gt;=</span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0"> </span><span class="sc11">isize</span><span class="sc0"> </span><span class="sc10">:</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc2">// to be updated later
</span><span class="sc0">    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ulg</span><span class="sc10">)(</span><span class="sc11">isize</span><span class="sc10">);</span><span class="sc0">  </span><span class="sc2">// to be updated later
</span><span class="sc0">    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">dsk</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">atx</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">attr</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">off</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">writ</span><span class="sc10">+</span><span class="sc11">ooffset</span><span class="sc10">;</span><span class="sc0">         </span><span class="sc2">// offset within file of the start of this local record
</span><span class="sc0">    </span><span class="sc2">// stuff the 'times' structure into zfi.extra
</span><span class="sc0">    </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc11">xloc</span><span class="sc10">[</span><span class="sc11">EB_L_UT_SIZE</span><span class="sc10">];</span><span class="sc0"> 
    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">extra</span><span class="sc10">=</span><span class="sc11">xloc</span><span class="sc10">;</span><span class="sc0">  
    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">ext</span><span class="sc10">=</span><span class="sc11">EB_L_UT_SIZE</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc11">xcen</span><span class="sc10">[</span><span class="sc11">EB_C_UT_SIZE</span><span class="sc10">];</span><span class="sc0"> 
    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">cextra</span><span class="sc10">=</span><span class="sc11">xcen</span><span class="sc10">;</span><span class="sc0"> 
    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">cext</span><span class="sc10">=</span><span class="sc11">EB_C_UT_SIZE</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">xloc</span><span class="sc10">[</span><span class="sc4">0</span><span class="sc10">]</span><span class="sc0">  </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc7">'U'</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">xloc</span><span class="sc10">[</span><span class="sc4">1</span><span class="sc10">]</span><span class="sc0">  </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc7">'T'</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">xloc</span><span class="sc10">[</span><span class="sc4">2</span><span class="sc10">]</span><span class="sc0">  </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">EB_UT_LEN</span><span class="sc10">(</span><span class="sc4">3</span><span class="sc10">);</span><span class="sc0">       </span><span class="sc2">// length of data part of e.f.
</span><span class="sc0">    </span><span class="sc11">xloc</span><span class="sc10">[</span><span class="sc4">3</span><span class="sc10">]</span><span class="sc0">  </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">xloc</span><span class="sc10">[</span><span class="sc4">4</span><span class="sc10">]</span><span class="sc0">  </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">EB_UT_FL_MTIME</span><span class="sc0"> </span><span class="sc10">|</span><span class="sc0"> </span><span class="sc11">EB_UT_FL_ATIME</span><span class="sc0"> </span><span class="sc10">|</span><span class="sc0"> </span><span class="sc11">EB_UT_FL_CTIME</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">xloc</span><span class="sc10">[</span><span class="sc4">5</span><span class="sc10">]</span><span class="sc0">  </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">)(</span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">mtime</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">xloc</span><span class="sc10">[</span><span class="sc4">6</span><span class="sc10">]</span><span class="sc0">  </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">)(</span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">mtime</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">xloc</span><span class="sc10">[</span><span class="sc4">7</span><span class="sc10">]</span><span class="sc0">  </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">)(</span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">mtime</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">16</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">xloc</span><span class="sc10">[</span><span class="sc4">8</span><span class="sc10">]</span><span class="sc0">  </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">)(</span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">mtime</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">24</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">xloc</span><span class="sc10">[</span><span class="sc4">9</span><span class="sc10">]</span><span class="sc0">  </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">)(</span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">atime</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">xloc</span><span class="sc10">[</span><span class="sc4">10</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">)(</span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">atime</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">xloc</span><span class="sc10">[</span><span class="sc4">11</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">)(</span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">atime</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">16</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">xloc</span><span class="sc10">[</span><span class="sc4">12</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">)(</span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">atime</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">24</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">xloc</span><span class="sc10">[</span><span class="sc4">13</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">)(</span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">ctime</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">xloc</span><span class="sc10">[</span><span class="sc4">14</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">)(</span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">ctime</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">8</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">xloc</span><span class="sc10">[</span><span class="sc4">15</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">)(</span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">ctime</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">16</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">xloc</span><span class="sc10">[</span><span class="sc4">16</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">)(</span><span class="sc11">times</span><span class="sc10">.</span><span class="sc11">ctime</span><span class="sc0"> </span><span class="sc10">&gt;&gt;</span><span class="sc0"> </span><span class="sc4">24</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">memcpy</span><span class="sc10">(</span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">cextra</span><span class="sc10">,</span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">extra</span><span class="sc10">,</span><span class="sc11">EB_C_UT_SIZE</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">cextra</span><span class="sc10">[</span><span class="sc11">EB_LEN</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">EB_UT_LEN</span><span class="sc10">(</span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0">


    </span><span class="sc2">// (1) Start by writing the local header:
</span><span class="sc0">    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">r</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">putlocal</span><span class="sc10">(&amp;</span><span class="sc11">zfi</span><span class="sc10">,</span><span class="sc11">swrite</span><span class="sc10">,</span><span class="sc5">this</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">r</span><span class="sc10">!=</span><span class="sc11">ZE_OK</span><span class="sc10">)</span><span class="sc0"> 
    </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">iclose</span><span class="sc10">();</span><span class="sc0"> 
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_WRITE</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">writ</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">LOCHEAD</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc10">)</span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">nam</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc10">)</span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">ext</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">oerr</span><span class="sc10">!=</span><span class="sc11">ZR_OK</span><span class="sc10">)</span><span class="sc0"> 
    </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">iclose</span><span class="sc10">();</span><span class="sc0"> 
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">oerr</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc2">//(2) Write deflated/stored file to zip file
</span><span class="sc0">    </span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">writeres</span><span class="sc10">=</span><span class="sc11">ZR_OK</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(!</span><span class="sc11">isdir</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">method</span><span class="sc10">==</span><span class="sc11">DEFLATE</span><span class="sc10">)</span><span class="sc0"> 
        </span><span class="sc11">writeres</span><span class="sc10">=</span><span class="sc11">ideflate</span><span class="sc10">(&amp;</span><span class="sc11">zfi</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(!</span><span class="sc11">isdir</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">method</span><span class="sc10">==</span><span class="sc11">STORE</span><span class="sc10">)</span><span class="sc0"> 
        </span><span class="sc11">writeres</span><span class="sc10">=</span><span class="sc11">istore</span><span class="sc10">();</span><span class="sc0">
    </span><span class="sc5">else</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">isdir</span><span class="sc10">)</span><span class="sc0"> 
        </span><span class="sc11">csize</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">iclose</span><span class="sc10">();</span><span class="sc0">
    </span><span class="sc11">writ</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc11">csize</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">oerr</span><span class="sc10">!=</span><span class="sc11">ZR_OK</span><span class="sc10">)</span><span class="sc0"> 
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">oerr</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">writeres</span><span class="sc10">!=</span><span class="sc11">ZR_OK</span><span class="sc10">)</span><span class="sc0"> 
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_WRITE</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc2">// (3) Either rewrite the local header with correct information...
</span><span class="sc0">    </span><span class="sc16">bool</span><span class="sc0"> </span><span class="sc11">first_header_has_size_right</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">siz</span><span class="sc10">==</span><span class="sc11">csize</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">crc</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">crc</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">siz</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">csize</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">len</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">isize</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ocanseek</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc10">{</span><span class="sc0"> 
        </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">how</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc11">method</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">flg</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> 
            </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">flg</span><span class="sc0"> </span><span class="sc10">&amp;=</span><span class="sc0"> </span><span class="sc10">~</span><span class="sc4">8</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// clear the extended local header flag
</span><span class="sc0">        </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">lflg</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">flg</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc2">// rewrite the local header:
</span><span class="sc0">        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(!</span><span class="sc11">oseek</span><span class="sc10">(</span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">off</span><span class="sc10">-</span><span class="sc11">ooffset</span><span class="sc10">))</span><span class="sc0"> 
            </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_SEEK</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">r</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">putlocal</span><span class="sc10">(&amp;</span><span class="sc11">zfi</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">swrite</span><span class="sc10">,</span><span class="sc5">this</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">ZE_OK</span><span class="sc10">)</span><span class="sc0"> 
            </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_WRITE</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(!</span><span class="sc11">oseek</span><span class="sc10">(</span><span class="sc11">writ</span><span class="sc10">))</span><span class="sc0"> 
            </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_SEEK</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">else</span><span class="sc0">
    </span><span class="sc10">{</span><span class="sc0"> 
        </span><span class="sc2">// (4) ... or put an updated header at the end
</span><span class="sc0">        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">how</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">ush</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">method</span><span class="sc10">)</span><span class="sc0"> 
            </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_NOCHANGE</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">method</span><span class="sc10">==</span><span class="sc11">STORE</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc10">!</span><span class="sc11">first_header_has_size_right</span><span class="sc10">)</span><span class="sc0"> 
            </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_NOCHANGE</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">r</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">putextended</span><span class="sc10">(&amp;</span><span class="sc11">zfi</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">swrite</span><span class="sc10">,</span><span class="sc5">this</span><span class="sc10">))</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">ZE_OK</span><span class="sc10">)</span><span class="sc0"> 
            </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_WRITE</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">writ</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">16L</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">flg</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">lflg</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc2">// if flg modified by inflate, for the central index
</span><span class="sc0">    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">oerr</span><span class="sc10">!=</span><span class="sc11">ZR_OK</span><span class="sc10">)</span><span class="sc0"> 
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">oerr</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc2">// Keep a copy of the zipfileinfo, for our end-of-zip directory
</span><span class="sc0">    </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">cextra</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc5">new</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc10">[</span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">cext</span><span class="sc10">];</span><span class="sc0"> 
    </span><span class="sc11">memcpy</span><span class="sc10">(</span><span class="sc11">cextra</span><span class="sc10">,</span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">cextra</span><span class="sc10">,</span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">cext</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc11">zfi</span><span class="sc10">.</span><span class="sc11">cextra</span><span class="sc10">=</span><span class="sc11">cextra</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">TZipFileInfo</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">pzfi</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc5">new</span><span class="sc0"> </span><span class="sc11">TZipFileInfo</span><span class="sc10">;</span><span class="sc0"> 
    </span><span class="sc11">memcpy</span><span class="sc10">(</span><span class="sc11">pzfi</span><span class="sc10">,&amp;</span><span class="sc11">zfi</span><span class="sc10">,</span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">zfi</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">zfis</span><span class="sc10">==</span><span class="sc5">NULL</span><span class="sc10">)</span><span class="sc0"> 
        </span><span class="sc11">zfis</span><span class="sc10">=</span><span class="sc11">pzfi</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">else</span><span class="sc0"> 
    </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">TZipFileInfo</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">z</span><span class="sc10">=</span><span class="sc11">zfis</span><span class="sc10">;</span><span class="sc0"> 
        </span><span class="sc5">while</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">nxt</span><span class="sc10">!=</span><span class="sc5">NULL</span><span class="sc10">)</span><span class="sc0"> 
            </span><span class="sc11">z</span><span class="sc10">=</span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">nxt</span><span class="sc10">;</span><span class="sc0"> 
        </span><span class="sc11">z</span><span class="sc10">-&gt;</span><span class="sc11">nxt</span><span class="sc10">=</span><span class="sc11">pzfi</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc10">::</span><span class="sc11">AddCentral</span><span class="sc10">()</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc2">// write central directory
</span><span class="sc0">  </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">numentries</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">pos_at_start_of_central</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">writ</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc2">//ulg tot_unc_size=0, tot_compressed_size=0;
</span><span class="sc0">  </span><span class="sc16">bool</span><span class="sc0"> </span><span class="sc11">okay</span><span class="sc10">=</span><span class="sc5">true</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">for</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">TZipFileInfo</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">zfi</span><span class="sc10">=</span><span class="sc11">zfis</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">zfi</span><span class="sc10">!=</span><span class="sc5">NULL</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc10">)</span><span class="sc0">
  </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">okay</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">res</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">putcentral</span><span class="sc10">(</span><span class="sc11">zfi</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">swrite</span><span class="sc10">,</span><span class="sc5">this</span><span class="sc10">);</span><span class="sc0">
      </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">res</span><span class="sc10">!=</span><span class="sc11">ZE_OK</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">okay</span><span class="sc10">=</span><span class="sc5">false</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">writ</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">CENHEAD</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc10">)</span><span class="sc11">zfi</span><span class="sc10">-&gt;</span><span class="sc11">nam</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc10">)</span><span class="sc11">zfi</span><span class="sc10">-&gt;</span><span class="sc11">cext</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc10">)</span><span class="sc11">zfi</span><span class="sc10">-&gt;</span><span class="sc11">com</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc2">//tot_unc_size += zfi-&gt;len;
</span><span class="sc0">    </span><span class="sc2">//tot_compressed_size += zfi-&gt;siz;
</span><span class="sc0">    </span><span class="sc11">numentries</span><span class="sc10">++;</span><span class="sc0">
    </span><span class="sc2">//
</span><span class="sc0">    </span><span class="sc11">TZipFileInfo</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">zfinext</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">zfi</span><span class="sc10">-&gt;</span><span class="sc11">nxt</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">zfi</span><span class="sc10">-&gt;</span><span class="sc11">cextra</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">delete</span><span class="sc10">[]</span><span class="sc0"> </span><span class="sc11">zfi</span><span class="sc10">-&gt;</span><span class="sc11">cextra</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">delete</span><span class="sc0"> </span><span class="sc11">zfi</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">zfi</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">zfinext</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc10">}</span><span class="sc0">
  </span><span class="sc11">ulg</span><span class="sc0"> </span><span class="sc11">center_size</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">writ</span><span class="sc0"> </span><span class="sc10">-</span><span class="sc0"> </span><span class="sc11">pos_at_start_of_central</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">okay</span><span class="sc10">)</span><span class="sc0">
  </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">res</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">putend</span><span class="sc10">(</span><span class="sc11">numentries</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">center_size</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">pos_at_start_of_central</span><span class="sc10">+</span><span class="sc11">ooffset</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc5">NULL</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">swrite</span><span class="sc10">,</span><span class="sc5">this</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">res</span><span class="sc10">!=</span><span class="sc11">ZE_OK</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">okay</span><span class="sc10">=</span><span class="sc5">false</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">writ</span><span class="sc0"> </span><span class="sc10">+=</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc11">ENDHEAD</span><span class="sc0"> </span><span class="sc10">+</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc10">}</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(!</span><span class="sc11">okay</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_WRITE</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_OK</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">





</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">lasterrorZ</span><span class="sc10">=</span><span class="sc11">ZR_OK</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">FormatZipMessageZ</span><span class="sc10">(</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">code</span><span class="sc10">==</span><span class="sc11">ZR_RECENT</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">code</span><span class="sc10">=</span><span class="sc11">lasterrorZ</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"unknown zip result code"</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">switch</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">code</span><span class="sc10">)</span><span class="sc0">
  </span><span class="sc10">{</span><span class="sc0"> </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_OK</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Success"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_NODUPH</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Culdn't duplicate handle"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_NOFILE</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Couldn't create/open file"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_NOALLOC</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Failed to allocate memory"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_WRITE</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Error writing to file"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_NOTFOUND</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"File not found in the zipfile"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_MORE</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Still more data to unzip"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_CORRUPT</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Zipfile is corrupt or not a zipfile"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_READ</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Error reading file"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_ARGS</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Caller: faulty arguments"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_PARTIALUNZ</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Caller: the file had already been partially unzipped"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_NOTMMAP</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Caller: can only get memory of a memory zipfile"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_MEMSIZE</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Caller: not enough space allocated for memory zipfile"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_FAILED</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Caller: there was a previous error"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_ENDED</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Caller: additions to the zip have already been ended"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_ZMODE</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Caller: mixing creation and opening of zip"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_NOTINITED</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Zip-bug: internal initialisation not completed"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_SEEK</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Zip-bug: trying to seek the unseekable"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_MISSIZE</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Zip-bug: the anticipated size turned out wrong"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_NOCHANGE</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Zip-bug: tried to change mind, but not allowed"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">case</span><span class="sc0"> </span><span class="sc11">ZR_FLATE</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc11">msg</span><span class="sc10">=</span><span class="sc6">"Zip-bug: an internal error during flation"</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc10">}</span><span class="sc0">
  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">mlen</span><span class="sc10">=(</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc10">)</span><span class="sc11">strlen</span><span class="sc10">(</span><span class="sc11">msg</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">buf</span><span class="sc10">==</span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">||</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">==</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">mlen</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">=</span><span class="sc11">mlen</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">n</span><span class="sc10">+</span><span class="sc4">1</span><span class="sc10">&gt;</span><span class="sc11">len</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">n</span><span class="sc10">=</span><span class="sc11">len</span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">strncpy</span><span class="sc10">(</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc11">msg</span><span class="sc10">,</span><span class="sc11">n</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc11">buf</span><span class="sc10">[</span><span class="sc11">n</span><span class="sc10">]=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">mlen</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">



</span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">struct</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc11">DWORD</span><span class="sc0"> </span><span class="sc11">flag</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">TZip</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">zip</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0"> </span><span class="sc11">TZipHandleData</span><span class="sc10">;</span><span class="sc0">


</span><span class="sc11">HZIP</span><span class="sc0"> </span><span class="sc11">CreateZipZ</span><span class="sc10">(</span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">z</span><span class="sc10">,</span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">,</span><span class="sc11">DWORD</span><span class="sc0"> </span><span class="sc11">flags</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> 
    </span><span class="sc11">tzset</span><span class="sc10">();</span><span class="sc0">
    </span><span class="sc11">TZip</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">zip</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc5">new</span><span class="sc0"> </span><span class="sc11">TZip</span><span class="sc10">();</span><span class="sc0">
    </span><span class="sc11">lasterrorZ</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">zip</span><span class="sc10">-&gt;</span><span class="sc11">Create</span><span class="sc10">(</span><span class="sc11">z</span><span class="sc10">,</span><span class="sc11">len</span><span class="sc10">,</span><span class="sc11">flags</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">lasterrorZ</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc11">ZR_OK</span><span class="sc10">)</span><span class="sc0"> 
    </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc5">delete</span><span class="sc0"> </span><span class="sc11">zip</span><span class="sc10">;</span><span class="sc0"> 
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">TZipHandleData</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">han</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc5">new</span><span class="sc0"> </span><span class="sc11">TZipHandleData</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">han</span><span class="sc10">-&gt;</span><span class="sc11">flag</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0"> 
    </span><span class="sc11">han</span><span class="sc10">-&gt;</span><span class="sc11">zip</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">zip</span><span class="sc10">;</span><span class="sc0"> 
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">HZIP</span><span class="sc10">)</span><span class="sc11">han</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">ZipAdd</span><span class="sc10">(</span><span class="sc11">HZIP</span><span class="sc0"> </span><span class="sc11">hz</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">TCHAR</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">dstzn</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">src</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">DWORD</span><span class="sc0"> </span><span class="sc11">flags</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> 
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hz</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> 
    </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">lasterrorZ</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">ZR_ARGS</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_ARGS</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">TZipHandleData</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">han</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">TZipHandleData</span><span class="sc10">*)</span><span class="sc11">hz</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">han</span><span class="sc10">-&gt;</span><span class="sc11">flag</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> 
    </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">lasterrorZ</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">ZR_ZMODE</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_ZMODE</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">TZip</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">zip</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">han</span><span class="sc10">-&gt;</span><span class="sc11">zip</span><span class="sc10">;</span><span class="sc0">


    </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">flags</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc11">ZIP_FILENAME</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc11">szDest</span><span class="sc10">[</span><span class="sc11">MAX_PATH</span><span class="sc10">*</span><span class="sc4">2</span><span class="sc10">];</span><span class="sc0">
        </span><span class="sc11">memset</span><span class="sc10">(</span><span class="sc11">szDest</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc5">sizeof</span><span class="sc10">(</span><span class="sc11">szDest</span><span class="sc10">));</span><span class="sc0">

</span><span class="sc9">#ifdef _UNICODE
</span><span class="sc0">        </span><span class="sc2">// need to convert Unicode dest to ANSI
</span><span class="sc0">        </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">nActualChars</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">WideCharToMultiByte</span><span class="sc10">(</span><span class="sc11">CP_ACP</span><span class="sc10">,</span><span class="sc0">  </span><span class="sc2">// code page
</span><span class="sc0">                                </span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0">                      </span><span class="sc2">// performance and mapping flags
</span><span class="sc0">                                </span><span class="sc10">(</span><span class="sc11">LPCWSTR</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc11">dstzn</span><span class="sc10">,</span><span class="sc0">        </span><span class="sc2">// wide-character string
</span><span class="sc0">                                </span><span class="sc10">-</span><span class="sc4">1</span><span class="sc10">,</span><span class="sc0">                     </span><span class="sc2">// number of chars in string
</span><span class="sc0">                                </span><span class="sc11">szDest</span><span class="sc10">,</span><span class="sc0">                 </span><span class="sc2">// buffer for new string
</span><span class="sc0">                                </span><span class="sc11">MAX_PATH</span><span class="sc10">*</span><span class="sc4">2</span><span class="sc10">-</span><span class="sc4">2</span><span class="sc10">,</span><span class="sc0">           </span><span class="sc2">// size of buffer
</span><span class="sc0">                                </span><span class="sc5">NULL</span><span class="sc10">,</span><span class="sc0">                   </span><span class="sc2">// default for unmappable chars
</span><span class="sc0">                                </span><span class="sc5">NULL</span><span class="sc10">);</span><span class="sc0">                  </span><span class="sc2">// set when default char used
</span><span class="sc0">        </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">nActualChars</span><span class="sc0"> </span><span class="sc10">==</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0">
            </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_ARGS</span><span class="sc10">;</span><span class="sc0"> 
</span><span class="sc9">#else
</span><span class="sc0">        </span><span class="sc11">strcpy</span><span class="sc10">(</span><span class="sc11">szDest</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">dstzn</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc9">#endif
</span><span class="sc0">
        </span><span class="sc11">lasterrorZ</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">zip</span><span class="sc10">-&gt;</span><span class="sc11">Add</span><span class="sc10">(</span><span class="sc11">szDest</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">src</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">flags</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">else</span><span class="sc0">
    </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">lasterrorZ</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">zip</span><span class="sc10">-&gt;</span><span class="sc11">Add</span><span class="sc10">((</span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*)</span><span class="sc11">dstzn</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">src</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">len</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">flags</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">lasterrorZ</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">ZipGetMemory</span><span class="sc10">(</span><span class="sc11">HZIP</span><span class="sc0"> </span><span class="sc11">hz</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">void</span><span class="sc0"> </span><span class="sc10">**</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">len</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hz</span><span class="sc10">==</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">buf</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buf</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">len</span><span class="sc10">!=</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">len</span><span class="sc10">=</span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">lasterrorZ</span><span class="sc10">=</span><span class="sc11">ZR_ARGS</span><span class="sc10">;</span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_ARGS</span><span class="sc10">;}</span><span class="sc0">
  </span><span class="sc11">TZipHandleData</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">han</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">TZipHandleData</span><span class="sc10">*)</span><span class="sc11">hz</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">han</span><span class="sc10">-&gt;</span><span class="sc11">flag</span><span class="sc10">!=</span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc11">lasterrorZ</span><span class="sc10">=</span><span class="sc11">ZR_ZMODE</span><span class="sc10">;</span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_ZMODE</span><span class="sc10">;}</span><span class="sc0">
  </span><span class="sc11">TZip</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">zip</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">han</span><span class="sc10">-&gt;</span><span class="sc11">zip</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">lasterrorZ</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">zip</span><span class="sc10">-&gt;</span><span class="sc11">GetMemory</span><span class="sc10">(</span><span class="sc11">buf</span><span class="sc10">,</span><span class="sc11">len</span><span class="sc10">);</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">lasterrorZ</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc11">ZRESULT</span><span class="sc0"> </span><span class="sc11">CloseZipZ</span><span class="sc10">(</span><span class="sc11">HZIP</span><span class="sc0"> </span><span class="sc11">hz</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hz</span><span class="sc10">==</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc11">lasterrorZ</span><span class="sc10">=</span><span class="sc11">ZR_ARGS</span><span class="sc10">;</span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_ARGS</span><span class="sc10">;}</span><span class="sc0">
  </span><span class="sc11">TZipHandleData</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">han</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">TZipHandleData</span><span class="sc10">*)</span><span class="sc11">hz</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">han</span><span class="sc10">-&gt;</span><span class="sc11">flag</span><span class="sc10">!=</span><span class="sc4">2</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc11">lasterrorZ</span><span class="sc10">=</span><span class="sc11">ZR_ZMODE</span><span class="sc10">;</span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ZR_ZMODE</span><span class="sc10">;}</span><span class="sc0">
  </span><span class="sc11">TZip</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">zip</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">han</span><span class="sc10">-&gt;</span><span class="sc11">zip</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">lasterrorZ</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">zip</span><span class="sc10">-&gt;</span><span class="sc11">Close</span><span class="sc10">();</span><span class="sc0">
  </span><span class="sc5">delete</span><span class="sc0"> </span><span class="sc11">zip</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">delete</span><span class="sc0"> </span><span class="sc11">han</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">lasterrorZ</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc16">bool</span><span class="sc0"> </span><span class="sc11">IsZipHandleZ</span><span class="sc10">(</span><span class="sc11">HZIP</span><span class="sc0"> </span><span class="sc11">hz</span><span class="sc10">)</span><span class="sc0">
</span><span class="sc10">{</span><span class="sc0"> </span><span class="sc5">if</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">hz</span><span class="sc10">==</span><span class="sc4">0</span><span class="sc10">)</span><span class="sc0"> </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc5">true</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc11">TZipHandleData</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">han</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">TZipHandleData</span><span class="sc10">*)</span><span class="sc11">hz</span><span class="sc10">;</span><span class="sc0">
  </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">han</span><span class="sc10">-&gt;</span><span class="sc11">flag</span><span class="sc10">==</span><span class="sc4">2</span><span class="sc10">);</span><span class="sc0">
</span><span class="sc10">}</span></div></body>
</html>
