<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>PHANTOM.TXT</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc0">
                Direct Phantom
                ──────────────
          A includable Simulated Polymorphic Generator
          ────────────────────────────────────────────


 Mutation Engine. Ну вот и я решил попробовать себя в этой области.
 Уж не знаю как получилось, но думаю на Уровне. Только не знаю на каком:

 [ Использование в расшифровщике взамозаменяемых инструкций и "перемешивание"
   инструкций между собой без изменения алгоритма шифрования,а также расшифровщик
   может использовать различные алгоритмы шифрования вирусного кода.]
   (C) кажется Данилова ?

 Direct Phantom - это подключаемый генератор,моделирующий
 полиморфные расшифровщики. В этой версии DPH 1.0 длинна декриптора
 варьируется от 50 до 100 байт без мусора. Алгоритм шифрования
 составляется из 13 команд на RND(8...16) позиций - от 0.8*10^9 до 6.6*10^17
 комбинаций команд

 Вызов
 ─────

 Нужно заполнить структуру

 (1)
 TARGETPLACE   : SEG:OFFS - место генерения декриптора
 DEST_CODE     : адрес шифруемой области,SEG декриптора
 COUNTER       : длинна области
 LENDECRYPTOR  : длинна декриптора = 0
 RELOFFS       : дополнительное смещение

 (2)
 CALL PHANTOM      - генерация декриптора

 Создает декриптор в указанном месте
 Если DEST_CODE=FFFFh, то после генерации DEST_CODE = TARGETOFFS+LENDECRYPTOR

 CALL JuNK_DOIT    - шифрование области,освобождение стека


 Моделирование
 ─────────────

 При генерации не используется никаких сжатых масок - нет принципиально разных
 частей ,поэтому разные декрипторы в общем должны рассматриваться как
 декрипторы одного типа:

 ────────────────────────────────────────────────────────────────────────────
 (1)
 InitUsedRegisters:
 BASE       = 1000h  В произвольном порядке,
 KEY        = RND    с разными регистрами,
 COUNTER    = 3Dh    и разными способами
 SEGBASE    = ES,DS

 mov    bx,0974F  ; BASE    mov    al,068     ; KEY
 push   cs    ; DSBASE  mov    bp,A014    ; BASE
 pop    ds          mov    bx,cs      ; DSBASE
 mov    si,cs     ; ESBASE  mov    ds,bx
 mov    es,si           mov    dx,0003D   ; COUNTER
 mov    al,038    ; KEY     push   cs     ; ESBASE
                pop    es

 (2)
 LoadByteFromCode:  (Present/Abscent)

 Загрузка байта из криптуемого кода в TMP_REG,
 если криптование непосредственно в память,то ничего нет

 mov    ch,es:[bx+78B1]     ------//------

 (3)
 Arithm&amp;Shift[De]Coding:

 Кодирование байта арифметичаскими и логическими командами в REG/MEM
 От 8 до 16 комманд

 Параллельно в стеке создается EncryptionPart состоящий из
 зеркальных комманд в обратном порядке
 При закодировании используется созданный декриптор,но с вызовом EncryptPart

 rol    ch,64           add    ds:[bp][06FEC],00C ; A014+6FEC=1000h
 add    ch,al           add    es:[bp][06FEC],dh
 sub    ah,2E           add    ds:[bp][06FEC],094
 inc    ch          sub    es:[bp][06FEC],06B
 add    ch,FC           add    ds:[bp][06FEC],0A2
 sub    ch,al           inc    es:[bp][06FEC]
 sub    ch,1C           sub    es:[bp][06FEC],dl  ; С счетчиком
 neg    ch          sub    ds:[bp][06FEC],al  ; С ключем
 rol    ch,1            add    es:[bp][06FEC],al
                neg    es:[bp][06FEC]
                not    es:[bp][06FEC]
                inc    ds:[bp][06FEC]
                rol    ds:[bp][06FEC],024
                add    es:[bp][06FEC],066
                rol    es:[bp][06FEC],1

 (4)
 SaveByteFromCode:  (Present/Abscent)

 Сохранение байта в криптуемый код из TMP_REG,
 если криптование непосредственно в память,то ничего нет

 mov    es:[bx+78B1],ch     ------//------

 (5)
 ChangeCnt,Base&amp;TestLimit

 Продвижение Базы  -  ADD/SUB,SUB/ADD,INC

 Уменьшение счетчика цикла  -  DEC
 (если таковой существует)

 Проверка предела  -  CMP or None
 Результат в ZF
 После проверки предела не присутствует мусор

 sub    bx,4C           inc    bp
 add    bx,4D           dec    dx
 cmp    bx,978C

 (5a)
 ChangeKey (не реализовано)
 Изменение ключа всеми доступными способами

 (6)
 JumpIfNotAll

 Цикл по признаку ZF  -  JNE Rel8 , JNE Rel16
 ────────────────────────────────────────────────────────────────────────────

 HISTORY
 ───────

 Версия 1.0 beta

 + Не найдено ошибок. У-рр-а !!!
 + Возможность использования DEST_CODE = FFFFh
 - Нет мусора - уже написан,но неоптимизен,TRCHAIN = RET
 - Нет базирования PHANTOM (и не будет)
 - Нет антиэвристики (и не будет)

 Версия 2.0

 + Сделан генератор мусора включающий в себя весь какой только можно мусор
   с любыми режимами адресации (см. TRCOMM.TXT ). Круче SMEG !
   Включает мусорные подпрограммы и вызовы их. Все CALL'ы адресуются назад.


 - Имеется генерация словного мусора адресующегося в память типа mov ax,[bx]
   Отсюда возможна экзотическая ошибка "заворачивание сегмента"
   Это когда BX=0FFFFh,и при mov ax,[bx] вылетает Exeption 12:Invalid opcode
   Вообще сначала я думал что такой глюк будет встречаться крайне редко,
   но к моему огорчению результаты тестов показали обратное - 1/15.
   Видимо придется оставить только байтовую адресацию в память.А жаль.

 - Крайне принципиальная ошибка.
   Мусорные CALL'ы формируются из 4 offset'ной очереди на предшествующие SUB'ы
   в любом месте программы.Но слежение за регистрами осуществляется линейно
   по ходу формирования декриптора.
   Может возникнуть ситуация когда SUB'рутина мусором изменяет нужный регитср,
   когда в том месте откуда она вызывалась этого уже делать нельзя.
   Но когда генерилась процедура этот регистр был еще свободным для мусора

 Версия 2.1

 + Исправлены CALL'ы :
   Теперь адресация CALL'ов сделана только на впередстоящие SUB'рутины.
   То есть в SUB'ах нужные регистры уже учтены.
   Для пользования FREEREG сделан MaskCALLRequest - запрещает генерацию CALL'ов
 + Возможны вложенные CALL'ы : в одном экземпляре у меня наблюлось 8 вложений.
 - Лишняя сотня байтов . Итого DirectPhantom v2.1 = 2045 байт.
</span></div></body>
</html>
