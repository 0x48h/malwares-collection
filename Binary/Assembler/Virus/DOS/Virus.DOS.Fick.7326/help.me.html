<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Virus.DOS.Fick.7326 - help.me.html</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc0">Note:   This file was first confidentially spread to various virus writers,
        and I finally came to the conclusion that since the nature of GRACE
        will be very generic, av'er cannot take it into account beforehand.
        Therefore it's completely safe to spread this, since most scanners
        still rely on some sort of string scanning, and av'er don't like going
        through thousands of old virus strings if they don't need to.


GRACE
=====

At the moment I'm making plans on writing a virus generator. A virus
generator on itself is not a novel idea. We have seen different
approaches from a menu interface (VCL) to modular code with
configuration files (G2). To avoid making another clone of one of these,
I have decided to take a complete different approach. The program I'm
planning to make is not as much as a virus generator, but more of a kind
of "meta-assembly" language which can be used for virus exploits. The
language can be extended by external C source code, which gets loaded
and compiled by the generator during runtime. The virus code is being
generated from a template file, which contains mixed meta and assembly
code, of which parts can or can not be included, which is decided by a
configuration file for that template (a la PS-MPC).

You see that this is a mighty big project, and it will sure take me a
lot of time to finish it, granted if I succeed at all. I have called
this project GRACE (Generic Random Assembly Construction Engine). To let
GRACE to be of use to you, I need your help. I want you to exchange
ideas with me how the meta language should look like, what possibilities
you want in the language, etc.

Opcodes
=======

GRACE will feature an extended opcode set for generating random
instructions. This can be mixed through the assembler code. Here are a
few examples of what kind of extended opcodes I mean:

        opcode                          could generate

        ZERO &lt;reg&gt;                      MOV &lt;reg&gt;,0
                                        or
                                        SUB &lt;reg&gt;,&lt;reg&gt;
                                        or
                                        CLC
                                        SBB &lt;reg&gt;,&lt;reg&gt;
                                        or
                                        XOR &lt;reg&gt;,&lt;reg&gt;
                                        or
                                        AND &lt;reg&gt;,0

        LOAD &lt;reg&gt;,&lt;reg&gt;|&lt;mem&gt;|&lt;imm&gt;|   MOV &lt;reg&gt;,&lt;rval&gt;
                   &lt;mem+reg&gt; = &lt;rval&gt;   or
                                        ZERO &lt;reg&gt;
                                        ADD &lt;reg&gt;,&lt;rval&gt;
                                        or
                                        ZERO &lt;reg&gt;
                                        OR &lt;reg&gt;,&lt;rval&gt;
                                        or
                                        ZERO &lt;reg&gt;
                                        XOR &lt;reg&gt;,&lt;rval&gt;
                                        or
                                        ZERO &lt;reg&gt;
                                        CLC
                                        ADC &lt;reg&gt;,&lt;rval&gt;

        INCR &lt;reg&gt;|&lt;mem+reg&gt;|           INC &lt;rval&gt;
             &lt;mem&gt; = &lt;rval&gt;             or
                                        ADD &lt;rval&gt;,1
                                        or
                                        SUB &lt;rval&gt;,-1

        DECR &lt;reg&gt;|&lt;mem+reg&gt;|           DEC &lt;rval&gt;
             &lt;mem&gt; = &lt;rval&gt;             or
                                        SUB &lt;rval&gt;,1
                                        or
                                        ADD &lt;rval&gt;,-1

You see the idea here, be creative, thing of nice possible constructs
how to move registers, compare things, do branches, whatever! As you
see, the opcodes can be recursed, so this leaves room for maximum
flexibility.

Example idea of how the meta code would look like with these two
new opcodes:

        open_file:              load ax,3d02h           ; open file
                                load dx,9eh             ; dta :-)
                                int 21h
                                jc error
                                load ax,4202h           ; end of file
                                zero cx
                                zero dx
                                int 21h

Or a simple dencryption loop, which now turns out to be nicely
polymorphically generated:

                                load cx,virus_bytes
                                load si,encrypted_code
decrypt:                        xor byte ptr [si],bvalue
                                incr si
                                decr cx
                                jnz decrypt

Register tracking
=================

If I can do some sort of register tracking, I can see which registers
are free for generating trash functions for between the code, but I
cannot predict what registers get filled with important values after
calling an interrupt. How should I track the registers? I thought the
simplest approach would be using statements for reserving, freeing and
tracking registers. For example:

        load ax,3d02h
        load dx,offset filename
        int 21h
        jc error
        RESERVE AX              ; protects file handle
        some trash code generation opcodes that you have thought of :-)
        FREE AX                 ; frees file handle
        load bx,4202h
        xchg ax,bx
        RESERVE AX,BX           ; protects file handle


Should I try to do some register tracking? It is not so easy to do. What
I can do is let the generator output warning messages that a register
that is reserved is being manipulated, or let GRACE generate push and
pop sequences to save registers? That would not be safe if there is a
branch that jumps out of the RESERVE and FREE statements. Comments
please!

Random Line Ordering
====================

To be truly of use, it should be possible to let lines of code get
swapped, or in case a meta opcode is used, get mixed if possible. How
should I define blocks of lines that can be swapped? I was thinking
about this:

                        BEGIN MIX
                        load si,encrypted_file
                        load cx,virus_bytes
                        END MIX
        decrypt:        xor byte ptr [si],bval
                        incr si
                        decr cx
                        jnz decrypt

or to lseek to the end of the file:

                        BEGIN MIX
                        load ax,4202h
                        zero cx
                        zero dx
                        END MIX

Beware: you cannot mix incr si/decr cx from the 1st example, as the
branch depends on the result on the operation on cx, which gets
destroyed of si gets modified after it.

Random Block Ordering
=====================

I have absolutely no idea how I'll do this, I had an idea about defining
blocks of code with name and level, so blocks can be nested, or should I
autodetect levels, so I can simply use brackets ({}) for defining
blocks? That would make it VERY nice.

{
open_file:      load ax,3d02h
                int 21h
                jc error
                xchg ax,bx
error:          ret
}

{
close_file:     load ah,3eh
                int 21h
                ret
}

check_type:     cmp word ptr [exe_id],'MZ'
                je exefile
                cmp word ptr [exe_id],'ZM'
                je exefile
                jmp comfile
{
  {
  com_file:     etc;
  }
  {
  exe_file:     etc;
  }
}

This makes it very cryptic and you easily can get problems with
branching out of range, so please give me some comments on this one!

Random Register Selector
========================

For some matters (especially encryption loops) it would be nice if you
could load a random register in a symbol, which you could use in your
assembler statements, like a random definition from a c-like
preprocessor. Ofcourse it should work with statements like for example
RESERVE and FREE. Look at this sample:

                BEGIN MIX
                EVO = random("SI","DI","BX")
                RESERVE EVO
                load EVO,encrypted_virus_offset
                COUNTER = random("AX","BX","CX","DX","SI","DI","BP")
                load COUNTER,virus_bytes
                RESERVE COUNTER
                END MIX
decrypt:        xor byte ptr [EVO],bval
                incr EVO
                decr COUNTER
                jnz decrypt
                FREE EVO,COUNTER

Conditionals
============

To make GRACE work with configuration files, the meta language should
support some conditionals that can evaluate strings that have been read
from the configuration file. I can't use the normal IF, since that is a
reserved TASM word. Should I use IFOPT and ENDIFOPT? Or should I create
C-like IF constructs? I can recognize them simply with grammar, since
C's IF uses () and TASM doesn't.

if (tsr == "Y") || (tsr == "Yes")
        hey you see that? If I want to do this approach, I should
        provide some string comparison and manipulation functions... You
        know what I want to ask from you...


The end of the story, the beginning of my biggest project.

If you have any ideas or want to contact me on this project, feel free
to send email to: rajaat@itookmyprozac.com

If there is enough interest, I shall see if I can make some sort of
mailing list to keep people informed, or keep up a homepage of the
progress and discussions.</span></div></body>
</html>
